{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MediaInfo from './media-info.js';\nimport FLVDemuxer from '../demux/flv-demuxer.js';\nimport MP4Remuxer from '../remux/mp4-remuxer.js';\nimport DemuxErrors from '../demux/demux-errors.js';\nimport IOController from '../io/io-controller.js';\nimport TransmuxingEvents from './transmuxing-events.js';\nimport { LoaderStatus, LoaderErrors } from '../io/loader.js'; // Transmuxing (IO, Demuxing, Remuxing) controller, with multipart support\n\nclass TransmuxingController {\n  constructor(mediaDataSource, config) {\n    this.TAG = 'TransmuxingController';\n    this._emitter = new EventEmitter();\n    this._config = config; // treat single part media as multipart media, which has only one segment\n\n    if (!mediaDataSource.segments) {\n      mediaDataSource.segments = [{\n        duration: mediaDataSource.duration,\n        filesize: mediaDataSource.filesize,\n        url: mediaDataSource.url\n      }];\n    } // fill in default IO params if not exists\n\n\n    if (typeof mediaDataSource.cors !== 'boolean') {\n      mediaDataSource.cors = true;\n    }\n\n    if (typeof mediaDataSource.withCredentials !== 'boolean') {\n      mediaDataSource.withCredentials = false;\n    }\n\n    this._mediaDataSource = mediaDataSource;\n    this._currentSegmentIndex = 0;\n    let totalDuration = 0;\n\n    this._mediaDataSource.segments.forEach(segment => {\n      // timestampBase for each segment, and calculate total duration\n      segment.timestampBase = totalDuration;\n      totalDuration += segment.duration; // params needed by IOController\n\n      segment.cors = mediaDataSource.cors;\n      segment.withCredentials = mediaDataSource.withCredentials; // referrer policy control, if exist\n\n      if (config.referrerPolicy) {\n        segment.referrerPolicy = config.referrerPolicy;\n      }\n    });\n\n    if (!isNaN(totalDuration) && this._mediaDataSource.duration !== totalDuration) {\n      this._mediaDataSource.duration = totalDuration;\n    }\n\n    this._mediaInfo = null;\n    this._demuxer = null;\n    this._remuxer = null;\n    this._ioctl = null;\n    this._pendingSeekTime = null;\n    this._pendingResolveSeekPoint = null;\n    this._statisticsReporter = null;\n  }\n\n  destroy() {\n    this._mediaInfo = null;\n    this._mediaDataSource = null;\n\n    if (this._statisticsReporter) {\n      this._disableStatisticsReporter();\n    }\n\n    if (this._ioctl) {\n      this._ioctl.destroy();\n\n      this._ioctl = null;\n    }\n\n    if (this._demuxer) {\n      this._demuxer.destroy();\n\n      this._demuxer = null;\n    }\n\n    if (this._remuxer) {\n      this._remuxer.destroy();\n\n      this._remuxer = null;\n    }\n\n    this._emitter.removeAllListeners();\n\n    this._emitter = null;\n  }\n\n  on(event, listener) {\n    this._emitter.addListener(event, listener);\n  }\n\n  off(event, listener) {\n    this._emitter.removeListener(event, listener);\n  }\n\n  start() {\n    this._loadSegment(0);\n\n    this._enableStatisticsReporter();\n  }\n\n  _loadSegment(segmentIndex, optionalFrom) {\n    this._currentSegmentIndex = segmentIndex;\n    let dataSource = this._mediaDataSource.segments[segmentIndex];\n    let ioctl = this._ioctl = new IOController(dataSource, this._config, segmentIndex);\n    ioctl.onError = this._onIOException.bind(this);\n    ioctl.onSeeked = this._onIOSeeked.bind(this);\n    ioctl.onComplete = this._onIOComplete.bind(this);\n    ioctl.onRedirect = this._onIORedirect.bind(this);\n    ioctl.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this);\n\n    if (optionalFrom) {\n      this._demuxer.bindDataSource(this._ioctl);\n    } else {\n      ioctl.onDataArrival = this._onInitChunkArrival.bind(this);\n    }\n\n    ioctl.open(optionalFrom);\n  }\n\n  stop() {\n    this._internalAbort();\n\n    this._disableStatisticsReporter();\n  }\n\n  _internalAbort() {\n    if (this._ioctl) {\n      this._ioctl.destroy();\n\n      this._ioctl = null;\n    }\n  }\n\n  pause() {\n    // take a rest\n    if (this._ioctl && this._ioctl.isWorking()) {\n      this._ioctl.pause();\n\n      this._disableStatisticsReporter();\n    }\n  }\n\n  resume() {\n    if (this._ioctl && this._ioctl.isPaused()) {\n      this._ioctl.resume();\n\n      this._enableStatisticsReporter();\n    }\n  }\n\n  seek(milliseconds) {\n    if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) {\n      return;\n    }\n\n    let targetSegmentIndex = this._searchSegmentIndexContains(milliseconds);\n\n    if (targetSegmentIndex === this._currentSegmentIndex) {\n      // intra-segment seeking\n      let segmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n      if (segmentInfo == undefined) {\n        // current segment loading started, but mediainfo hasn't received yet\n        // wait for the metadata loaded, then seek to expected position\n        this._pendingSeekTime = milliseconds;\n      } else {\n        let keyframe = segmentInfo.getNearestKeyframe(milliseconds);\n\n        this._remuxer.seek(keyframe.milliseconds);\n\n        this._ioctl.seek(keyframe.fileposition); // Will be resolved in _onRemuxerMediaSegmentArrival()\n\n\n        this._pendingResolveSeekPoint = keyframe.milliseconds;\n      }\n    } else {\n      // cross-segment seeking\n      let targetSegmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n      if (targetSegmentInfo == undefined) {\n        // target segment hasn't been loaded. We need metadata then seek to expected time\n        this._pendingSeekTime = milliseconds;\n\n        this._internalAbort();\n\n        this._remuxer.seek();\n\n        this._remuxer.insertDiscontinuity();\n\n        this._loadSegment(targetSegmentIndex); // Here we wait for the metadata loaded, then seek to expected position\n\n      } else {\n        // We have target segment's metadata, direct seek to target position\n        let keyframe = targetSegmentInfo.getNearestKeyframe(milliseconds);\n\n        this._internalAbort();\n\n        this._remuxer.seek(milliseconds);\n\n        this._remuxer.insertDiscontinuity();\n\n        this._demuxer.resetMediaInfo();\n\n        this._demuxer.timestampBase = this._mediaDataSource.segments[targetSegmentIndex].timestampBase;\n\n        this._loadSegment(targetSegmentIndex, keyframe.fileposition);\n\n        this._pendingResolveSeekPoint = keyframe.milliseconds;\n\n        this._reportSegmentMediaInfo(targetSegmentIndex);\n      }\n    }\n\n    this._enableStatisticsReporter();\n  }\n\n  _searchSegmentIndexContains(milliseconds) {\n    let segments = this._mediaDataSource.segments;\n    let idx = segments.length - 1;\n\n    for (let i = 0; i < segments.length; i++) {\n      if (milliseconds < segments[i].timestampBase) {\n        idx = i - 1;\n        break;\n      }\n    }\n\n    return idx;\n  }\n\n  _onInitChunkArrival(data, byteStart) {\n    let probeData = null;\n    let consumed = 0;\n\n    if (byteStart > 0) {\n      // IOController seeked immediately after opened, byteStart > 0 callback may received\n      this._demuxer.bindDataSource(this._ioctl);\n\n      this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase;\n      consumed = this._demuxer.parseChunks(data, byteStart);\n    } else if ((probeData = FLVDemuxer.probe(data)).match) {\n      // Always create new FLVDemuxer\n      this._demuxer = new FLVDemuxer(probeData, this._config);\n\n      if (!this._remuxer) {\n        this._remuxer = new MP4Remuxer(this._config);\n      }\n\n      let mds = this._mediaDataSource;\n\n      if (mds.duration != undefined && !isNaN(mds.duration)) {\n        this._demuxer.overridedDuration = mds.duration;\n      }\n\n      if (typeof mds.hasAudio === 'boolean') {\n        this._demuxer.overridedHasAudio = mds.hasAudio;\n      }\n\n      if (typeof mds.hasVideo === 'boolean') {\n        this._demuxer.overridedHasVideo = mds.hasVideo;\n      }\n\n      this._demuxer.timestampBase = mds.segments[this._currentSegmentIndex].timestampBase;\n      this._demuxer.onError = this._onDemuxException.bind(this);\n      this._demuxer.onMediaInfo = this._onMediaInfo.bind(this);\n      this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this);\n      this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this);\n\n      this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl));\n\n      this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this);\n      this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this);\n      consumed = this._demuxer.parseChunks(data, byteStart);\n    } else {\n      probeData = null;\n      Log.e(this.TAG, 'Non-FLV, Unsupported media type!');\n      Promise.resolve().then(() => {\n        this._internalAbort();\n      });\n\n      this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, DemuxErrors.FORMAT_UNSUPPORTED, 'Non-FLV, Unsupported media type');\n\n      consumed = 0;\n    }\n\n    return consumed;\n  }\n\n  _onMediaInfo(mediaInfo) {\n    if (this._mediaInfo == null) {\n      // Store first segment's mediainfo as global mediaInfo\n      this._mediaInfo = Object.assign({}, mediaInfo);\n      this._mediaInfo.keyframesIndex = null;\n      this._mediaInfo.segments = [];\n      this._mediaInfo.segmentCount = this._mediaDataSource.segments.length;\n      Object.setPrototypeOf(this._mediaInfo, MediaInfo.prototype);\n    }\n\n    let segmentInfo = Object.assign({}, mediaInfo);\n    Object.setPrototypeOf(segmentInfo, MediaInfo.prototype);\n    this._mediaInfo.segments[this._currentSegmentIndex] = segmentInfo; // notify mediaInfo update\n\n    this._reportSegmentMediaInfo(this._currentSegmentIndex);\n\n    if (this._pendingSeekTime != null) {\n      Promise.resolve().then(() => {\n        let target = this._pendingSeekTime;\n        this._pendingSeekTime = null;\n        this.seek(target);\n      });\n    }\n  }\n\n  _onMetaDataArrived(metadata) {\n    this._emitter.emit(TransmuxingEvents.METADATA_ARRIVED, metadata);\n  }\n\n  _onScriptDataArrived(data) {\n    this._emitter.emit(TransmuxingEvents.SCRIPTDATA_ARRIVED, data);\n  }\n\n  _onIOSeeked() {\n    this._remuxer.insertDiscontinuity();\n  }\n\n  _onIOComplete(extraData) {\n    let segmentIndex = extraData;\n    let nextSegmentIndex = segmentIndex + 1;\n\n    if (nextSegmentIndex < this._mediaDataSource.segments.length) {\n      this._internalAbort();\n\n      this._remuxer.flushStashedSamples();\n\n      this._loadSegment(nextSegmentIndex);\n    } else {\n      this._remuxer.flushStashedSamples();\n\n      this._emitter.emit(TransmuxingEvents.LOADING_COMPLETE);\n\n      this._disableStatisticsReporter();\n    }\n  }\n\n  _onIORedirect(redirectedURL) {\n    let segmentIndex = this._ioctl.extraData;\n    this._mediaDataSource.segments[segmentIndex].redirectedURL = redirectedURL;\n  }\n\n  _onIORecoveredEarlyEof() {\n    this._emitter.emit(TransmuxingEvents.RECOVERED_EARLY_EOF);\n  }\n\n  _onIOException(type, info) {\n    Log.e(this.TAG, `IOException: type = ${type}, code = ${info.code}, msg = ${info.msg}`);\n\n    this._emitter.emit(TransmuxingEvents.IO_ERROR, type, info);\n\n    this._disableStatisticsReporter();\n  }\n\n  _onDemuxException(type, info) {\n    Log.e(this.TAG, `DemuxException: type = ${type}, info = ${info}`);\n\n    this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, type, info);\n  }\n\n  _onRemuxerInitSegmentArrival(type, initSegment) {\n    this._emitter.emit(TransmuxingEvents.INIT_SEGMENT, type, initSegment);\n  }\n\n  _onRemuxerMediaSegmentArrival(type, mediaSegment) {\n    if (this._pendingSeekTime != null) {\n      // Media segments after new-segment cross-seeking should be dropped.\n      return;\n    }\n\n    this._emitter.emit(TransmuxingEvents.MEDIA_SEGMENT, type, mediaSegment); // Resolve pending seekPoint\n\n\n    if (this._pendingResolveSeekPoint != null && type === 'video') {\n      let syncPoints = mediaSegment.info.syncPoints;\n      let seekpoint = this._pendingResolveSeekPoint;\n      this._pendingResolveSeekPoint = null; // Safari: Pass PTS for recommend_seekpoint\n\n      if (Browser.safari && syncPoints.length > 0 && syncPoints[0].originalDts === seekpoint) {\n        seekpoint = syncPoints[0].pts;\n      } // else: use original DTS (keyframe.milliseconds)\n\n\n      this._emitter.emit(TransmuxingEvents.RECOMMEND_SEEKPOINT, seekpoint);\n    }\n  }\n\n  _enableStatisticsReporter() {\n    if (this._statisticsReporter == null) {\n      this._statisticsReporter = self.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval);\n    }\n  }\n\n  _disableStatisticsReporter() {\n    if (this._statisticsReporter) {\n      self.clearInterval(this._statisticsReporter);\n      this._statisticsReporter = null;\n    }\n  }\n\n  _reportSegmentMediaInfo(segmentIndex) {\n    let segmentInfo = this._mediaInfo.segments[segmentIndex];\n    let exportInfo = Object.assign({}, segmentInfo);\n    exportInfo.duration = this._mediaInfo.duration;\n    exportInfo.segmentCount = this._mediaInfo.segmentCount;\n    delete exportInfo.segments;\n    delete exportInfo.keyframesIndex;\n\n    this._emitter.emit(TransmuxingEvents.MEDIA_INFO, exportInfo);\n  }\n\n  _reportStatisticsInfo() {\n    let info = {};\n    info.url = this._ioctl.currentURL;\n    info.hasRedirect = this._ioctl.hasRedirect;\n\n    if (info.hasRedirect) {\n      info.redirectedURL = this._ioctl.currentRedirectedURL;\n    }\n\n    info.speed = this._ioctl.currentSpeed;\n    info.loaderType = this._ioctl.loaderType;\n    info.currentSegmentIndex = this._currentSegmentIndex;\n    info.totalSegmentCount = this._mediaDataSource.segments.length;\n\n    this._emitter.emit(TransmuxingEvents.STATISTICS_INFO, info);\n  }\n\n}\n\nexport default TransmuxingController;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/core/transmuxing-controller.js"],"names":["EventEmitter","Log","Browser","MediaInfo","FLVDemuxer","MP4Remuxer","DemuxErrors","IOController","TransmuxingEvents","LoaderStatus","LoaderErrors","TransmuxingController","constructor","mediaDataSource","config","TAG","_emitter","_config","segments","duration","filesize","url","cors","withCredentials","_mediaDataSource","_currentSegmentIndex","totalDuration","forEach","segment","timestampBase","referrerPolicy","isNaN","_mediaInfo","_demuxer","_remuxer","_ioctl","_pendingSeekTime","_pendingResolveSeekPoint","_statisticsReporter","destroy","_disableStatisticsReporter","removeAllListeners","on","event","listener","addListener","off","removeListener","start","_loadSegment","_enableStatisticsReporter","segmentIndex","optionalFrom","dataSource","ioctl","onError","_onIOException","bind","onSeeked","_onIOSeeked","onComplete","_onIOComplete","onRedirect","_onIORedirect","onRecoveredEarlyEof","_onIORecoveredEarlyEof","bindDataSource","onDataArrival","_onInitChunkArrival","open","stop","_internalAbort","pause","isWorking","resume","isPaused","seek","milliseconds","isSeekable","targetSegmentIndex","_searchSegmentIndexContains","segmentInfo","undefined","keyframe","getNearestKeyframe","fileposition","targetSegmentInfo","insertDiscontinuity","resetMediaInfo","_reportSegmentMediaInfo","idx","length","i","data","byteStart","probeData","consumed","parseChunks","probe","match","mds","overridedDuration","hasAudio","overridedHasAudio","hasVideo","overridedHasVideo","_onDemuxException","onMediaInfo","_onMediaInfo","onMetaDataArrived","_onMetaDataArrived","onScriptDataArrived","_onScriptDataArrived","onInitSegment","_onRemuxerInitSegmentArrival","onMediaSegment","_onRemuxerMediaSegmentArrival","e","Promise","resolve","then","emit","DEMUX_ERROR","FORMAT_UNSUPPORTED","mediaInfo","Object","assign","keyframesIndex","segmentCount","setPrototypeOf","prototype","target","metadata","METADATA_ARRIVED","SCRIPTDATA_ARRIVED","extraData","nextSegmentIndex","flushStashedSamples","LOADING_COMPLETE","redirectedURL","RECOVERED_EARLY_EOF","type","info","code","msg","IO_ERROR","initSegment","INIT_SEGMENT","mediaSegment","MEDIA_SEGMENT","syncPoints","seekpoint","safari","originalDts","pts","RECOMMEND_SEEKPOINT","self","setInterval","_reportStatisticsInfo","statisticsInfoReportInterval","clearInterval","exportInfo","MEDIA_INFO","currentURL","hasRedirect","currentRedirectedURL","speed","currentSpeed","loaderType","currentSegmentIndex","totalSegmentCount","STATISTICS_INFO"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MediaInfo from './media-info.js';\nimport FLVDemuxer from '../demux/flv-demuxer.js';\nimport MP4Remuxer from '../remux/mp4-remuxer.js';\nimport DemuxErrors from '../demux/demux-errors.js';\nimport IOController from '../io/io-controller.js';\nimport TransmuxingEvents from './transmuxing-events.js';\nimport {LoaderStatus, LoaderErrors} from '../io/loader.js';\n\n// Transmuxing (IO, Demuxing, Remuxing) controller, with multipart support\nclass TransmuxingController {\n\n    constructor(mediaDataSource, config) {\n        this.TAG = 'TransmuxingController';\n        this._emitter = new EventEmitter();\n\n        this._config = config;\n\n        // treat single part media as multipart media, which has only one segment\n        if (!mediaDataSource.segments) {\n            mediaDataSource.segments = [{\n                duration: mediaDataSource.duration,\n                filesize: mediaDataSource.filesize,\n                url: mediaDataSource.url\n            }];\n        }\n\n        // fill in default IO params if not exists\n        if (typeof mediaDataSource.cors !== 'boolean') {\n            mediaDataSource.cors = true;\n        }\n        if (typeof mediaDataSource.withCredentials !== 'boolean') {\n            mediaDataSource.withCredentials = false;\n        }\n\n        this._mediaDataSource = mediaDataSource;\n        this._currentSegmentIndex = 0;\n        let totalDuration = 0;\n\n        this._mediaDataSource.segments.forEach((segment) => {\n            // timestampBase for each segment, and calculate total duration\n            segment.timestampBase = totalDuration;\n            totalDuration += segment.duration;\n            // params needed by IOController\n            segment.cors = mediaDataSource.cors;\n            segment.withCredentials = mediaDataSource.withCredentials;\n            // referrer policy control, if exist\n            if (config.referrerPolicy) {\n                segment.referrerPolicy = config.referrerPolicy;\n            }\n        });\n\n        if (!isNaN(totalDuration) && this._mediaDataSource.duration !== totalDuration) {\n            this._mediaDataSource.duration = totalDuration;\n        }\n\n        this._mediaInfo = null;\n        this._demuxer = null;\n        this._remuxer = null;\n        this._ioctl = null;\n\n        this._pendingSeekTime = null;\n        this._pendingResolveSeekPoint = null;\n\n        this._statisticsReporter = null;\n    }\n\n    destroy() {\n        this._mediaInfo = null;\n        this._mediaDataSource = null;\n\n        if (this._statisticsReporter) {\n            this._disableStatisticsReporter();\n        }\n        if (this._ioctl) {\n            this._ioctl.destroy();\n            this._ioctl = null;\n        }\n        if (this._demuxer) {\n            this._demuxer.destroy();\n            this._demuxer = null;\n        }\n        if (this._remuxer) {\n            this._remuxer.destroy();\n            this._remuxer = null;\n        }\n\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n    }\n\n    on(event, listener) {\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n\n    start() {\n        this._loadSegment(0);\n        this._enableStatisticsReporter();\n    }\n\n    _loadSegment(segmentIndex, optionalFrom) {\n        this._currentSegmentIndex = segmentIndex;\n        let dataSource = this._mediaDataSource.segments[segmentIndex];\n\n        let ioctl = this._ioctl = new IOController(dataSource, this._config, segmentIndex);\n        ioctl.onError = this._onIOException.bind(this);\n        ioctl.onSeeked = this._onIOSeeked.bind(this);\n        ioctl.onComplete = this._onIOComplete.bind(this);\n        ioctl.onRedirect = this._onIORedirect.bind(this);\n        ioctl.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this);\n\n        if (optionalFrom) {\n            this._demuxer.bindDataSource(this._ioctl);\n        } else {\n            ioctl.onDataArrival = this._onInitChunkArrival.bind(this);\n        }\n\n        ioctl.open(optionalFrom);\n    }\n\n    stop() {\n        this._internalAbort();\n        this._disableStatisticsReporter();\n    }\n\n    _internalAbort() {\n        if (this._ioctl) {\n            this._ioctl.destroy();\n            this._ioctl = null;\n        }\n    }\n\n    pause() {  // take a rest\n        if (this._ioctl && this._ioctl.isWorking()) {\n            this._ioctl.pause();\n            this._disableStatisticsReporter();\n        }\n    }\n\n    resume() {\n        if (this._ioctl && this._ioctl.isPaused()) {\n            this._ioctl.resume();\n            this._enableStatisticsReporter();\n        }\n    }\n\n    seek(milliseconds) {\n        if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) {\n            return;\n        }\n\n        let targetSegmentIndex = this._searchSegmentIndexContains(milliseconds);\n\n        if (targetSegmentIndex === this._currentSegmentIndex) {\n            // intra-segment seeking\n            let segmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n            if (segmentInfo == undefined) {\n                // current segment loading started, but mediainfo hasn't received yet\n                // wait for the metadata loaded, then seek to expected position\n                this._pendingSeekTime = milliseconds;\n            } else {\n                let keyframe = segmentInfo.getNearestKeyframe(milliseconds);\n                this._remuxer.seek(keyframe.milliseconds);\n                this._ioctl.seek(keyframe.fileposition);\n                // Will be resolved in _onRemuxerMediaSegmentArrival()\n                this._pendingResolveSeekPoint = keyframe.milliseconds;\n            }\n        } else {\n            // cross-segment seeking\n            let targetSegmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n            if (targetSegmentInfo == undefined) {\n                // target segment hasn't been loaded. We need metadata then seek to expected time\n                this._pendingSeekTime = milliseconds;\n                this._internalAbort();\n                this._remuxer.seek();\n                this._remuxer.insertDiscontinuity();\n                this._loadSegment(targetSegmentIndex);\n                // Here we wait for the metadata loaded, then seek to expected position\n            } else {\n                // We have target segment's metadata, direct seek to target position\n                let keyframe = targetSegmentInfo.getNearestKeyframe(milliseconds);\n                this._internalAbort();\n                this._remuxer.seek(milliseconds);\n                this._remuxer.insertDiscontinuity();\n                this._demuxer.resetMediaInfo();\n                this._demuxer.timestampBase = this._mediaDataSource.segments[targetSegmentIndex].timestampBase;\n                this._loadSegment(targetSegmentIndex, keyframe.fileposition);\n                this._pendingResolveSeekPoint = keyframe.milliseconds;\n                this._reportSegmentMediaInfo(targetSegmentIndex);\n            }\n        }\n\n        this._enableStatisticsReporter();\n    }\n\n    _searchSegmentIndexContains(milliseconds) {\n        let segments = this._mediaDataSource.segments;\n        let idx = segments.length - 1;\n\n        for (let i = 0; i < segments.length; i++) {\n            if (milliseconds < segments[i].timestampBase) {\n                idx = i - 1;\n                break;\n            }\n        }\n        return idx;\n    }\n\n    _onInitChunkArrival(data, byteStart) {\n        let probeData = null;\n        let consumed = 0;\n\n        if (byteStart > 0) {\n            // IOController seeked immediately after opened, byteStart > 0 callback may received\n            this._demuxer.bindDataSource(this._ioctl);\n            this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase;\n\n            consumed = this._demuxer.parseChunks(data, byteStart);\n        } else if ((probeData = FLVDemuxer.probe(data)).match) {\n            // Always create new FLVDemuxer\n            this._demuxer = new FLVDemuxer(probeData, this._config);\n\n            if (!this._remuxer) {\n                this._remuxer = new MP4Remuxer(this._config);\n            }\n\n            let mds = this._mediaDataSource;\n            if (mds.duration != undefined && !isNaN(mds.duration)) {\n                this._demuxer.overridedDuration = mds.duration;\n            }\n            if (typeof mds.hasAudio === 'boolean') {\n                this._demuxer.overridedHasAudio = mds.hasAudio;\n            }\n            if (typeof mds.hasVideo === 'boolean') {\n                this._demuxer.overridedHasVideo = mds.hasVideo;\n            }\n\n            this._demuxer.timestampBase = mds.segments[this._currentSegmentIndex].timestampBase;\n\n            this._demuxer.onError = this._onDemuxException.bind(this);\n            this._demuxer.onMediaInfo = this._onMediaInfo.bind(this);\n            this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this);\n            this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this);\n\n            this._remuxer.bindDataSource(this._demuxer\n                         .bindDataSource(this._ioctl\n            ));\n\n            this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this);\n            this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this);\n\n            consumed = this._demuxer.parseChunks(data, byteStart);\n        } else {\n            probeData = null;\n            Log.e(this.TAG, 'Non-FLV, Unsupported media type!');\n            Promise.resolve().then(() => {\n                this._internalAbort();\n            });\n            this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, DemuxErrors.FORMAT_UNSUPPORTED, 'Non-FLV, Unsupported media type');\n\n            consumed = 0;\n        }\n\n        return consumed;\n    }\n\n    _onMediaInfo(mediaInfo) {\n        if (this._mediaInfo == null) {\n            // Store first segment's mediainfo as global mediaInfo\n            this._mediaInfo = Object.assign({}, mediaInfo);\n            this._mediaInfo.keyframesIndex = null;\n            this._mediaInfo.segments = [];\n            this._mediaInfo.segmentCount = this._mediaDataSource.segments.length;\n            Object.setPrototypeOf(this._mediaInfo, MediaInfo.prototype);\n        }\n\n        let segmentInfo = Object.assign({}, mediaInfo);\n        Object.setPrototypeOf(segmentInfo, MediaInfo.prototype);\n        this._mediaInfo.segments[this._currentSegmentIndex] = segmentInfo;\n\n        // notify mediaInfo update\n        this._reportSegmentMediaInfo(this._currentSegmentIndex);\n\n        if (this._pendingSeekTime != null) {\n            Promise.resolve().then(() => {\n                let target = this._pendingSeekTime;\n                this._pendingSeekTime = null;\n                this.seek(target);\n            });\n        }\n    }\n\n    _onMetaDataArrived(metadata) {\n        this._emitter.emit(TransmuxingEvents.METADATA_ARRIVED, metadata);\n    }\n\n    _onScriptDataArrived(data) {\n        this._emitter.emit(TransmuxingEvents.SCRIPTDATA_ARRIVED, data);\n    }\n\n    _onIOSeeked() {\n        this._remuxer.insertDiscontinuity();\n    }\n\n    _onIOComplete(extraData) {\n        let segmentIndex = extraData;\n        let nextSegmentIndex = segmentIndex + 1;\n\n        if (nextSegmentIndex < this._mediaDataSource.segments.length) {\n            this._internalAbort();\n            this._remuxer.flushStashedSamples();\n            this._loadSegment(nextSegmentIndex);\n        } else {\n            this._remuxer.flushStashedSamples();\n            this._emitter.emit(TransmuxingEvents.LOADING_COMPLETE);\n            this._disableStatisticsReporter();\n        }\n    }\n\n    _onIORedirect(redirectedURL) {\n        let segmentIndex = this._ioctl.extraData;\n        this._mediaDataSource.segments[segmentIndex].redirectedURL = redirectedURL;\n    }\n\n    _onIORecoveredEarlyEof() {\n        this._emitter.emit(TransmuxingEvents.RECOVERED_EARLY_EOF);\n    }\n\n    _onIOException(type, info) {\n        Log.e(this.TAG, `IOException: type = ${type}, code = ${info.code}, msg = ${info.msg}`);\n        this._emitter.emit(TransmuxingEvents.IO_ERROR, type, info);\n        this._disableStatisticsReporter();\n    }\n\n    _onDemuxException(type, info) {\n        Log.e(this.TAG, `DemuxException: type = ${type}, info = ${info}`);\n        this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, type, info);\n    }\n\n    _onRemuxerInitSegmentArrival(type, initSegment) {\n        this._emitter.emit(TransmuxingEvents.INIT_SEGMENT, type, initSegment);\n    }\n\n    _onRemuxerMediaSegmentArrival(type, mediaSegment) {\n        if (this._pendingSeekTime != null) {\n            // Media segments after new-segment cross-seeking should be dropped.\n            return;\n        }\n        this._emitter.emit(TransmuxingEvents.MEDIA_SEGMENT, type, mediaSegment);\n\n        // Resolve pending seekPoint\n        if (this._pendingResolveSeekPoint != null && type === 'video') {\n            let syncPoints = mediaSegment.info.syncPoints;\n            let seekpoint = this._pendingResolveSeekPoint;\n            this._pendingResolveSeekPoint = null;\n\n            // Safari: Pass PTS for recommend_seekpoint\n            if (Browser.safari && syncPoints.length > 0 && syncPoints[0].originalDts === seekpoint) {\n                seekpoint = syncPoints[0].pts;\n            }\n            // else: use original DTS (keyframe.milliseconds)\n\n            this._emitter.emit(TransmuxingEvents.RECOMMEND_SEEKPOINT, seekpoint);\n        }\n    }\n\n    _enableStatisticsReporter() {\n        if (this._statisticsReporter == null) {\n            this._statisticsReporter = self.setInterval(\n                this._reportStatisticsInfo.bind(this),\n            this._config.statisticsInfoReportInterval);\n        }\n    }\n\n    _disableStatisticsReporter() {\n        if (this._statisticsReporter) {\n            self.clearInterval(this._statisticsReporter);\n            this._statisticsReporter = null;\n        }\n    }\n\n    _reportSegmentMediaInfo(segmentIndex) {\n        let segmentInfo = this._mediaInfo.segments[segmentIndex];\n        let exportInfo = Object.assign({}, segmentInfo);\n\n        exportInfo.duration = this._mediaInfo.duration;\n        exportInfo.segmentCount = this._mediaInfo.segmentCount;\n        delete exportInfo.segments;\n        delete exportInfo.keyframesIndex;\n\n        this._emitter.emit(TransmuxingEvents.MEDIA_INFO, exportInfo);\n    }\n\n    _reportStatisticsInfo() {\n        let info = {};\n\n        info.url = this._ioctl.currentURL;\n        info.hasRedirect = this._ioctl.hasRedirect;\n        if (info.hasRedirect) {\n            info.redirectedURL = this._ioctl.currentRedirectedURL;\n        }\n\n        info.speed = this._ioctl.currentSpeed;\n        info.loaderType = this._ioctl.loaderType;\n        info.currentSegmentIndex = this._currentSegmentIndex;\n        info.totalSegmentCount = this._mediaDataSource.segments.length;\n\n        this._emitter.emit(TransmuxingEvents.STATISTICS_INFO, info);\n    }\n\n}\n\nexport default TransmuxingController;"]},"metadata":{},"sourceType":"module"}