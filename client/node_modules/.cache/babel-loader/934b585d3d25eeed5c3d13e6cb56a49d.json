{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport AMF from './amf-parser.js';\nimport SPSParser from './sps-parser.js';\nimport DemuxErrors from './demux-errors.js';\nimport MediaInfo from '../core/media-info.js';\nimport { IllegalStateException } from '../utils/exception.js';\n\nfunction Swap16(src) {\n  return src >>> 8 & 0xFF | (src & 0xFF) << 8;\n}\n\nfunction Swap32(src) {\n  return (src & 0xFF000000) >>> 24 | (src & 0x00FF0000) >>> 8 | (src & 0x0000FF00) << 8 | (src & 0x000000FF) << 24;\n}\n\nfunction ReadBig32(array, index) {\n  return array[index] << 24 | array[index + 1] << 16 | array[index + 2] << 8 | array[index + 3];\n}\n\nclass FLVDemuxer {\n  constructor(probeData, config) {\n    this.TAG = 'FLVDemuxer';\n    this._config = config;\n    this._onError = null;\n    this._onMediaInfo = null;\n    this._onMetaDataArrived = null;\n    this._onScriptDataArrived = null;\n    this._onTrackMetadata = null;\n    this._onDataAvailable = null;\n    this._dataOffset = probeData.dataOffset;\n    this._firstParse = true;\n    this._dispatch = false;\n    this._hasAudio = probeData.hasAudioTrack;\n    this._hasVideo = probeData.hasVideoTrack;\n    this._hasAudioFlagOverrided = false;\n    this._hasVideoFlagOverrided = false;\n    this._audioInitialMetadataDispatched = false;\n    this._videoInitialMetadataDispatched = false;\n    this._mediaInfo = new MediaInfo();\n    this._mediaInfo.hasAudio = this._hasAudio;\n    this._mediaInfo.hasVideo = this._hasVideo;\n    this._metadata = null;\n    this._audioMetadata = null;\n    this._videoMetadata = null;\n    this._naluLengthSize = 4;\n    this._timestampBase = 0; // int32, in milliseconds\n\n    this._timescale = 1000;\n    this._duration = 0; // int32, in milliseconds\n\n    this._durationOverrided = false;\n    this._referenceFrameRate = {\n      fixed: true,\n      fps: 23.976,\n      fps_num: 23976,\n      fps_den: 1000\n    };\n    this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\n    this._mpegSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\n    this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\n    this._mpegAudioV25SampleRateTable = [11025, 12000, 8000, 0];\n    this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\n    this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\n    this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];\n    this._videoTrack = {\n      type: 'video',\n      id: 1,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n    this._audioTrack = {\n      type: 'audio',\n      id: 2,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n\n    this._littleEndian = function () {\n      let buf = new ArrayBuffer(2);\n      new DataView(buf).setInt16(0, 256, true); // little-endian write\n\n      return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n    }();\n  }\n\n  destroy() {\n    this._mediaInfo = null;\n    this._metadata = null;\n    this._audioMetadata = null;\n    this._videoMetadata = null;\n    this._videoTrack = null;\n    this._audioTrack = null;\n    this._onError = null;\n    this._onMediaInfo = null;\n    this._onMetaDataArrived = null;\n    this._onScriptDataArrived = null;\n    this._onTrackMetadata = null;\n    this._onDataAvailable = null;\n  }\n\n  static probe(buffer) {\n    let data = new Uint8Array(buffer);\n    let mismatch = {\n      match: false\n    };\n\n    if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n      return mismatch;\n    }\n\n    let hasAudio = (data[4] & 4) >>> 2 !== 0;\n    let hasVideo = (data[4] & 1) !== 0;\n    let offset = ReadBig32(data, 5);\n\n    if (offset < 9) {\n      return mismatch;\n    }\n\n    return {\n      match: true,\n      consumed: offset,\n      dataOffset: offset,\n      hasAudioTrack: hasAudio,\n      hasVideoTrack: hasVideo\n    };\n  }\n\n  bindDataSource(loader) {\n    loader.onDataArrival = this.parseChunks.bind(this);\n    return this;\n  } // prototype: function(type: string, metadata: any): void\n\n\n  get onTrackMetadata() {\n    return this._onTrackMetadata;\n  }\n\n  set onTrackMetadata(callback) {\n    this._onTrackMetadata = callback;\n  } // prototype: function(mediaInfo: MediaInfo): void\n\n\n  get onMediaInfo() {\n    return this._onMediaInfo;\n  }\n\n  set onMediaInfo(callback) {\n    this._onMediaInfo = callback;\n  }\n\n  get onMetaDataArrived() {\n    return this._onMetaDataArrived;\n  }\n\n  set onMetaDataArrived(callback) {\n    this._onMetaDataArrived = callback;\n  }\n\n  get onScriptDataArrived() {\n    return this._onScriptDataArrived;\n  }\n\n  set onScriptDataArrived(callback) {\n    this._onScriptDataArrived = callback;\n  } // prototype: function(type: number, info: string): void\n\n\n  get onError() {\n    return this._onError;\n  }\n\n  set onError(callback) {\n    this._onError = callback;\n  } // prototype: function(videoTrack: any, audioTrack: any): void\n\n\n  get onDataAvailable() {\n    return this._onDataAvailable;\n  }\n\n  set onDataAvailable(callback) {\n    this._onDataAvailable = callback;\n  } // timestamp base for output samples, must be in milliseconds\n\n\n  get timestampBase() {\n    return this._timestampBase;\n  }\n\n  set timestampBase(base) {\n    this._timestampBase = base;\n  }\n\n  get overridedDuration() {\n    return this._duration;\n  } // Force-override media duration. Must be in milliseconds, int32\n\n\n  set overridedDuration(duration) {\n    this._durationOverrided = true;\n    this._duration = duration;\n    this._mediaInfo.duration = duration;\n  } // Force-override audio track present flag, boolean\n\n\n  set overridedHasAudio(hasAudio) {\n    this._hasAudioFlagOverrided = true;\n    this._hasAudio = hasAudio;\n    this._mediaInfo.hasAudio = hasAudio;\n  } // Force-override video track present flag, boolean\n\n\n  set overridedHasVideo(hasVideo) {\n    this._hasVideoFlagOverrided = true;\n    this._hasVideo = hasVideo;\n    this._mediaInfo.hasVideo = hasVideo;\n  }\n\n  resetMediaInfo() {\n    this._mediaInfo = new MediaInfo();\n  }\n\n  _isInitialMetadataDispatched() {\n    if (this._hasAudio && this._hasVideo) {\n      // both audio & video\n      return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n    }\n\n    if (this._hasAudio && !this._hasVideo) {\n      // audio only\n      return this._audioInitialMetadataDispatched;\n    }\n\n    if (!this._hasAudio && this._hasVideo) {\n      // video only\n      return this._videoInitialMetadataDispatched;\n    }\n\n    return false;\n  } // function parseChunks(chunk: ArrayBuffer, byteStart: number): number;\n\n\n  parseChunks(chunk, byteStart) {\n    if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\n      throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\n    }\n\n    let offset = 0;\n    let le = this._littleEndian;\n\n    if (byteStart === 0) {\n      // buffer with FLV header\n      if (chunk.byteLength > 13) {\n        let probeData = FLVDemuxer.probe(chunk);\n        offset = probeData.dataOffset;\n      } else {\n        return 0;\n      }\n    }\n\n    if (this._firstParse) {\n      // handle PreviousTagSize0 before Tag1\n      this._firstParse = false;\n\n      if (byteStart + offset !== this._dataOffset) {\n        Log.w(this.TAG, 'First time parsing but chunk byteStart invalid!');\n      }\n\n      let v = new DataView(chunk, offset);\n      let prevTagSize0 = v.getUint32(0, !le);\n\n      if (prevTagSize0 !== 0) {\n        Log.w(this.TAG, 'PrevTagSize0 !== 0 !!!');\n      }\n\n      offset += 4;\n    }\n\n    while (offset < chunk.byteLength) {\n      this._dispatch = true;\n      let v = new DataView(chunk, offset);\n\n      if (offset + 11 + 4 > chunk.byteLength) {\n        // data not enough for parsing an flv tag\n        break;\n      }\n\n      let tagType = v.getUint8(0);\n      let dataSize = v.getUint32(0, !le) & 0x00FFFFFF;\n\n      if (offset + 11 + dataSize + 4 > chunk.byteLength) {\n        // data not enough for parsing actual data body\n        break;\n      }\n\n      if (tagType !== 8 && tagType !== 9 && tagType !== 18) {\n        Log.w(this.TAG, `Unsupported tag type ${tagType}, skipped`); // consume the whole tag (skip it)\n\n        offset += 11 + dataSize + 4;\n        continue;\n      }\n\n      let ts2 = v.getUint8(4);\n      let ts1 = v.getUint8(5);\n      let ts0 = v.getUint8(6);\n      let ts3 = v.getUint8(7);\n      let timestamp = ts0 | ts1 << 8 | ts2 << 16 | ts3 << 24;\n      let streamId = v.getUint32(7, !le) & 0x00FFFFFF;\n\n      if (streamId !== 0) {\n        Log.w(this.TAG, 'Meet tag which has StreamID != 0!');\n      }\n\n      let dataOffset = offset + 11;\n\n      switch (tagType) {\n        case 8:\n          // Audio\n          this._parseAudioData(chunk, dataOffset, dataSize, timestamp);\n\n          break;\n\n        case 9:\n          // Video\n          this._parseVideoData(chunk, dataOffset, dataSize, timestamp, byteStart + offset);\n\n          break;\n\n        case 18:\n          // ScriptDataObject\n          this._parseScriptData(chunk, dataOffset, dataSize);\n\n          break;\n      }\n\n      let prevTagSize = v.getUint32(11 + dataSize, !le);\n\n      if (prevTagSize !== 11 + dataSize) {\n        Log.w(this.TAG, `Invalid PrevTagSize ${prevTagSize}`);\n      }\n\n      offset += 11 + dataSize + 4; // tagBody + dataSize + prevTagSize\n    } // dispatch parsed frames to consumer (typically, the remuxer)\n\n\n    if (this._isInitialMetadataDispatched()) {\n      if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n        this._onDataAvailable(this._audioTrack, this._videoTrack);\n      }\n    }\n\n    return offset; // consumed bytes, just equals latest offset index\n  }\n\n  _parseScriptData(arrayBuffer, dataOffset, dataSize) {\n    let scriptData = AMF.parseScriptData(arrayBuffer, dataOffset, dataSize);\n\n    if (scriptData.hasOwnProperty('onMetaData')) {\n      if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\n        Log.w(this.TAG, 'Invalid onMetaData structure!');\n        return;\n      }\n\n      if (this._metadata) {\n        Log.w(this.TAG, 'Found another onMetaData tag!');\n      }\n\n      this._metadata = scriptData;\n      let onMetaData = this._metadata.onMetaData;\n\n      if (this._onMetaDataArrived) {\n        this._onMetaDataArrived(Object.assign({}, onMetaData));\n      }\n\n      if (typeof onMetaData.hasAudio === 'boolean') {\n        // hasAudio\n        if (this._hasAudioFlagOverrided === false) {\n          this._hasAudio = onMetaData.hasAudio;\n          this._mediaInfo.hasAudio = this._hasAudio;\n        }\n      }\n\n      if (typeof onMetaData.hasVideo === 'boolean') {\n        // hasVideo\n        if (this._hasVideoFlagOverrided === false) {\n          this._hasVideo = onMetaData.hasVideo;\n          this._mediaInfo.hasVideo = this._hasVideo;\n        }\n      }\n\n      if (typeof onMetaData.audiodatarate === 'number') {\n        // audiodatarate\n        this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n      }\n\n      if (typeof onMetaData.videodatarate === 'number') {\n        // videodatarate\n        this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n      }\n\n      if (typeof onMetaData.width === 'number') {\n        // width\n        this._mediaInfo.width = onMetaData.width;\n      }\n\n      if (typeof onMetaData.height === 'number') {\n        // height\n        this._mediaInfo.height = onMetaData.height;\n      }\n\n      if (typeof onMetaData.duration === 'number') {\n        // duration\n        if (!this._durationOverrided) {\n          let duration = Math.floor(onMetaData.duration * this._timescale);\n          this._duration = duration;\n          this._mediaInfo.duration = duration;\n        }\n      } else {\n        this._mediaInfo.duration = 0;\n      }\n\n      if (typeof onMetaData.framerate === 'number') {\n        // framerate\n        let fps_num = Math.floor(onMetaData.framerate * 1000);\n\n        if (fps_num > 0) {\n          let fps = fps_num / 1000;\n          this._referenceFrameRate.fixed = true;\n          this._referenceFrameRate.fps = fps;\n          this._referenceFrameRate.fps_num = fps_num;\n          this._referenceFrameRate.fps_den = 1000;\n          this._mediaInfo.fps = fps;\n        }\n      }\n\n      if (typeof onMetaData.keyframes === 'object') {\n        // keyframes\n        this._mediaInfo.hasKeyframesIndex = true;\n        let keyframes = onMetaData.keyframes;\n        this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n        onMetaData.keyframes = null; // keyframes has been extracted, remove it\n      } else {\n        this._mediaInfo.hasKeyframesIndex = false;\n      }\n\n      this._dispatch = false;\n      this._mediaInfo.metadata = onMetaData;\n      Log.v(this.TAG, 'Parsed onMetaData');\n\n      if (this._mediaInfo.isComplete()) {\n        this._onMediaInfo(this._mediaInfo);\n      }\n    }\n\n    if (Object.keys(scriptData).length > 0) {\n      if (this._onScriptDataArrived) {\n        this._onScriptDataArrived(Object.assign({}, scriptData));\n      }\n    }\n  }\n\n  _parseKeyframesIndex(keyframes) {\n    let times = [];\n    let filepositions = []; // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n\n    for (let i = 1; i < keyframes.times.length; i++) {\n      let time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n      times.push(time);\n      filepositions.push(keyframes.filepositions[i]);\n    }\n\n    return {\n      times: times,\n      filepositions: filepositions\n    };\n  }\n\n  _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n    if (dataSize <= 1) {\n      Log.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n      return;\n    }\n\n    if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\n      // If hasAudio: false indicated explicitly in MediaDataSource,\n      // Ignore all the audio packets\n      return;\n    }\n\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let soundSpec = v.getUint8(0);\n    let soundFormat = soundSpec >>> 4;\n\n    if (soundFormat !== 2 && soundFormat !== 10) {\n      // MP3 or AAC\n      this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n\n      return;\n    }\n\n    let soundRate = 0;\n    let soundRateIndex = (soundSpec & 12) >>> 2;\n\n    if (soundRateIndex >= 0 && soundRateIndex <= 4) {\n      soundRate = this._flvSoundRateTable[soundRateIndex];\n    } else {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n\n      return;\n    }\n\n    let soundSize = (soundSpec & 2) >>> 1; // unused\n\n    let soundType = soundSpec & 1;\n    let meta = this._audioMetadata;\n    let track = this._audioTrack;\n\n    if (!meta) {\n      if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\n        this._hasAudio = true;\n        this._mediaInfo.hasAudio = true;\n      } // initial metadata\n\n\n      meta = this._audioMetadata = {};\n      meta.type = 'audio';\n      meta.id = track.id;\n      meta.timescale = this._timescale;\n      meta.duration = this._duration;\n      meta.audioSampleRate = soundRate;\n      meta.channelCount = soundType === 0 ? 1 : 2;\n    }\n\n    if (soundFormat === 10) {\n      // AAC\n      let aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n\n      if (aacData == undefined) {\n        return;\n      }\n\n      if (aacData.packetType === 0) {\n        // AAC sequence header (AudioSpecificConfig)\n        if (meta.config) {\n          Log.w(this.TAG, 'Found another AudioSpecificConfig!');\n        }\n\n        let misc = aacData.data;\n        meta.audioSampleRate = misc.samplingRate;\n        meta.channelCount = misc.channelCount;\n        meta.codec = misc.codec;\n        meta.originalCodec = misc.originalCodec;\n        meta.config = misc.config; // The decode result of an aac sample is 1024 PCM samples\n\n        meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\n        Log.v(this.TAG, 'Parsed AudioSpecificConfig');\n\n        if (this._isInitialMetadataDispatched()) {\n          // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n          if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n            this._onDataAvailable(this._audioTrack, this._videoTrack);\n          }\n        } else {\n          this._audioInitialMetadataDispatched = true;\n        } // then notify new metadata\n\n\n        this._dispatch = false;\n\n        this._onTrackMetadata('audio', meta);\n\n        let mi = this._mediaInfo;\n        mi.audioCodec = meta.originalCodec;\n        mi.audioSampleRate = meta.audioSampleRate;\n        mi.audioChannelCount = meta.channelCount;\n\n        if (mi.hasVideo) {\n          if (mi.videoCodec != null) {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n          }\n        } else {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n        }\n\n        if (mi.isComplete()) {\n          this._onMediaInfo(mi);\n        }\n      } else if (aacData.packetType === 1) {\n        // AAC raw frame data\n        let dts = this._timestampBase + tagTimestamp;\n        let aacSample = {\n          unit: aacData.data,\n          length: aacData.data.byteLength,\n          dts: dts,\n          pts: dts\n        };\n        track.samples.push(aacSample);\n        track.length += aacData.data.length;\n      } else {\n        Log.e(this.TAG, `Flv: Unsupported AAC data type ${aacData.packetType}`);\n      }\n    } else if (soundFormat === 2) {\n      // MP3\n      if (!meta.codec) {\n        // We need metadata for mp3 audio track, extract info from frame header\n        let misc = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, true);\n\n        if (misc == undefined) {\n          return;\n        }\n\n        meta.audioSampleRate = misc.samplingRate;\n        meta.channelCount = misc.channelCount;\n        meta.codec = misc.codec;\n        meta.originalCodec = misc.originalCodec; // The decode result of an mp3 sample is 1152 PCM samples\n\n        meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\n        Log.v(this.TAG, 'Parsed MPEG Audio Frame Header');\n        this._audioInitialMetadataDispatched = true;\n\n        this._onTrackMetadata('audio', meta);\n\n        let mi = this._mediaInfo;\n        mi.audioCodec = meta.codec;\n        mi.audioSampleRate = meta.audioSampleRate;\n        mi.audioChannelCount = meta.channelCount;\n        mi.audioDataRate = misc.bitRate;\n\n        if (mi.hasVideo) {\n          if (mi.videoCodec != null) {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n          }\n        } else {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n        }\n\n        if (mi.isComplete()) {\n          this._onMediaInfo(mi);\n        }\n      } // This packet is always a valid audio packet, extract it\n\n\n      let data = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, false);\n\n      if (data == undefined) {\n        return;\n      }\n\n      let dts = this._timestampBase + tagTimestamp;\n      let mp3Sample = {\n        unit: data,\n        length: data.byteLength,\n        dts: dts,\n        pts: dts\n      };\n      track.samples.push(mp3Sample);\n      track.length += data.length;\n    }\n  }\n\n  _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize <= 1) {\n      Log.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n      return;\n    }\n\n    let result = {};\n    let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n    result.packetType = array[0];\n\n    if (array[0] === 0) {\n      result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n    } else {\n      result.data = array.subarray(1);\n    }\n\n    return result;\n  }\n\n  _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n    let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n    let config = null;\n    /* Audio Object Type:\n       0: Null\n       1: AAC Main\n       2: AAC LC\n       3: AAC SSR (Scalable Sample Rate)\n       4: AAC LTP (Long Term Prediction)\n       5: HE-AAC / SBR (Spectral Band Replication)\n       6: AAC Scalable\n    */\n\n    let audioObjectType = 0;\n    let originalAudioObjectType = 0;\n    let audioExtensionObjectType = null;\n    let samplingIndex = 0;\n    let extensionSamplingIndex = null; // 5 bits\n\n    audioObjectType = originalAudioObjectType = array[0] >>> 3; // 4 bits\n\n    samplingIndex = (array[0] & 0x07) << 1 | array[1] >>> 7;\n\n    if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n\n      return;\n    }\n\n    let samplingFrequence = this._mpegSamplingRates[samplingIndex]; // 4 bits\n\n    let channelConfig = (array[1] & 0x78) >>> 3;\n\n    if (channelConfig < 0 || channelConfig >= 8) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n\n      return;\n    }\n\n    if (audioObjectType === 5) {\n      // HE-AAC?\n      // 4 bits\n      extensionSamplingIndex = (array[1] & 0x07) << 1 | array[2] >>> 7; // 5 bits\n\n      audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n    } // workarounds for various browsers\n\n\n    let userAgent = self.navigator.userAgent.toLowerCase();\n\n    if (userAgent.indexOf('firefox') !== -1) {\n      // firefox: use SBR (HE-AAC) if freq less than 24kHz\n      if (samplingIndex >= 6) {\n        audioObjectType = 5;\n        config = new Array(4);\n        extensionSamplingIndex = samplingIndex - 3;\n      } else {\n        // use LC-AAC\n        audioObjectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      }\n    } else if (userAgent.indexOf('android') !== -1) {\n      // android: always use LC-AAC\n      audioObjectType = 2;\n      config = new Array(2);\n      extensionSamplingIndex = samplingIndex;\n    } else {\n      // for other browsers, e.g. chrome...\n      // Always use HE-AAC to make it easier to switch aac codec profile\n      audioObjectType = 5;\n      extensionSamplingIndex = samplingIndex;\n      config = new Array(4);\n\n      if (samplingIndex >= 6) {\n        extensionSamplingIndex = samplingIndex - 3;\n      } else if (channelConfig === 1) {\n        // Mono channel\n        audioObjectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      }\n    }\n\n    config[0] = audioObjectType << 3;\n    config[0] |= (samplingIndex & 0x0F) >>> 1;\n    config[1] = (samplingIndex & 0x0F) << 7;\n    config[1] |= (channelConfig & 0x0F) << 3;\n\n    if (audioObjectType === 5) {\n      config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;\n      config[2] = (extensionSamplingIndex & 0x01) << 7; // extended audio object type: force to 2 (LC-AAC)\n\n      config[2] |= 2 << 2;\n      config[3] = 0;\n    }\n\n    return {\n      config: config,\n      samplingRate: samplingFrequence,\n      channelCount: channelConfig,\n      codec: 'mp4a.40.' + audioObjectType,\n      originalCodec: 'mp4a.40.' + originalAudioObjectType\n    };\n  }\n\n  _parseMP3AudioData(arrayBuffer, dataOffset, dataSize, requestHeader) {\n    if (dataSize < 4) {\n      Log.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\n      return;\n    }\n\n    let le = this._littleEndian;\n    let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n    let result = null;\n\n    if (requestHeader) {\n      if (array[0] !== 0xFF) {\n        return;\n      }\n\n      let ver = array[1] >>> 3 & 0x03;\n      let layer = (array[1] & 0x06) >> 1;\n      let bitrate_index = (array[2] & 0xF0) >>> 4;\n      let sampling_freq_index = (array[2] & 0x0C) >>> 2;\n      let channel_mode = array[3] >>> 6 & 0x03;\n      let channel_count = channel_mode !== 3 ? 2 : 1;\n      let sample_rate = 0;\n      let bit_rate = 0;\n      let object_type = 34; // Layer-3, listed in MPEG-4 Audio Object Types\n\n      let codec = 'mp3';\n\n      switch (ver) {\n        case 0:\n          // MPEG 2.5\n          sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\n          break;\n\n        case 2:\n          // MPEG 2\n          sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\n          break;\n\n        case 3:\n          // MPEG 1\n          sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\n          break;\n      }\n\n      switch (layer) {\n        case 1:\n          // Layer 3\n          object_type = 34;\n\n          if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\n            bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\n          }\n\n          break;\n\n        case 2:\n          // Layer 2\n          object_type = 33;\n\n          if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\n            bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\n          }\n\n          break;\n\n        case 3:\n          // Layer 1\n          object_type = 32;\n\n          if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\n            bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\n          }\n\n          break;\n      }\n\n      result = {\n        bitRate: bit_rate,\n        samplingRate: sample_rate,\n        channelCount: channel_count,\n        codec: codec,\n        originalCodec: codec\n      };\n    } else {\n      result = array;\n    }\n\n    return result;\n  }\n\n  _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n    if (dataSize <= 1) {\n      Log.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n      return;\n    }\n\n    if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\n      // If hasVideo: false indicated explicitly in MediaDataSource,\n      // Ignore all the video packets\n      return;\n    }\n\n    let spec = new Uint8Array(arrayBuffer, dataOffset, dataSize)[0];\n    let frameType = (spec & 240) >>> 4;\n    let codecId = spec & 15;\n\n    if (codecId !== 7) {\n      this._onError(DemuxErrors.CODEC_UNSUPPORTED, `Flv: Unsupported codec in video frame: ${codecId}`);\n\n      return;\n    }\n\n    this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n  }\n\n  _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n    if (dataSize < 4) {\n      Log.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n      return;\n    }\n\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let packetType = v.getUint8(0);\n    let cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\n    let cts = cts_unsigned << 8 >> 8; // convert to 24-bit signed int\n\n    if (packetType === 0) {\n      // AVCDecoderConfigurationRecord\n      this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n    } else if (packetType === 1) {\n      // One or more Nalus\n      this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n    } else if (packetType === 2) {// empty, AVC end of sequence\n    } else {\n      this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid video packet type ${packetType}`);\n\n      return;\n    }\n  }\n\n  _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 7) {\n      Log.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n      return;\n    }\n\n    let meta = this._videoMetadata;\n    let track = this._videoTrack;\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n    if (!meta) {\n      if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\n        this._hasVideo = true;\n        this._mediaInfo.hasVideo = true;\n      }\n\n      meta = this._videoMetadata = {};\n      meta.type = 'video';\n      meta.id = track.id;\n      meta.timescale = this._timescale;\n      meta.duration = this._duration;\n    } else {\n      if (typeof meta.avcc !== 'undefined') {\n        Log.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n      }\n    }\n\n    let version = v.getUint8(0); // configurationVersion\n\n    let avcProfile = v.getUint8(1); // avcProfileIndication\n\n    let profileCompatibility = v.getUint8(2); // profile_compatibility\n\n    let avcLevel = v.getUint8(3); // AVCLevelIndication\n\n    if (version !== 1 || avcProfile === 0) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n\n      return;\n    }\n\n    this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n\n    if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {\n      // holy shit!!!\n      this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`);\n\n      return;\n    }\n\n    let spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n\n    if (spsCount === 0) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\n\n      return;\n    } else if (spsCount > 1) {\n      Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: SPS Count = ${spsCount}`);\n    }\n\n    let offset = 6;\n\n    for (let i = 0; i < spsCount; i++) {\n      let len = v.getUint16(offset, !le); // sequenceParameterSetLength\n\n      offset += 2;\n\n      if (len === 0) {\n        continue;\n      } // Notice: Nalu without startcode header (00 00 00 01)\n\n\n      let sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n      offset += len;\n      let config = SPSParser.parseSPS(sps);\n\n      if (i !== 0) {\n        // ignore other sps's config\n        continue;\n      }\n\n      meta.codecWidth = config.codec_size.width;\n      meta.codecHeight = config.codec_size.height;\n      meta.presentWidth = config.present_size.width;\n      meta.presentHeight = config.present_size.height;\n      meta.profile = config.profile_string;\n      meta.level = config.level_string;\n      meta.bitDepth = config.bit_depth;\n      meta.chromaFormat = config.chroma_format;\n      meta.sarRatio = config.sar_ratio;\n      meta.frameRate = config.frame_rate;\n\n      if (config.frame_rate.fixed === false || config.frame_rate.fps_num === 0 || config.frame_rate.fps_den === 0) {\n        meta.frameRate = this._referenceFrameRate;\n      }\n\n      let fps_den = meta.frameRate.fps_den;\n      let fps_num = meta.frameRate.fps_num;\n      meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\n      let codecArray = sps.subarray(1, 4);\n      let codecString = 'avc1.';\n\n      for (let j = 0; j < 3; j++) {\n        let h = codecArray[j].toString(16);\n\n        if (h.length < 2) {\n          h = '0' + h;\n        }\n\n        codecString += h;\n      }\n\n      meta.codec = codecString;\n      let mi = this._mediaInfo;\n      mi.width = meta.codecWidth;\n      mi.height = meta.codecHeight;\n      mi.fps = meta.frameRate.fps;\n      mi.profile = meta.profile;\n      mi.level = meta.level;\n      mi.refFrames = config.ref_frames;\n      mi.chromaFormat = config.chroma_format_string;\n      mi.sarNum = meta.sarRatio.width;\n      mi.sarDen = meta.sarRatio.height;\n      mi.videoCodec = codecString;\n\n      if (mi.hasAudio) {\n        if (mi.audioCodec != null) {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n        }\n      } else {\n        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n      }\n\n      if (mi.isComplete()) {\n        this._onMediaInfo(mi);\n      }\n    }\n\n    let ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n\n    if (ppsCount === 0) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\n\n      return;\n    } else if (ppsCount > 1) {\n      Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: PPS Count = ${ppsCount}`);\n    }\n\n    offset++;\n\n    for (let i = 0; i < ppsCount; i++) {\n      let len = v.getUint16(offset, !le); // pictureParameterSetLength\n\n      offset += 2;\n\n      if (len === 0) {\n        continue;\n      } // pps is useless for extracting video information\n\n\n      offset += len;\n    }\n\n    meta.avcc = new Uint8Array(dataSize);\n    meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n    Log.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n    if (this._isInitialMetadataDispatched()) {\n      // flush parsed frames\n      if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n        this._onDataAvailable(this._audioTrack, this._videoTrack);\n      }\n    } else {\n      this._videoInitialMetadataDispatched = true;\n    } // notify new metadata\n\n\n    this._dispatch = false;\n\n    this._onTrackMetadata('video', meta);\n  }\n\n  _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let units = [],\n        length = 0;\n    let offset = 0;\n    const lengthSize = this._naluLengthSize;\n    let dts = this._timestampBase + tagTimestamp;\n    let keyframe = frameType === 1; // from FLV Frame Type constants\n\n    while (offset < dataSize) {\n      if (offset + 4 >= dataSize) {\n        Log.w(this.TAG, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n        break; // data not enough for next Nalu\n      } // Nalu with length-header (AVC1)\n\n\n      let naluSize = v.getUint32(offset, !le); // Big-Endian read\n\n      if (lengthSize === 3) {\n        naluSize >>>= 8;\n      }\n\n      if (naluSize > dataSize - lengthSize) {\n        Log.w(this.TAG, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n        return;\n      }\n\n      let unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n      if (unitType === 5) {\n        // IDR\n        keyframe = true;\n      }\n\n      let data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n      let unit = {\n        type: unitType,\n        data: data\n      };\n      units.push(unit);\n      length += data.byteLength;\n      offset += lengthSize + naluSize;\n    }\n\n    if (units.length) {\n      let track = this._videoTrack;\n      let avcSample = {\n        units: units,\n        length: length,\n        isKeyframe: keyframe,\n        dts: dts,\n        cts: cts,\n        pts: dts + cts\n      };\n\n      if (keyframe) {\n        avcSample.fileposition = tagPosition;\n      }\n\n      track.samples.push(avcSample);\n      track.length += length;\n    }\n  }\n\n}\n\nexport default FLVDemuxer;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/demux/flv-demuxer.js"],"names":["Log","AMF","SPSParser","DemuxErrors","MediaInfo","IllegalStateException","Swap16","src","Swap32","ReadBig32","array","index","FLVDemuxer","constructor","probeData","config","TAG","_config","_onError","_onMediaInfo","_onMetaDataArrived","_onScriptDataArrived","_onTrackMetadata","_onDataAvailable","_dataOffset","dataOffset","_firstParse","_dispatch","_hasAudio","hasAudioTrack","_hasVideo","hasVideoTrack","_hasAudioFlagOverrided","_hasVideoFlagOverrided","_audioInitialMetadataDispatched","_videoInitialMetadataDispatched","_mediaInfo","hasAudio","hasVideo","_metadata","_audioMetadata","_videoMetadata","_naluLengthSize","_timestampBase","_timescale","_duration","_durationOverrided","_referenceFrameRate","fixed","fps","fps_num","fps_den","_flvSoundRateTable","_mpegSamplingRates","_mpegAudioV10SampleRateTable","_mpegAudioV20SampleRateTable","_mpegAudioV25SampleRateTable","_mpegAudioL1BitRateTable","_mpegAudioL2BitRateTable","_mpegAudioL3BitRateTable","_videoTrack","type","id","sequenceNumber","samples","length","_audioTrack","_littleEndian","buf","ArrayBuffer","DataView","setInt16","Int16Array","destroy","probe","buffer","data","Uint8Array","mismatch","match","offset","consumed","bindDataSource","loader","onDataArrival","parseChunks","bind","onTrackMetadata","callback","onMediaInfo","onMetaDataArrived","onScriptDataArrived","onError","onDataAvailable","timestampBase","base","overridedDuration","duration","overridedHasAudio","overridedHasVideo","resetMediaInfo","_isInitialMetadataDispatched","chunk","byteStart","le","byteLength","w","v","prevTagSize0","getUint32","tagType","getUint8","dataSize","ts2","ts1","ts0","ts3","timestamp","streamId","_parseAudioData","_parseVideoData","_parseScriptData","prevTagSize","arrayBuffer","scriptData","parseScriptData","hasOwnProperty","onMetaData","Object","assign","audiodatarate","audioDataRate","videodatarate","videoDataRate","width","height","Math","floor","framerate","keyframes","hasKeyframesIndex","keyframesIndex","_parseKeyframesIndex","metadata","isComplete","keys","times","filepositions","i","time","push","tagTimestamp","soundSpec","soundFormat","CODEC_UNSUPPORTED","soundRate","soundRateIndex","FORMAT_ERROR","soundSize","soundType","meta","track","timescale","audioSampleRate","channelCount","aacData","_parseAACAudioData","undefined","packetType","misc","samplingRate","codec","originalCodec","refSampleDuration","mi","audioCodec","audioChannelCount","videoCodec","mimeType","dts","aacSample","unit","pts","e","_parseMP3AudioData","bitRate","mp3Sample","result","_parseAACAudioSpecificConfig","subarray","audioObjectType","originalAudioObjectType","audioExtensionObjectType","samplingIndex","extensionSamplingIndex","samplingFrequence","channelConfig","userAgent","self","navigator","toLowerCase","indexOf","Array","requestHeader","ver","layer","bitrate_index","sampling_freq_index","channel_mode","channel_count","sample_rate","bit_rate","object_type","tagPosition","spec","frameType","codecId","_parseAVCVideoPacket","cts_unsigned","cts","_parseAVCDecoderConfigurationRecord","_parseAVCVideoData","avcc","version","avcProfile","profileCompatibility","avcLevel","spsCount","len","getUint16","sps","parseSPS","codecWidth","codec_size","codecHeight","presentWidth","present_size","presentHeight","profile","profile_string","level","level_string","bitDepth","bit_depth","chromaFormat","chroma_format","sarRatio","sar_ratio","frameRate","frame_rate","codecArray","codecString","j","h","toString","refFrames","ref_frames","chroma_format_string","sarNum","sarDen","ppsCount","set","units","lengthSize","keyframe","naluSize","unitType","avcSample","isKeyframe","fileposition"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport AMF from './amf-parser.js';\nimport SPSParser from './sps-parser.js';\nimport DemuxErrors from './demux-errors.js';\nimport MediaInfo from '../core/media-info.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\nfunction Swap16(src) {\n    return (((src >>> 8) & 0xFF) |\n            ((src & 0xFF) << 8));\n}\n\nfunction Swap32(src) {\n    return (((src & 0xFF000000) >>> 24) |\n            ((src & 0x00FF0000) >>> 8)  |\n            ((src & 0x0000FF00) << 8)   |\n            ((src & 0x000000FF) << 24));\n}\n\nfunction ReadBig32(array, index) {\n    return ((array[index] << 24)     |\n            (array[index + 1] << 16) |\n            (array[index + 2] << 8)  |\n            (array[index + 3]));\n}\n\n\nclass FLVDemuxer {\n\n    constructor(probeData, config) {\n        this.TAG = 'FLVDemuxer';\n\n        this._config = config;\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onMetaDataArrived = null;\n        this._onScriptDataArrived = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n\n        this._dataOffset = probeData.dataOffset;\n        this._firstParse = true;\n        this._dispatch = false;\n\n        this._hasAudio = probeData.hasAudioTrack;\n        this._hasVideo = probeData.hasVideoTrack;\n\n        this._hasAudioFlagOverrided = false;\n        this._hasVideoFlagOverrided = false;\n\n        this._audioInitialMetadataDispatched = false;\n        this._videoInitialMetadataDispatched = false;\n\n        this._mediaInfo = new MediaInfo();\n        this._mediaInfo.hasAudio = this._hasAudio;\n        this._mediaInfo.hasVideo = this._hasVideo;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n\n        this._naluLengthSize = 4;\n        this._timestampBase = 0;  // int32, in milliseconds\n        this._timescale = 1000;\n        this._duration = 0;  // int32, in milliseconds\n        this._durationOverrided = false;\n        this._referenceFrameRate = {\n            fixed: true,\n            fps: 23.976,\n            fps_num: 23976,\n            fps_den: 1000\n        };\n\n        this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\n\n        this._mpegSamplingRates = [\n            96000, 88200, 64000, 48000, 44100, 32000,\n            24000, 22050, 16000, 12000, 11025, 8000, 7350\n        ];\n\n        this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\n        this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\n        this._mpegAudioV25SampleRateTable = [11025, 12000, 8000,  0];\n\n        this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\n        this._mpegAudioL2BitRateTable = [0, 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\n        this._mpegAudioL3BitRateTable = [0, 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, -1];\n\n        this._videoTrack = {type: 'video', id: 1, sequenceNumber: 0, samples: [], length: 0};\n        this._audioTrack = {type: 'audio', id: 2, sequenceNumber: 0, samples: [], length: 0};\n\n        this._littleEndian = (function () {\n            let buf = new ArrayBuffer(2);\n            (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\n            return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\n        })();\n    }\n\n    destroy() {\n        this._mediaInfo = null;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n        this._videoTrack = null;\n        this._audioTrack = null;\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onMetaDataArrived = null;\n        this._onScriptDataArrived = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n    }\n\n    static probe(buffer) {\n        let data = new Uint8Array(buffer);\n        let mismatch = {match: false};\n\n        if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n            return mismatch;\n        }\n\n        let hasAudio = ((data[4] & 4) >>> 2) !== 0;\n        let hasVideo = (data[4] & 1) !== 0;\n\n        let offset = ReadBig32(data, 5);\n\n        if (offset < 9) {\n            return mismatch;\n        }\n\n        return {\n            match: true,\n            consumed: offset,\n            dataOffset: offset,\n            hasAudioTrack: hasAudio,\n            hasVideoTrack: hasVideo\n        };\n    }\n\n    bindDataSource(loader) {\n        loader.onDataArrival = this.parseChunks.bind(this);\n        return this;\n    }\n\n    // prototype: function(type: string, metadata: any): void\n    get onTrackMetadata() {\n        return this._onTrackMetadata;\n    }\n\n    set onTrackMetadata(callback) {\n        this._onTrackMetadata = callback;\n    }\n\n    // prototype: function(mediaInfo: MediaInfo): void\n    get onMediaInfo() {\n        return this._onMediaInfo;\n    }\n\n    set onMediaInfo(callback) {\n        this._onMediaInfo = callback;\n    }\n\n    get onMetaDataArrived() {\n        return this._onMetaDataArrived;\n    }\n\n    set onMetaDataArrived(callback) {\n        this._onMetaDataArrived = callback;\n    }\n\n    get onScriptDataArrived() {\n        return this._onScriptDataArrived;\n    }\n\n    set onScriptDataArrived(callback) {\n        this._onScriptDataArrived = callback;\n    }\n\n    // prototype: function(type: number, info: string): void\n    get onError() {\n        return this._onError;\n    }\n\n    set onError(callback) {\n        this._onError = callback;\n    }\n\n    // prototype: function(videoTrack: any, audioTrack: any): void\n    get onDataAvailable() {\n        return this._onDataAvailable;\n    }\n\n    set onDataAvailable(callback) {\n        this._onDataAvailable = callback;\n    }\n\n    // timestamp base for output samples, must be in milliseconds\n    get timestampBase() {\n        return this._timestampBase;\n    }\n\n    set timestampBase(base) {\n        this._timestampBase = base;\n    }\n\n    get overridedDuration() {\n        return this._duration;\n    }\n\n    // Force-override media duration. Must be in milliseconds, int32\n    set overridedDuration(duration) {\n        this._durationOverrided = true;\n        this._duration = duration;\n        this._mediaInfo.duration = duration;\n    }\n\n    // Force-override audio track present flag, boolean\n    set overridedHasAudio(hasAudio) {\n        this._hasAudioFlagOverrided = true;\n        this._hasAudio = hasAudio;\n        this._mediaInfo.hasAudio = hasAudio;\n    }\n\n    // Force-override video track present flag, boolean\n    set overridedHasVideo(hasVideo) {\n        this._hasVideoFlagOverrided = true;\n        this._hasVideo = hasVideo;\n        this._mediaInfo.hasVideo = hasVideo;\n    }\n\n    resetMediaInfo() {\n        this._mediaInfo = new MediaInfo();\n    }\n\n    _isInitialMetadataDispatched() {\n        if (this._hasAudio && this._hasVideo) {  // both audio & video\n            return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n        }\n        if (this._hasAudio && !this._hasVideo) {  // audio only\n            return this._audioInitialMetadataDispatched;\n        }\n        if (!this._hasAudio && this._hasVideo) {  // video only\n            return this._videoInitialMetadataDispatched;\n        }\n        return false;\n    }\n\n    // function parseChunks(chunk: ArrayBuffer, byteStart: number): number;\n    parseChunks(chunk, byteStart) {\n        if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\n            throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\n        }\n\n        let offset = 0;\n        let le = this._littleEndian;\n\n        if (byteStart === 0) {  // buffer with FLV header\n            if (chunk.byteLength > 13) {\n                let probeData = FLVDemuxer.probe(chunk);\n                offset = probeData.dataOffset;\n            } else {\n                return 0;\n            }\n        }\n\n        if (this._firstParse) {  // handle PreviousTagSize0 before Tag1\n            this._firstParse = false;\n            if (byteStart + offset !== this._dataOffset) {\n                Log.w(this.TAG, 'First time parsing but chunk byteStart invalid!');\n            }\n\n            let v = new DataView(chunk, offset);\n            let prevTagSize0 = v.getUint32(0, !le);\n            if (prevTagSize0 !== 0) {\n                Log.w(this.TAG, 'PrevTagSize0 !== 0 !!!');\n            }\n            offset += 4;\n        }\n\n        while (offset < chunk.byteLength) {\n            this._dispatch = true;\n\n            let v = new DataView(chunk, offset);\n\n            if (offset + 11 + 4 > chunk.byteLength) {\n                // data not enough for parsing an flv tag\n                break;\n            }\n\n            let tagType = v.getUint8(0);\n            let dataSize = v.getUint32(0, !le) & 0x00FFFFFF;\n\n            if (offset + 11 + dataSize + 4 > chunk.byteLength) {\n                // data not enough for parsing actual data body\n                break;\n            }\n\n            if (tagType !== 8 && tagType !== 9 && tagType !== 18) {\n                Log.w(this.TAG, `Unsupported tag type ${tagType}, skipped`);\n                // consume the whole tag (skip it)\n                offset += 11 + dataSize + 4;\n                continue;\n            }\n\n            let ts2 = v.getUint8(4);\n            let ts1 = v.getUint8(5);\n            let ts0 = v.getUint8(6);\n            let ts3 = v.getUint8(7);\n\n            let timestamp = ts0 | (ts1 << 8) | (ts2 << 16) | (ts3 << 24);\n\n            let streamId = v.getUint32(7, !le) & 0x00FFFFFF;\n            if (streamId !== 0) {\n                Log.w(this.TAG, 'Meet tag which has StreamID != 0!');\n            }\n\n            let dataOffset = offset + 11;\n\n            switch (tagType) {\n                case 8:  // Audio\n                    this._parseAudioData(chunk, dataOffset, dataSize, timestamp);\n                    break;\n                case 9:  // Video\n                    this._parseVideoData(chunk, dataOffset, dataSize, timestamp, byteStart + offset);\n                    break;\n                case 18:  // ScriptDataObject\n                    this._parseScriptData(chunk, dataOffset, dataSize);\n                    break;\n            }\n\n            let prevTagSize = v.getUint32(11 + dataSize, !le);\n            if (prevTagSize !== 11 + dataSize) {\n                Log.w(this.TAG, `Invalid PrevTagSize ${prevTagSize}`);\n            }\n\n            offset += 11 + dataSize + 4;  // tagBody + dataSize + prevTagSize\n        }\n\n        // dispatch parsed frames to consumer (typically, the remuxer)\n        if (this._isInitialMetadataDispatched()) {\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        }\n\n        return offset;  // consumed bytes, just equals latest offset index\n    }\n\n    _parseScriptData(arrayBuffer, dataOffset, dataSize) {\n        let scriptData = AMF.parseScriptData(arrayBuffer, dataOffset, dataSize);\n\n        if (scriptData.hasOwnProperty('onMetaData')) {\n            if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\n                Log.w(this.TAG, 'Invalid onMetaData structure!');\n                return;\n            }\n            if (this._metadata) {\n                Log.w(this.TAG, 'Found another onMetaData tag!');\n            }\n            this._metadata = scriptData;\n            let onMetaData = this._metadata.onMetaData;\n\n            if (this._onMetaDataArrived) {\n                this._onMetaDataArrived(Object.assign({}, onMetaData));\n            }\n\n            if (typeof onMetaData.hasAudio === 'boolean') {  // hasAudio\n                if (this._hasAudioFlagOverrided === false) {\n                    this._hasAudio = onMetaData.hasAudio;\n                    this._mediaInfo.hasAudio = this._hasAudio;\n                }\n            }\n            if (typeof onMetaData.hasVideo === 'boolean') {  // hasVideo\n                if (this._hasVideoFlagOverrided === false) {\n                    this._hasVideo = onMetaData.hasVideo;\n                    this._mediaInfo.hasVideo = this._hasVideo;\n                }\n            }\n            if (typeof onMetaData.audiodatarate === 'number') {  // audiodatarate\n                this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n            }\n            if (typeof onMetaData.videodatarate === 'number') {  // videodatarate\n                this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n            }\n            if (typeof onMetaData.width === 'number') {  // width\n                this._mediaInfo.width = onMetaData.width;\n            }\n            if (typeof onMetaData.height === 'number') {  // height\n                this._mediaInfo.height = onMetaData.height;\n            }\n            if (typeof onMetaData.duration === 'number') {  // duration\n                if (!this._durationOverrided) {\n                    let duration = Math.floor(onMetaData.duration * this._timescale);\n                    this._duration = duration;\n                    this._mediaInfo.duration = duration;\n                }\n            } else {\n                this._mediaInfo.duration = 0;\n            }\n            if (typeof onMetaData.framerate === 'number') {  // framerate\n                let fps_num = Math.floor(onMetaData.framerate * 1000);\n                if (fps_num > 0) {\n                    let fps = fps_num / 1000;\n                    this._referenceFrameRate.fixed = true;\n                    this._referenceFrameRate.fps = fps;\n                    this._referenceFrameRate.fps_num = fps_num;\n                    this._referenceFrameRate.fps_den = 1000;\n                    this._mediaInfo.fps = fps;\n                }\n            }\n            if (typeof onMetaData.keyframes === 'object') {  // keyframes\n                this._mediaInfo.hasKeyframesIndex = true;\n                let keyframes = onMetaData.keyframes;\n                this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n                onMetaData.keyframes = null;  // keyframes has been extracted, remove it\n            } else {\n                this._mediaInfo.hasKeyframesIndex = false;\n            }\n            this._dispatch = false;\n            this._mediaInfo.metadata = onMetaData;\n            Log.v(this.TAG, 'Parsed onMetaData');\n            if (this._mediaInfo.isComplete()) {\n                this._onMediaInfo(this._mediaInfo);\n            }\n        }\n\n        if (Object.keys(scriptData).length > 0) {\n            if (this._onScriptDataArrived) {\n                this._onScriptDataArrived(Object.assign({}, scriptData));\n            }\n        }\n    }\n\n    _parseKeyframesIndex(keyframes) {\n        let times = [];\n        let filepositions = [];\n\n        // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n        for (let i = 1; i < keyframes.times.length; i++) {\n            let time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n            times.push(time);\n            filepositions.push(keyframes.filepositions[i]);\n        }\n\n        return {\n            times: times,\n            filepositions: filepositions\n        };\n    }\n\n    _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n        if (dataSize <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n            return;\n        }\n\n        if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\n            // If hasAudio: false indicated explicitly in MediaDataSource,\n            // Ignore all the audio packets\n            return;\n        }\n\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let soundSpec = v.getUint8(0);\n\n        let soundFormat = soundSpec >>> 4;\n        if (soundFormat !== 2 && soundFormat !== 10) {  // MP3 or AAC\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n            return;\n        }\n\n        let soundRate = 0;\n        let soundRateIndex = (soundSpec & 12) >>> 2;\n        if (soundRateIndex >= 0 && soundRateIndex <= 4) {\n            soundRate = this._flvSoundRateTable[soundRateIndex];\n        } else {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n            return;\n        }\n\n        let soundSize = (soundSpec & 2) >>> 1;  // unused\n        let soundType = (soundSpec & 1);\n\n\n        let meta = this._audioMetadata;\n        let track = this._audioTrack;\n\n        if (!meta) {\n            if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\n                this._hasAudio = true;\n                this._mediaInfo.hasAudio = true;\n            }\n\n            // initial metadata\n            meta = this._audioMetadata = {};\n            meta.type = 'audio';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n            meta.audioSampleRate = soundRate;\n            meta.channelCount = (soundType === 0 ? 1 : 2);\n        }\n\n        if (soundFormat === 10) {  // AAC\n            let aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n            if (aacData == undefined) {\n                return;\n            }\n\n            if (aacData.packetType === 0) {  // AAC sequence header (AudioSpecificConfig)\n                if (meta.config) {\n                    Log.w(this.TAG, 'Found another AudioSpecificConfig!');\n                }\n                let misc = aacData.data;\n                meta.audioSampleRate = misc.samplingRate;\n                meta.channelCount = misc.channelCount;\n                meta.codec = misc.codec;\n                meta.originalCodec = misc.originalCodec;\n                meta.config = misc.config;\n                // The decode result of an aac sample is 1024 PCM samples\n                meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\n                Log.v(this.TAG, 'Parsed AudioSpecificConfig');\n\n                if (this._isInitialMetadataDispatched()) {\n                    // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n                    if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                        this._onDataAvailable(this._audioTrack, this._videoTrack);\n                    }\n                } else {\n                    this._audioInitialMetadataDispatched = true;\n                }\n                // then notify new metadata\n                this._dispatch = false;\n                this._onTrackMetadata('audio', meta);\n\n                let mi = this._mediaInfo;\n                mi.audioCodec = meta.originalCodec;\n                mi.audioSampleRate = meta.audioSampleRate;\n                mi.audioChannelCount = meta.channelCount;\n                if (mi.hasVideo) {\n                    if (mi.videoCodec != null) {\n                        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                    }\n                } else {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n                }\n                if (mi.isComplete()) {\n                    this._onMediaInfo(mi);\n                }\n            } else if (aacData.packetType === 1) {  // AAC raw frame data\n                let dts = this._timestampBase + tagTimestamp;\n                let aacSample = {unit: aacData.data, length: aacData.data.byteLength, dts: dts, pts: dts};\n                track.samples.push(aacSample);\n                track.length += aacData.data.length;\n            } else {\n                Log.e(this.TAG, `Flv: Unsupported AAC data type ${aacData.packetType}`);\n            }\n        } else if (soundFormat === 2) {  // MP3\n            if (!meta.codec) {\n                // We need metadata for mp3 audio track, extract info from frame header\n                let misc = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, true);\n                if (misc == undefined) {\n                    return;\n                }\n                meta.audioSampleRate = misc.samplingRate;\n                meta.channelCount = misc.channelCount;\n                meta.codec = misc.codec;\n                meta.originalCodec = misc.originalCodec;\n                // The decode result of an mp3 sample is 1152 PCM samples\n                meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\n                Log.v(this.TAG, 'Parsed MPEG Audio Frame Header');\n\n                this._audioInitialMetadataDispatched = true;\n                this._onTrackMetadata('audio', meta);\n\n                let mi = this._mediaInfo;\n                mi.audioCodec = meta.codec;\n                mi.audioSampleRate = meta.audioSampleRate;\n                mi.audioChannelCount = meta.channelCount;\n                mi.audioDataRate = misc.bitRate;\n                if (mi.hasVideo) {\n                    if (mi.videoCodec != null) {\n                        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                    }\n                } else {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n                }\n                if (mi.isComplete()) {\n                    this._onMediaInfo(mi);\n                }\n            }\n\n            // This packet is always a valid audio packet, extract it\n            let data = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, false);\n            if (data == undefined) {\n                return;\n            }\n            let dts = this._timestampBase + tagTimestamp;\n            let mp3Sample = {unit: data, length: data.byteLength, dts: dts, pts: dts};\n            track.samples.push(mp3Sample);\n            track.length += data.length;\n        }\n    }\n\n    _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n            return;\n        }\n\n        let result = {};\n        let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n\n        result.packetType = array[0];\n\n        if (array[0] === 0) {\n            result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n        } else {\n            result.data = array.subarray(1);\n        }\n\n        return result;\n    }\n\n    _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n        let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n        let config = null;\n\n        /* Audio Object Type:\n           0: Null\n           1: AAC Main\n           2: AAC LC\n           3: AAC SSR (Scalable Sample Rate)\n           4: AAC LTP (Long Term Prediction)\n           5: HE-AAC / SBR (Spectral Band Replication)\n           6: AAC Scalable\n        */\n\n        let audioObjectType = 0;\n        let originalAudioObjectType = 0;\n        let audioExtensionObjectType = null;\n        let samplingIndex = 0;\n        let extensionSamplingIndex = null;\n\n        // 5 bits\n        audioObjectType = originalAudioObjectType = array[0] >>> 3;\n        // 4 bits\n        samplingIndex = ((array[0] & 0x07) << 1) | (array[1] >>> 7);\n        if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n            return;\n        }\n\n        let samplingFrequence = this._mpegSamplingRates[samplingIndex];\n\n        // 4 bits\n        let channelConfig = (array[1] & 0x78) >>> 3;\n        if (channelConfig < 0 || channelConfig >= 8) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n            return;\n        }\n\n        if (audioObjectType === 5) {  // HE-AAC?\n            // 4 bits\n            extensionSamplingIndex = ((array[1] & 0x07) << 1) | (array[2] >>> 7);\n            // 5 bits\n            audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n        }\n\n        // workarounds for various browsers\n        let userAgent = self.navigator.userAgent.toLowerCase();\n\n        if (userAgent.indexOf('firefox') !== -1) {\n            // firefox: use SBR (HE-AAC) if freq less than 24kHz\n            if (samplingIndex >= 6) {\n                audioObjectType = 5;\n                config = new Array(4);\n                extensionSamplingIndex = samplingIndex - 3;\n            } else {  // use LC-AAC\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        } else if (userAgent.indexOf('android') !== -1) {\n            // android: always use LC-AAC\n            audioObjectType = 2;\n            config = new Array(2);\n            extensionSamplingIndex = samplingIndex;\n        } else {\n            // for other browsers, e.g. chrome...\n            // Always use HE-AAC to make it easier to switch aac codec profile\n            audioObjectType = 5;\n            extensionSamplingIndex = samplingIndex;\n            config = new Array(4);\n\n            if (samplingIndex >= 6) {\n                extensionSamplingIndex = samplingIndex - 3;\n            } else if (channelConfig === 1) {  // Mono channel\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        }\n\n        config[0]  = audioObjectType << 3;\n        config[0] |= (samplingIndex & 0x0F) >>> 1;\n        config[1]  = (samplingIndex & 0x0F) << 7;\n        config[1] |= (channelConfig & 0x0F) << 3;\n        if (audioObjectType === 5) {\n            config[1] |= ((extensionSamplingIndex & 0x0F) >>> 1);\n            config[2]  = (extensionSamplingIndex & 0x01) << 7;\n            // extended audio object type: force to 2 (LC-AAC)\n            config[2] |= (2 << 2);\n            config[3]  = 0;\n        }\n\n        return {\n            config: config,\n            samplingRate: samplingFrequence,\n            channelCount: channelConfig,\n            codec: 'mp4a.40.' + audioObjectType,\n            originalCodec: 'mp4a.40.' + originalAudioObjectType\n        };\n    }\n\n    _parseMP3AudioData(arrayBuffer, dataOffset, dataSize, requestHeader) {\n        if (dataSize < 4) {\n            Log.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\n            return;\n        }\n\n        let le = this._littleEndian;\n        let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n        let result = null;\n\n        if (requestHeader) {\n            if (array[0] !== 0xFF) {\n                return;\n            }\n            let ver = (array[1] >>> 3) & 0x03;\n            let layer = (array[1] & 0x06) >> 1;\n\n            let bitrate_index = (array[2] & 0xF0) >>> 4;\n            let sampling_freq_index = (array[2] & 0x0C) >>> 2;\n\n            let channel_mode = (array[3] >>> 6) & 0x03;\n            let channel_count = channel_mode !== 3 ? 2 : 1;\n\n            let sample_rate = 0;\n            let bit_rate = 0;\n            let object_type = 34;  // Layer-3, listed in MPEG-4 Audio Object Types\n\n            let codec = 'mp3';\n\n            switch (ver) {\n                case 0:  // MPEG 2.5\n                    sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\n                    break;\n                case 2:  // MPEG 2\n                    sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\n                    break;\n                case 3:  // MPEG 1\n                    sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\n                    break;\n            }\n\n            switch (layer) {\n                case 1:  // Layer 3\n                    object_type = 34;\n                    if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\n                        bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\n                    }\n                    break;\n                case 2:  // Layer 2\n                    object_type = 33;\n                    if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\n                        bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\n                    }\n                    break;\n                case 3:  // Layer 1\n                    object_type = 32;\n                    if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\n                        bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\n                    }\n                    break;\n            }\n\n            result = {\n                bitRate: bit_rate,\n                samplingRate: sample_rate,\n                channelCount: channel_count,\n                codec: codec,\n                originalCodec: codec\n            };\n        } else {\n            result = array;\n        }\n\n        return result;\n    }\n\n    _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n        if (dataSize <= 1) {\n            Log.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n            return;\n        }\n\n        if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\n            // If hasVideo: false indicated explicitly in MediaDataSource,\n            // Ignore all the video packets\n            return;\n        }\n\n        let spec = (new Uint8Array(arrayBuffer, dataOffset, dataSize))[0];\n\n        let frameType = (spec & 240) >>> 4;\n        let codecId = spec & 15;\n\n        if (codecId !== 7) {\n            this._onError(DemuxErrors.CODEC_UNSUPPORTED, `Flv: Unsupported codec in video frame: ${codecId}`);\n            return;\n        }\n\n        this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n    }\n\n    _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n        if (dataSize < 4) {\n            Log.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n            return;\n        }\n\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let packetType = v.getUint8(0);\n        let cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\n        let cts = (cts_unsigned << 8) >> 8;  // convert to 24-bit signed int\n\n        if (packetType === 0) {  // AVCDecoderConfigurationRecord\n            this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n        } else if (packetType === 1) {  // One or more Nalus\n            this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n        } else if (packetType === 2) {\n            // empty, AVC end of sequence\n        } else {\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid video packet type ${packetType}`);\n            return;\n        }\n    }\n\n    _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 7) {\n            Log.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n            return;\n        }\n\n        let meta = this._videoMetadata;\n        let track = this._videoTrack;\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        if (!meta) {\n            if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\n                this._hasVideo = true;\n                this._mediaInfo.hasVideo = true;\n            }\n\n            meta = this._videoMetadata = {};\n            meta.type = 'video';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n        } else {\n            if (typeof meta.avcc !== 'undefined') {\n                Log.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n            }\n        }\n\n        let version = v.getUint8(0);  // configurationVersion\n        let avcProfile = v.getUint8(1);  // avcProfileIndication\n        let profileCompatibility = v.getUint8(2);  // profile_compatibility\n        let avcLevel = v.getUint8(3);  // AVCLevelIndication\n\n        if (version !== 1 || avcProfile === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n            return;\n        }\n\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1;  // lengthSizeMinusOne\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {  // holy shit!!!\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`);\n            return;\n        }\n\n        let spsCount = v.getUint8(5) & 31;  // numOfSequenceParameterSets\n        if (spsCount === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\n            return;\n        } else if (spsCount > 1) {\n            Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: SPS Count = ${spsCount}`);\n        }\n\n        let offset = 6;\n\n        for (let i = 0; i < spsCount; i++) {\n            let len = v.getUint16(offset, !le);  // sequenceParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // Notice: Nalu without startcode header (00 00 00 01)\n            let sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            offset += len;\n\n            let config = SPSParser.parseSPS(sps);\n            if (i !== 0) {\n                // ignore other sps's config\n                continue;\n            }\n\n            meta.codecWidth = config.codec_size.width;\n            meta.codecHeight = config.codec_size.height;\n            meta.presentWidth = config.present_size.width;\n            meta.presentHeight = config.present_size.height;\n\n            meta.profile = config.profile_string;\n            meta.level = config.level_string;\n            meta.bitDepth = config.bit_depth;\n            meta.chromaFormat = config.chroma_format;\n            meta.sarRatio = config.sar_ratio;\n            meta.frameRate = config.frame_rate;\n\n            if (config.frame_rate.fixed === false ||\n                config.frame_rate.fps_num === 0 ||\n                config.frame_rate.fps_den === 0) {\n                meta.frameRate = this._referenceFrameRate;\n            }\n\n            let fps_den = meta.frameRate.fps_den;\n            let fps_num = meta.frameRate.fps_num;\n            meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\n\n            let codecArray = sps.subarray(1, 4);\n            let codecString = 'avc1.';\n            for (let j = 0; j < 3; j++) {\n                let h = codecArray[j].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                codecString += h;\n            }\n            meta.codec = codecString;\n\n            let mi = this._mediaInfo;\n            mi.width = meta.codecWidth;\n            mi.height = meta.codecHeight;\n            mi.fps = meta.frameRate.fps;\n            mi.profile = meta.profile;\n            mi.level = meta.level;\n            mi.refFrames = config.ref_frames;\n            mi.chromaFormat = config.chroma_format_string;\n            mi.sarNum = meta.sarRatio.width;\n            mi.sarDen = meta.sarRatio.height;\n            mi.videoCodec = codecString;\n\n            if (mi.hasAudio) {\n                if (mi.audioCodec != null) {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                }\n            } else {\n                mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n            }\n            if (mi.isComplete()) {\n                this._onMediaInfo(mi);\n            }\n        }\n\n        let ppsCount = v.getUint8(offset);  // numOfPictureParameterSets\n        if (ppsCount === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\n            return;\n        } else if (ppsCount > 1) {\n            Log.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: PPS Count = ${ppsCount}`);\n        }\n\n        offset++;\n\n        for (let i = 0; i < ppsCount; i++) {\n            let len = v.getUint16(offset, !le);  // pictureParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // pps is useless for extracting video information\n            offset += len;\n        }\n\n        meta.avcc = new Uint8Array(dataSize);\n        meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n        Log.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n        if (this._isInitialMetadataDispatched()) {\n            // flush parsed frames\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        } else {\n            this._videoInitialMetadataDispatched = true;\n        }\n        // notify new metadata\n        this._dispatch = false;\n        this._onTrackMetadata('video', meta);\n    }\n\n    _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n        let le = this._littleEndian;\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let units = [], length = 0;\n\n        let offset = 0;\n        const lengthSize = this._naluLengthSize;\n        let dts = this._timestampBase + tagTimestamp;\n        let keyframe = (frameType === 1);  // from FLV Frame Type constants\n\n        while (offset < dataSize) {\n            if (offset + 4 >= dataSize) {\n                Log.w(this.TAG, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n                break;  // data not enough for next Nalu\n            }\n            // Nalu with length-header (AVC1)\n            let naluSize = v.getUint32(offset, !le);  // Big-Endian read\n            if (lengthSize === 3) {\n                naluSize >>>= 8;\n            }\n            if (naluSize > dataSize - lengthSize) {\n                Log.w(this.TAG, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n                return;\n            }\n\n            let unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n            if (unitType === 5) {  // IDR\n                keyframe = true;\n            }\n\n            let data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n            let unit = {type: unitType, data: data};\n            units.push(unit);\n            length += data.byteLength;\n\n            offset += lengthSize + naluSize;\n        }\n\n        if (units.length) {\n            let track = this._videoTrack;\n            let avcSample = {\n                units: units,\n                length: length,\n                isKeyframe: keyframe,\n                dts: dts,\n                cts: cts,\n                pts: (dts + cts)\n            };\n            if (keyframe) {\n                avcSample.fileposition = tagPosition;\n            }\n            track.samples.push(avcSample);\n            track.length += length;\n        }\n    }\n\n}\n\nexport default FLVDemuxer;"]},"metadata":{},"sourceType":"module"}