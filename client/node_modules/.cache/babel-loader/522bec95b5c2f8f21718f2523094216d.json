{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport ExpGolomb from './exp-golomb.js';\n\nclass SPSParser {\n  static _ebsp2rbsp(uint8array) {\n    let src = uint8array;\n    let src_length = src.byteLength;\n    let dst = new Uint8Array(src_length);\n    let dst_idx = 0;\n\n    for (let i = 0; i < src_length; i++) {\n      if (i >= 2) {\n        // Unescape: Skip 0x03 after 00 00\n        if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n          continue;\n        }\n      }\n\n      dst[dst_idx] = src[i];\n      dst_idx++;\n    }\n\n    return new Uint8Array(dst.buffer, 0, dst_idx);\n  }\n\n  static parseSPS(uint8array) {\n    let rbsp = SPSParser._ebsp2rbsp(uint8array);\n\n    let gb = new ExpGolomb(rbsp);\n    gb.readByte();\n    let profile_idc = gb.readByte(); // profile_idc\n\n    gb.readByte(); // constraint_set_flags[5] + reserved_zero[3]\n\n    let level_idc = gb.readByte(); // level_idc\n\n    gb.readUEG(); // seq_parameter_set_id\n\n    let profile_string = SPSParser.getProfileString(profile_idc);\n    let level_string = SPSParser.getLevelString(level_idc);\n    let chroma_format_idc = 1;\n    let chroma_format = 420;\n    let chroma_format_table = [0, 420, 422, 444];\n    let bit_depth = 8;\n\n    if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 || profile_idc === 244 || profile_idc === 44 || profile_idc === 83 || profile_idc === 86 || profile_idc === 118 || profile_idc === 128 || profile_idc === 138 || profile_idc === 144) {\n      chroma_format_idc = gb.readUEG();\n\n      if (chroma_format_idc === 3) {\n        gb.readBits(1); // separate_colour_plane_flag\n      }\n\n      if (chroma_format_idc <= 3) {\n        chroma_format = chroma_format_table[chroma_format_idc];\n      }\n\n      bit_depth = gb.readUEG() + 8; // bit_depth_luma_minus8\n\n      gb.readUEG(); // bit_depth_chroma_minus8\n\n      gb.readBits(1); // qpprime_y_zero_transform_bypass_flag\n\n      if (gb.readBool()) {\n        // seq_scaling_matrix_present_flag\n        let scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n\n        for (let i = 0; i < scaling_list_count; i++) {\n          if (gb.readBool()) {\n            // seq_scaling_list_present_flag\n            if (i < 6) {\n              SPSParser._skipScalingList(gb, 16);\n            } else {\n              SPSParser._skipScalingList(gb, 64);\n            }\n          }\n        }\n      }\n    }\n\n    gb.readUEG(); // log2_max_frame_num_minus4\n\n    let pic_order_cnt_type = gb.readUEG();\n\n    if (pic_order_cnt_type === 0) {\n      gb.readUEG(); // log2_max_pic_order_cnt_lsb_minus_4\n    } else if (pic_order_cnt_type === 1) {\n      gb.readBits(1); // delta_pic_order_always_zero_flag\n\n      gb.readSEG(); // offset_for_non_ref_pic\n\n      gb.readSEG(); // offset_for_top_to_bottom_field\n\n      let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n\n      for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n        gb.readSEG(); // offset_for_ref_frame\n      }\n    }\n\n    let ref_frames = gb.readUEG(); // max_num_ref_frames\n\n    gb.readBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    let pic_width_in_mbs_minus1 = gb.readUEG();\n    let pic_height_in_map_units_minus1 = gb.readUEG();\n    let frame_mbs_only_flag = gb.readBits(1);\n\n    if (frame_mbs_only_flag === 0) {\n      gb.readBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    gb.readBits(1); // direct_8x8_inference_flag\n\n    let frame_crop_left_offset = 0;\n    let frame_crop_right_offset = 0;\n    let frame_crop_top_offset = 0;\n    let frame_crop_bottom_offset = 0;\n    let frame_cropping_flag = gb.readBool();\n\n    if (frame_cropping_flag) {\n      frame_crop_left_offset = gb.readUEG();\n      frame_crop_right_offset = gb.readUEG();\n      frame_crop_top_offset = gb.readUEG();\n      frame_crop_bottom_offset = gb.readUEG();\n    }\n\n    let sar_width = 1,\n        sar_height = 1;\n    let fps = 0,\n        fps_fixed = true,\n        fps_num = 0,\n        fps_den = 0;\n    let vui_parameters_present_flag = gb.readBool();\n\n    if (vui_parameters_present_flag) {\n      if (gb.readBool()) {\n        // aspect_ratio_info_present_flag\n        let aspect_ratio_idc = gb.readByte();\n        let sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n        let sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n          sar_width = sar_w_table[aspect_ratio_idc - 1];\n          sar_height = sar_h_table[aspect_ratio_idc - 1];\n        } else if (aspect_ratio_idc === 255) {\n          sar_width = gb.readByte() << 8 | gb.readByte();\n          sar_height = gb.readByte() << 8 | gb.readByte();\n        }\n      }\n\n      if (gb.readBool()) {\n        // overscan_info_present_flag\n        gb.readBool(); // overscan_appropriate_flag\n      }\n\n      if (gb.readBool()) {\n        // video_signal_type_present_flag\n        gb.readBits(4); // video_format & video_full_range_flag\n\n        if (gb.readBool()) {\n          // colour_description_present_flag\n          gb.readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n        }\n      }\n\n      if (gb.readBool()) {\n        // chroma_loc_info_present_flag\n        gb.readUEG(); // chroma_sample_loc_type_top_field\n\n        gb.readUEG(); // chroma_sample_loc_type_bottom_field\n      }\n\n      if (gb.readBool()) {\n        // timing_info_present_flag\n        let num_units_in_tick = gb.readBits(32);\n        let time_scale = gb.readBits(32);\n        fps_fixed = gb.readBool(); // fixed_frame_rate_flag\n\n        fps_num = time_scale;\n        fps_den = num_units_in_tick * 2;\n        fps = fps_num / fps_den;\n      }\n    }\n\n    let sarScale = 1;\n\n    if (sar_width !== 1 || sar_height !== 1) {\n      sarScale = sar_width / sar_height;\n    }\n\n    let crop_unit_x = 0,\n        crop_unit_y = 0;\n\n    if (chroma_format_idc === 0) {\n      crop_unit_x = 1;\n      crop_unit_y = 2 - frame_mbs_only_flag;\n    } else {\n      let sub_wc = chroma_format_idc === 3 ? 1 : 2;\n      let sub_hc = chroma_format_idc === 1 ? 2 : 1;\n      crop_unit_x = sub_wc;\n      crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n    }\n\n    let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n    let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n    codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n    codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n    let present_width = Math.ceil(codec_width * sarScale);\n    gb.destroy();\n    gb = null;\n    return {\n      profile_string: profile_string,\n      // baseline, high, high10, ...\n      level_string: level_string,\n      // 3, 3.1, 4, 4.1, 5, 5.1, ...\n      bit_depth: bit_depth,\n      // 8bit, 10bit, ...\n      ref_frames: ref_frames,\n      chroma_format: chroma_format,\n      // 4:2:0, 4:2:2, ...\n      chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n      frame_rate: {\n        fixed: fps_fixed,\n        fps: fps,\n        fps_den: fps_den,\n        fps_num: fps_num\n      },\n      sar_ratio: {\n        width: sar_width,\n        height: sar_height\n      },\n      codec_size: {\n        width: codec_width,\n        height: codec_height\n      },\n      present_size: {\n        width: present_width,\n        height: codec_height\n      }\n    };\n  }\n\n  static _skipScalingList(gb, count) {\n    let last_scale = 8,\n        next_scale = 8;\n    let delta_scale = 0;\n\n    for (let i = 0; i < count; i++) {\n      if (next_scale !== 0) {\n        delta_scale = gb.readSEG();\n        next_scale = (last_scale + delta_scale + 256) % 256;\n      }\n\n      last_scale = next_scale === 0 ? last_scale : next_scale;\n    }\n  }\n\n  static getProfileString(profile_idc) {\n    switch (profile_idc) {\n      case 66:\n        return 'Baseline';\n\n      case 77:\n        return 'Main';\n\n      case 88:\n        return 'Extended';\n\n      case 100:\n        return 'High';\n\n      case 110:\n        return 'High10';\n\n      case 122:\n        return 'High422';\n\n      case 244:\n        return 'High444';\n\n      default:\n        return 'Unknown';\n    }\n  }\n\n  static getLevelString(level_idc) {\n    return (level_idc / 10).toFixed(1);\n  }\n\n  static getChromaFormatString(chroma) {\n    switch (chroma) {\n      case 420:\n        return '4:2:0';\n\n      case 422:\n        return '4:2:2';\n\n      case 444:\n        return '4:4:4';\n\n      default:\n        return 'Unknown';\n    }\n  }\n\n}\n\nexport default SPSParser;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/demux/sps-parser.js"],"names":["ExpGolomb","SPSParser","_ebsp2rbsp","uint8array","src","src_length","byteLength","dst","Uint8Array","dst_idx","i","buffer","parseSPS","rbsp","gb","readByte","profile_idc","level_idc","readUEG","profile_string","getProfileString","level_string","getLevelString","chroma_format_idc","chroma_format","chroma_format_table","bit_depth","readBits","readBool","scaling_list_count","_skipScalingList","pic_order_cnt_type","readSEG","num_ref_frames_in_pic_order_cnt_cycle","ref_frames","pic_width_in_mbs_minus1","pic_height_in_map_units_minus1","frame_mbs_only_flag","frame_crop_left_offset","frame_crop_right_offset","frame_crop_top_offset","frame_crop_bottom_offset","frame_cropping_flag","sar_width","sar_height","fps","fps_fixed","fps_num","fps_den","vui_parameters_present_flag","aspect_ratio_idc","sar_w_table","sar_h_table","num_units_in_tick","time_scale","sarScale","crop_unit_x","crop_unit_y","sub_wc","sub_hc","codec_width","codec_height","present_width","Math","ceil","destroy","chroma_format_string","getChromaFormatString","frame_rate","fixed","sar_ratio","width","height","codec_size","present_size","count","last_scale","next_scale","delta_scale","toFixed","chroma"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport ExpGolomb from './exp-golomb.js';\n\nclass SPSParser {\n\n    static _ebsp2rbsp(uint8array) {\n        let src = uint8array;\n        let src_length = src.byteLength;\n        let dst = new Uint8Array(src_length);\n        let dst_idx = 0;\n\n        for (let i = 0; i < src_length; i++) {\n            if (i >= 2) {\n                // Unescape: Skip 0x03 after 00 00\n                if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n                    continue;\n                }\n            }\n            dst[dst_idx] = src[i];\n            dst_idx++;\n        }\n\n        return new Uint8Array(dst.buffer, 0, dst_idx);\n    }\n\n    static parseSPS(uint8array) {\n        let rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb = new ExpGolomb(rbsp);\n\n        gb.readByte();\n        let profile_idc = gb.readByte();  // profile_idc\n        gb.readByte();  // constraint_set_flags[5] + reserved_zero[3]\n        let level_idc = gb.readByte();  // level_idc\n        gb.readUEG();  // seq_parameter_set_id\n\n        let profile_string = SPSParser.getProfileString(profile_idc);\n        let level_string = SPSParser.getLevelString(level_idc);\n        let chroma_format_idc = 1;\n        let chroma_format = 420;\n        let chroma_format_table = [0, 420, 422, 444];\n        let bit_depth = 8;\n\n        if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 ||\n            profile_idc === 244 || profile_idc === 44 || profile_idc === 83 ||\n            profile_idc === 86 || profile_idc === 118 || profile_idc === 128 ||\n            profile_idc === 138 || profile_idc === 144) {\n\n            chroma_format_idc = gb.readUEG();\n            if (chroma_format_idc === 3) {\n                gb.readBits(1);  // separate_colour_plane_flag\n            }\n            if (chroma_format_idc <= 3) {\n                chroma_format = chroma_format_table[chroma_format_idc];\n            }\n\n            bit_depth = gb.readUEG() + 8;  // bit_depth_luma_minus8\n            gb.readUEG();  // bit_depth_chroma_minus8\n            gb.readBits(1);  // qpprime_y_zero_transform_bypass_flag\n            if (gb.readBool()) {  // seq_scaling_matrix_present_flag\n                let scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12;\n                for (let i = 0; i < scaling_list_count; i++) {\n                    if (gb.readBool()) {  // seq_scaling_list_present_flag\n                        if (i < 6) {\n                            SPSParser._skipScalingList(gb, 16);\n                        } else {\n                            SPSParser._skipScalingList(gb, 64);\n                        }\n                    }\n                }\n            }\n        }\n        gb.readUEG();  // log2_max_frame_num_minus4\n        let pic_order_cnt_type = gb.readUEG();\n        if (pic_order_cnt_type === 0) {\n            gb.readUEG();  // log2_max_pic_order_cnt_lsb_minus_4\n        } else if (pic_order_cnt_type === 1) {\n            gb.readBits(1);  // delta_pic_order_always_zero_flag\n            gb.readSEG();  // offset_for_non_ref_pic\n            gb.readSEG();  // offset_for_top_to_bottom_field\n            let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n            for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n                gb.readSEG();  // offset_for_ref_frame\n            }\n        }\n        let ref_frames = gb.readUEG();  // max_num_ref_frames\n        gb.readBits(1);  // gaps_in_frame_num_value_allowed_flag\n\n        let pic_width_in_mbs_minus1 = gb.readUEG();\n        let pic_height_in_map_units_minus1 = gb.readUEG();\n\n        let frame_mbs_only_flag = gb.readBits(1);\n        if (frame_mbs_only_flag === 0) {\n            gb.readBits(1);  // mb_adaptive_frame_field_flag\n        }\n        gb.readBits(1);  // direct_8x8_inference_flag\n\n        let frame_crop_left_offset = 0;\n        let frame_crop_right_offset = 0;\n        let frame_crop_top_offset = 0;\n        let frame_crop_bottom_offset = 0;\n\n        let frame_cropping_flag = gb.readBool();\n        if (frame_cropping_flag) {\n            frame_crop_left_offset = gb.readUEG();\n            frame_crop_right_offset = gb.readUEG();\n            frame_crop_top_offset = gb.readUEG();\n            frame_crop_bottom_offset = gb.readUEG();\n        }\n\n        let sar_width = 1, sar_height = 1;\n        let fps = 0, fps_fixed = true, fps_num = 0, fps_den = 0;\n\n        let vui_parameters_present_flag = gb.readBool();\n        if (vui_parameters_present_flag) {\n            if (gb.readBool()) {  // aspect_ratio_info_present_flag\n                let aspect_ratio_idc = gb.readByte();\n                let sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n                let sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33,  99, 3, 2, 1];\n\n                if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n                    sar_width = sar_w_table[aspect_ratio_idc - 1];\n                    sar_height = sar_h_table[aspect_ratio_idc - 1];\n                } else if (aspect_ratio_idc === 255) {\n                    sar_width = gb.readByte() << 8 | gb.readByte();\n                    sar_height = gb.readByte() << 8 | gb.readByte();\n                }\n            }\n\n            if (gb.readBool()) {  // overscan_info_present_flag\n                gb.readBool();  // overscan_appropriate_flag\n            }\n            if (gb.readBool()) {  // video_signal_type_present_flag\n                gb.readBits(4);  // video_format & video_full_range_flag\n                if (gb.readBool()) {  // colour_description_present_flag\n                    gb.readBits(24);  // colour_primaries & transfer_characteristics & matrix_coefficients\n                }\n            }\n            if (gb.readBool()) {  // chroma_loc_info_present_flag\n                gb.readUEG();  // chroma_sample_loc_type_top_field\n                gb.readUEG();  // chroma_sample_loc_type_bottom_field\n            }\n            if (gb.readBool()) {  // timing_info_present_flag\n                let num_units_in_tick = gb.readBits(32);\n                let time_scale = gb.readBits(32);\n                fps_fixed = gb.readBool();  // fixed_frame_rate_flag\n\n                fps_num = time_scale;\n                fps_den = num_units_in_tick * 2;\n                fps = fps_num / fps_den;\n            }\n        }\n\n        let sarScale = 1;\n        if (sar_width !== 1 || sar_height !== 1) {\n            sarScale = sar_width / sar_height;\n        }\n\n        let crop_unit_x = 0, crop_unit_y = 0;\n        if (chroma_format_idc === 0) {\n            crop_unit_x = 1;\n            crop_unit_y = 2 - frame_mbs_only_flag;\n        } else {\n            let sub_wc = (chroma_format_idc === 3) ? 1 : 2;\n            let sub_hc = (chroma_format_idc === 1) ? 2 : 1;\n            crop_unit_x = sub_wc;\n            crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n        }\n\n        let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n        let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n        let present_width = Math.ceil(codec_width * sarScale);\n\n        gb.destroy();\n        gb = null;\n\n        return {\n            profile_string: profile_string,  // baseline, high, high10, ...\n            level_string: level_string,  // 3, 3.1, 4, 4.1, 5, 5.1, ...\n            bit_depth: bit_depth,  // 8bit, 10bit, ...\n            ref_frames: ref_frames,\n            chroma_format: chroma_format,  // 4:2:0, 4:2:2, ...\n            chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n            frame_rate: {\n                fixed: fps_fixed,\n                fps: fps,\n                fps_den: fps_den,\n                fps_num: fps_num\n            },\n\n            sar_ratio: {\n                width: sar_width,\n                height: sar_height\n            },\n\n            codec_size: {\n                width: codec_width,\n                height: codec_height\n            },\n\n            present_size: {\n                width: present_width,\n                height: codec_height\n            }\n        };\n    }\n\n    static _skipScalingList(gb, count) {\n        let last_scale = 8, next_scale = 8;\n        let delta_scale = 0;\n        for (let i = 0; i < count; i++) {\n            if (next_scale !== 0) {\n                delta_scale = gb.readSEG();\n                next_scale = (last_scale + delta_scale + 256) % 256;\n            }\n            last_scale = (next_scale === 0) ? last_scale : next_scale;\n        }\n    }\n\n    static getProfileString(profile_idc) {\n        switch (profile_idc) {\n            case 66:\n                return 'Baseline';\n            case 77:\n                return 'Main';\n            case 88:\n                return 'Extended';\n            case 100:\n                return 'High';\n            case 110:\n                return 'High10';\n            case 122:\n                return 'High422';\n            case 244:\n                return 'High444';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getLevelString(level_idc) {\n        return (level_idc / 10).toFixed(1);\n    }\n\n    static getChromaFormatString(chroma) {\n        switch (chroma) {\n            case 420:\n                return '4:2:0';\n            case 422:\n                return '4:2:2';\n            case 444:\n                return '4:4:4';\n            default:\n                return 'Unknown';\n        }\n    }\n\n}\n\nexport default SPSParser;"]},"metadata":{},"sourceType":"module"}