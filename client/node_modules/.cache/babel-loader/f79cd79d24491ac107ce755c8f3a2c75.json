{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { LoaderStatus, LoaderErrors } from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport { RuntimeException, IllegalStateException, InvalidArgumentException } from '../utils/exception.js';\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n// Manage IO Loaders\n\nclass IOController {\n  constructor(dataSource, config, extraData) {\n    this.TAG = 'IOController';\n    this._config = config;\n    this._extraData = extraData;\n    this._stashInitialSize = 1024 * 384; // default initial size: 384KB\n\n    if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n      // apply from config\n      this._stashInitialSize = config.stashInitialSize;\n    }\n\n    this._stashUsed = 0;\n    this._stashSize = this._stashInitialSize;\n    this._bufferSize = 1024 * 1024 * 3; // initial size: 3MB\n\n    this._stashBuffer = new ArrayBuffer(this._bufferSize);\n    this._stashByteStart = 0;\n    this._enableStash = true;\n\n    if (config.enableStashBuffer === false) {\n      this._enableStash = false;\n    }\n\n    this._loader = null;\n    this._loaderClass = null;\n    this._seekHandler = null;\n    this._dataSource = dataSource;\n    this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n    this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n    this._totalLength = this._refTotalLength;\n    this._fullRequestFlag = false;\n    this._currentRange = null;\n    this._redirectedURL = null;\n    this._speedNormalized = 0;\n    this._speedSampler = new SpeedSampler();\n    this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n    this._isEarlyEofReconnecting = false;\n    this._paused = false;\n    this._resumeFrom = 0;\n    this._onDataArrival = null;\n    this._onSeeked = null;\n    this._onError = null;\n    this._onComplete = null;\n    this._onRedirect = null;\n    this._onRecoveredEarlyEof = null;\n\n    this._selectSeekHandler();\n\n    this._selectLoader();\n\n    this._createLoader();\n  }\n\n  destroy() {\n    if (this._loader.isWorking()) {\n      this._loader.abort();\n    }\n\n    this._loader.destroy();\n\n    this._loader = null;\n    this._loaderClass = null;\n    this._dataSource = null;\n    this._stashBuffer = null;\n    this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n    this._currentRange = null;\n    this._speedSampler = null;\n    this._isEarlyEofReconnecting = false;\n    this._onDataArrival = null;\n    this._onSeeked = null;\n    this._onError = null;\n    this._onComplete = null;\n    this._onRedirect = null;\n    this._onRecoveredEarlyEof = null;\n    this._extraData = null;\n  }\n\n  isWorking() {\n    return this._loader && this._loader.isWorking() && !this._paused;\n  }\n\n  isPaused() {\n    return this._paused;\n  }\n\n  get status() {\n    return this._loader.status;\n  }\n\n  get extraData() {\n    return this._extraData;\n  }\n\n  set extraData(data) {\n    this._extraData = data;\n  } // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n\n\n  get onDataArrival() {\n    return this._onDataArrival;\n  }\n\n  set onDataArrival(callback) {\n    this._onDataArrival = callback;\n  }\n\n  get onSeeked() {\n    return this._onSeeked;\n  }\n\n  set onSeeked(callback) {\n    this._onSeeked = callback;\n  } // prototype: function onError(type: number, info: {code: number, msg: string}): void\n\n\n  get onError() {\n    return this._onError;\n  }\n\n  set onError(callback) {\n    this._onError = callback;\n  }\n\n  get onComplete() {\n    return this._onComplete;\n  }\n\n  set onComplete(callback) {\n    this._onComplete = callback;\n  }\n\n  get onRedirect() {\n    return this._onRedirect;\n  }\n\n  set onRedirect(callback) {\n    this._onRedirect = callback;\n  }\n\n  get onRecoveredEarlyEof() {\n    return this._onRecoveredEarlyEof;\n  }\n\n  set onRecoveredEarlyEof(callback) {\n    this._onRecoveredEarlyEof = callback;\n  }\n\n  get currentURL() {\n    return this._dataSource.url;\n  }\n\n  get hasRedirect() {\n    return this._redirectedURL != null || this._dataSource.redirectedURL != undefined;\n  }\n\n  get currentRedirectedURL() {\n    return this._redirectedURL || this._dataSource.redirectedURL;\n  } // in KB/s\n\n\n  get currentSpeed() {\n    if (this._loaderClass === RangeLoader) {\n      // SpeedSampler is inaccuracy if loader is RangeLoader\n      return this._loader.currentSpeed;\n    }\n\n    return this._speedSampler.lastSecondKBps;\n  }\n\n  get loaderType() {\n    return this._loader.type;\n  }\n\n  _selectSeekHandler() {\n    let config = this._config;\n\n    if (config.seekType === 'range') {\n      this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n    } else if (config.seekType === 'param') {\n      let paramStart = config.seekParamStart || 'bstart';\n      let paramEnd = config.seekParamEnd || 'bend';\n      this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n    } else if (config.seekType === 'custom') {\n      if (typeof config.customSeekHandler !== 'function') {\n        throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n      }\n\n      this._seekHandler = new config.customSeekHandler();\n    } else {\n      throw new InvalidArgumentException(`Invalid seekType in config: ${config.seekType}`);\n    }\n  }\n\n  _selectLoader() {\n    if (this._config.customLoader != null) {\n      this._loaderClass = this._config.customLoader;\n    } else if (this._isWebSocketURL) {\n      this._loaderClass = WebSocketLoader;\n    } else if (FetchStreamLoader.isSupported()) {\n      this._loaderClass = FetchStreamLoader;\n    } else if (MozChunkedLoader.isSupported()) {\n      this._loaderClass = MozChunkedLoader;\n    } else if (RangeLoader.isSupported()) {\n      this._loaderClass = RangeLoader;\n    } else {\n      throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n    }\n  }\n\n  _createLoader() {\n    this._loader = new this._loaderClass(this._seekHandler, this._config);\n\n    if (this._loader.needStashBuffer === false) {\n      this._enableStash = false;\n    }\n\n    this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n    this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n    this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n    this._loader.onComplete = this._onLoaderComplete.bind(this);\n    this._loader.onError = this._onLoaderError.bind(this);\n  }\n\n  open(optionalFrom) {\n    this._currentRange = {\n      from: 0,\n      to: -1\n    };\n\n    if (optionalFrom) {\n      this._currentRange.from = optionalFrom;\n    }\n\n    this._speedSampler.reset();\n\n    if (!optionalFrom) {\n      this._fullRequestFlag = true;\n    }\n\n    this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n  }\n\n  abort() {\n    this._loader.abort();\n\n    if (this._paused) {\n      this._paused = false;\n      this._resumeFrom = 0;\n    }\n  }\n\n  pause() {\n    if (this.isWorking()) {\n      this._loader.abort();\n\n      if (this._stashUsed !== 0) {\n        this._resumeFrom = this._stashByteStart;\n        this._currentRange.to = this._stashByteStart - 1;\n      } else {\n        this._resumeFrom = this._currentRange.to + 1;\n      }\n\n      this._stashUsed = 0;\n      this._stashByteStart = 0;\n      this._paused = true;\n    }\n  }\n\n  resume() {\n    if (this._paused) {\n      this._paused = false;\n      let bytes = this._resumeFrom;\n      this._resumeFrom = 0;\n\n      this._internalSeek(bytes, true);\n    }\n  }\n\n  seek(bytes) {\n    this._paused = false;\n    this._stashUsed = 0;\n    this._stashByteStart = 0;\n\n    this._internalSeek(bytes, true);\n  }\n  /**\n   * When seeking request is from media seeking, unconsumed stash data should be dropped\n   * However, stash data shouldn't be dropped if seeking requested from http reconnection\n   *\n   * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n   */\n\n\n  _internalSeek(bytes, dropUnconsumed) {\n    if (this._loader.isWorking()) {\n      this._loader.abort();\n    } // dispatch & flush stash buffer before seek\n\n\n    this._flushStashBuffer(dropUnconsumed);\n\n    this._loader.destroy();\n\n    this._loader = null;\n    let requestRange = {\n      from: bytes,\n      to: -1\n    };\n    this._currentRange = {\n      from: requestRange.from,\n      to: -1\n    };\n\n    this._speedSampler.reset();\n\n    this._stashSize = this._stashInitialSize;\n\n    this._createLoader();\n\n    this._loader.open(this._dataSource, requestRange);\n\n    if (this._onSeeked) {\n      this._onSeeked();\n    }\n  }\n\n  updateUrl(url) {\n    if (!url || typeof url !== 'string' || url.length === 0) {\n      throw new InvalidArgumentException('Url must be a non-empty string!');\n    }\n\n    this._dataSource.url = url; // TODO: replace with new url\n  }\n\n  _expandBuffer(expectedBytes) {\n    let bufferNewSize = this._stashSize;\n\n    while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n      bufferNewSize *= 2;\n    }\n\n    bufferNewSize += 1024 * 1024 * 1; // bufferSize = stashSize + 1MB\n\n    if (bufferNewSize === this._bufferSize) {\n      return;\n    }\n\n    let newBuffer = new ArrayBuffer(bufferNewSize);\n\n    if (this._stashUsed > 0) {\n      // copy existing data into new buffer\n      let stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n      let stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n      stashNewArray.set(stashOldArray, 0);\n    }\n\n    this._stashBuffer = newBuffer;\n    this._bufferSize = bufferNewSize;\n  }\n\n  _normalizeSpeed(input) {\n    let list = this._speedNormalizeList;\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n\n    if (input < list[0]) {\n      return list[0];\n    } // binary search\n\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n        return list[mid];\n      } else if (list[mid] < input) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n  }\n\n  _adjustStashSize(normalized) {\n    let stashSizeKB = 0;\n\n    if (this._config.isLive) {\n      // live stream: always use single normalized speed for size of stashSizeKB\n      stashSizeKB = normalized;\n    } else {\n      if (normalized < 512) {\n        stashSizeKB = normalized;\n      } else if (normalized >= 512 && normalized <= 1024) {\n        stashSizeKB = Math.floor(normalized * 1.5);\n      } else {\n        stashSizeKB = normalized * 2;\n      }\n    }\n\n    if (stashSizeKB > 8192) {\n      stashSizeKB = 8192;\n    }\n\n    let bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1; // stashSize + 1MB\n\n    if (this._bufferSize < bufferSize) {\n      this._expandBuffer(bufferSize);\n    }\n\n    this._stashSize = stashSizeKB * 1024;\n  }\n\n  _dispatchChunks(chunks, byteStart) {\n    this._currentRange.to = byteStart + chunks.byteLength - 1;\n    return this._onDataArrival(chunks, byteStart);\n  }\n\n  _onURLRedirect(redirectedURL) {\n    this._redirectedURL = redirectedURL;\n\n    if (this._onRedirect) {\n      this._onRedirect(redirectedURL);\n    }\n  }\n\n  _onContentLengthKnown(contentLength) {\n    if (contentLength && this._fullRequestFlag) {\n      this._totalLength = contentLength;\n      this._fullRequestFlag = false;\n    }\n  }\n\n  _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n    if (!this._onDataArrival) {\n      throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n    }\n\n    if (this._paused) {\n      return;\n    }\n\n    if (this._isEarlyEofReconnecting) {\n      // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n      this._isEarlyEofReconnecting = false;\n\n      if (this._onRecoveredEarlyEof) {\n        this._onRecoveredEarlyEof();\n      }\n    }\n\n    this._speedSampler.addBytes(chunk.byteLength); // adjust stash buffer size according to network speed dynamically\n\n\n    let KBps = this._speedSampler.lastSecondKBps;\n\n    if (KBps !== 0) {\n      let normalized = this._normalizeSpeed(KBps);\n\n      if (this._speedNormalized !== normalized) {\n        this._speedNormalized = normalized;\n\n        this._adjustStashSize(normalized);\n      }\n    }\n\n    if (!this._enableStash) {\n      // disable stash\n      if (this._stashUsed === 0) {\n        // dispatch chunk directly to consumer;\n        // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n        let consumed = this._dispatchChunks(chunk, byteStart);\n\n        if (consumed < chunk.byteLength) {\n          // unconsumed data remain.\n          let remain = chunk.byteLength - consumed;\n\n          if (remain > this._bufferSize) {\n            this._expandBuffer(remain);\n          }\n\n          let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n          stashArray.set(new Uint8Array(chunk, consumed), 0);\n          this._stashUsed += remain;\n          this._stashByteStart = byteStart + consumed;\n        }\n      } else {\n        // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n        if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n          this._expandBuffer(this._stashUsed + chunk.byteLength);\n        }\n\n        let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n        stashArray.set(new Uint8Array(chunk), this._stashUsed);\n        this._stashUsed += chunk.byteLength;\n\n        let consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n\n        if (consumed < this._stashUsed && consumed > 0) {\n          // unconsumed data remain\n          let remainArray = new Uint8Array(this._stashBuffer, consumed);\n          stashArray.set(remainArray, 0);\n        }\n\n        this._stashUsed -= consumed;\n        this._stashByteStart += consumed;\n      }\n    } else {\n      // enable stash\n      if (this._stashUsed === 0 && this._stashByteStart === 0) {\n        // seeked? or init chunk?\n        // This is the first chunk after seek action\n        this._stashByteStart = byteStart;\n      }\n\n      if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n        // just stash\n        let stashArray = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n        stashArray.set(new Uint8Array(chunk), this._stashUsed);\n        this._stashUsed += chunk.byteLength;\n      } else {\n        // stashUsed + chunkSize > stashSize, size limit exceeded\n        let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n        if (this._stashUsed > 0) {\n          // There're stash datas in buffer\n          // dispatch the whole stashBuffer, and stash remain data\n          // then append chunk to stashBuffer (stash)\n          let buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n          let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n\n          if (consumed < buffer.byteLength) {\n            if (consumed > 0) {\n              let remainArray = new Uint8Array(buffer, consumed);\n              stashArray.set(remainArray, 0);\n              this._stashUsed = remainArray.byteLength;\n              this._stashByteStart += consumed;\n            }\n          } else {\n            this._stashUsed = 0;\n            this._stashByteStart += consumed;\n          }\n\n          if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n            this._expandBuffer(this._stashUsed + chunk.byteLength);\n\n            stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n          }\n\n          stashArray.set(new Uint8Array(chunk), this._stashUsed);\n          this._stashUsed += chunk.byteLength;\n        } else {\n          // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n          // dispatch chunk directly and stash remain data\n          let consumed = this._dispatchChunks(chunk, byteStart);\n\n          if (consumed < chunk.byteLength) {\n            let remain = chunk.byteLength - consumed;\n\n            if (remain > this._bufferSize) {\n              this._expandBuffer(remain);\n\n              stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            }\n\n            stashArray.set(new Uint8Array(chunk, consumed), 0);\n            this._stashUsed += remain;\n            this._stashByteStart = byteStart + consumed;\n          }\n        }\n      }\n    }\n  }\n\n  _flushStashBuffer(dropUnconsumed) {\n    if (this._stashUsed > 0) {\n      let buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n      let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n\n      let remain = buffer.byteLength - consumed;\n\n      if (consumed < buffer.byteLength) {\n        if (dropUnconsumed) {\n          Log.w(this.TAG, `${remain} bytes unconsumed data remain when flush buffer, dropped`);\n        } else {\n          if (consumed > 0) {\n            let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            let remainArray = new Uint8Array(buffer, consumed);\n            stashArray.set(remainArray, 0);\n            this._stashUsed = remainArray.byteLength;\n            this._stashByteStart += consumed;\n          }\n\n          return 0;\n        }\n      }\n\n      this._stashUsed = 0;\n      this._stashByteStart = 0;\n      return remain;\n    }\n\n    return 0;\n  }\n\n  _onLoaderComplete(from, to) {\n    // Force-flush stash buffer, and drop unconsumed data\n    this._flushStashBuffer(true);\n\n    if (this._onComplete) {\n      this._onComplete(this._extraData);\n    }\n  }\n\n  _onLoaderError(type, data) {\n    Log.e(this.TAG, `Loader error, code = ${data.code}, msg = ${data.msg}`);\n\n    this._flushStashBuffer(false);\n\n    if (this._isEarlyEofReconnecting) {\n      // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n      this._isEarlyEofReconnecting = false;\n      type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n    }\n\n    switch (type) {\n      case LoaderErrors.EARLY_EOF:\n        {\n          if (!this._config.isLive) {\n            // Do internal http reconnect if not live stream\n            if (this._totalLength) {\n              let nextFrom = this._currentRange.to + 1;\n\n              if (nextFrom < this._totalLength) {\n                Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                this._isEarlyEofReconnecting = true;\n\n                this._internalSeek(nextFrom, false);\n              }\n\n              return;\n            } // else: We don't know totalLength, throw UnrecoverableEarlyEof\n\n          } // live stream: throw UnrecoverableEarlyEof error to upper-layer\n\n\n          type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n          break;\n        }\n\n      case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n      case LoaderErrors.CONNECTING_TIMEOUT:\n      case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n      case LoaderErrors.EXCEPTION:\n        break;\n    }\n\n    if (this._onError) {\n      this._onError(type, data);\n    } else {\n      throw new RuntimeException('IOException: ' + data.msg);\n    }\n  }\n\n}\n\nexport default IOController;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/io/io-controller.js"],"names":["Log","SpeedSampler","LoaderStatus","LoaderErrors","FetchStreamLoader","MozChunkedLoader","MSStreamLoader","RangeLoader","WebSocketLoader","RangeSeekHandler","ParamSeekHandler","RuntimeException","IllegalStateException","InvalidArgumentException","IOController","constructor","dataSource","config","extraData","TAG","_config","_extraData","_stashInitialSize","stashInitialSize","undefined","_stashUsed","_stashSize","_bufferSize","_stashBuffer","ArrayBuffer","_stashByteStart","_enableStash","enableStashBuffer","_loader","_loaderClass","_seekHandler","_dataSource","_isWebSocketURL","test","url","_refTotalLength","filesize","_totalLength","_fullRequestFlag","_currentRange","_redirectedURL","_speedNormalized","_speedSampler","_speedNormalizeList","_isEarlyEofReconnecting","_paused","_resumeFrom","_onDataArrival","_onSeeked","_onError","_onComplete","_onRedirect","_onRecoveredEarlyEof","_selectSeekHandler","_selectLoader","_createLoader","destroy","isWorking","abort","isPaused","status","data","onDataArrival","callback","onSeeked","onError","onComplete","onRedirect","onRecoveredEarlyEof","currentURL","hasRedirect","redirectedURL","currentRedirectedURL","currentSpeed","lastSecondKBps","loaderType","type","seekType","rangeLoadZeroStart","paramStart","seekParamStart","paramEnd","seekParamEnd","customSeekHandler","customLoader","isSupported","needStashBuffer","onContentLengthKnown","_onContentLengthKnown","bind","onURLRedirect","_onURLRedirect","_onLoaderChunkArrival","_onLoaderComplete","_onLoaderError","open","optionalFrom","from","to","reset","Object","assign","pause","resume","bytes","_internalSeek","seek","dropUnconsumed","_flushStashBuffer","requestRange","updateUrl","length","_expandBuffer","expectedBytes","bufferNewSize","newBuffer","stashOldArray","Uint8Array","stashNewArray","set","_normalizeSpeed","input","list","last","mid","lbound","ubound","Math","floor","_adjustStashSize","normalized","stashSizeKB","isLive","bufferSize","_dispatchChunks","chunks","byteStart","byteLength","contentLength","chunk","receivedLength","addBytes","KBps","consumed","remain","stashArray","slice","remainArray","buffer","w","e","code","msg","UNRECOVERABLE_EARLY_EOF","EARLY_EOF","nextFrom","CONNECTING_TIMEOUT","HTTP_STATUS_CODE_INVALID","EXCEPTION"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport {LoaderStatus, LoaderErrors} from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport {RuntimeException, IllegalStateException, InvalidArgumentException} from '../utils/exception.js';\n\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n\n// Manage IO Loaders\nclass IOController {\n\n    constructor(dataSource, config, extraData) {\n        this.TAG = 'IOController';\n\n        this._config = config;\n        this._extraData = extraData;\n\n        this._stashInitialSize = 1024 * 384;  // default initial size: 384KB\n        if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n            // apply from config\n            this._stashInitialSize = config.stashInitialSize;\n        }\n\n        this._stashUsed = 0;\n        this._stashSize = this._stashInitialSize;\n        this._bufferSize = 1024 * 1024 * 3;  // initial size: 3MB\n        this._stashBuffer = new ArrayBuffer(this._bufferSize);\n        this._stashByteStart = 0;\n        this._enableStash = true;\n        if (config.enableStashBuffer === false) {\n            this._enableStash = false;\n        }\n\n        this._loader = null;\n        this._loaderClass = null;\n        this._seekHandler = null;\n\n        this._dataSource = dataSource;\n        this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n        this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n        this._totalLength = this._refTotalLength;\n        this._fullRequestFlag = false;\n        this._currentRange = null;\n        this._redirectedURL = null;\n\n        this._speedNormalized = 0;\n        this._speedSampler = new SpeedSampler();\n        this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n\n        this._isEarlyEofReconnecting = false;\n\n        this._paused = false;\n        this._resumeFrom = 0;\n\n        this._onDataArrival = null;\n        this._onSeeked = null;\n        this._onError = null;\n        this._onComplete = null;\n        this._onRedirect = null;\n        this._onRecoveredEarlyEof = null;\n\n        this._selectSeekHandler();\n        this._selectLoader();\n        this._createLoader();\n    }\n\n    destroy() {\n        if (this._loader.isWorking()) {\n            this._loader.abort();\n        }\n        this._loader.destroy();\n        this._loader = null;\n        this._loaderClass = null;\n        this._dataSource = null;\n        this._stashBuffer = null;\n        this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n        this._currentRange = null;\n        this._speedSampler = null;\n\n        this._isEarlyEofReconnecting = false;\n\n        this._onDataArrival = null;\n        this._onSeeked = null;\n        this._onError = null;\n        this._onComplete = null;\n        this._onRedirect = null;\n        this._onRecoveredEarlyEof = null;\n\n        this._extraData = null;\n    }\n\n    isWorking() {\n        return this._loader && this._loader.isWorking() && !this._paused;\n    }\n\n    isPaused() {\n        return this._paused;\n    }\n\n    get status() {\n        return this._loader.status;\n    }\n\n    get extraData() {\n        return this._extraData;\n    }\n\n    set extraData(data) {\n        this._extraData = data;\n    }\n\n    // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n    get onDataArrival() {\n        return this._onDataArrival;\n    }\n\n    set onDataArrival(callback) {\n        this._onDataArrival = callback;\n    }\n\n    get onSeeked() {\n        return this._onSeeked;\n    }\n\n    set onSeeked(callback) {\n        this._onSeeked = callback;\n    }\n\n    // prototype: function onError(type: number, info: {code: number, msg: string}): void\n    get onError() {\n        return this._onError;\n    }\n\n    set onError(callback) {\n        this._onError = callback;\n    }\n\n    get onComplete() {\n        return this._onComplete;\n    }\n\n    set onComplete(callback) {\n        this._onComplete = callback;\n    }\n\n    get onRedirect() {\n        return this._onRedirect;\n    }\n\n    set onRedirect(callback) {\n        this._onRedirect = callback;\n    }\n\n    get onRecoveredEarlyEof() {\n        return this._onRecoveredEarlyEof;\n    }\n\n    set onRecoveredEarlyEof(callback) {\n        this._onRecoveredEarlyEof = callback;\n    }\n\n    get currentURL() {\n        return this._dataSource.url;\n    }\n\n    get hasRedirect() {\n        return (this._redirectedURL != null || this._dataSource.redirectedURL != undefined);\n    }\n\n    get currentRedirectedURL() {\n        return this._redirectedURL || this._dataSource.redirectedURL;\n    }\n\n    // in KB/s\n    get currentSpeed() {\n        if (this._loaderClass === RangeLoader) {\n            // SpeedSampler is inaccuracy if loader is RangeLoader\n            return this._loader.currentSpeed;\n        }\n        return this._speedSampler.lastSecondKBps;\n    }\n\n    get loaderType() {\n        return this._loader.type;\n    }\n\n    _selectSeekHandler() {\n        let config = this._config;\n\n        if (config.seekType === 'range') {\n            this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n        } else if (config.seekType === 'param') {\n            let paramStart = config.seekParamStart || 'bstart';\n            let paramEnd = config.seekParamEnd || 'bend';\n\n            this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n        } else if (config.seekType === 'custom') {\n            if (typeof config.customSeekHandler !== 'function') {\n                throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n            }\n            this._seekHandler = new config.customSeekHandler();\n        } else {\n            throw new InvalidArgumentException(`Invalid seekType in config: ${config.seekType}`);\n        }\n    }\n\n    _selectLoader() {\n        if (this._config.customLoader != null) {\n            this._loaderClass = this._config.customLoader;\n        } else if (this._isWebSocketURL) {\n            this._loaderClass = WebSocketLoader;\n        } else if (FetchStreamLoader.isSupported()) {\n            this._loaderClass = FetchStreamLoader;\n        } else if (MozChunkedLoader.isSupported()) {\n            this._loaderClass = MozChunkedLoader;\n        } else if (RangeLoader.isSupported()) {\n            this._loaderClass = RangeLoader;\n        } else {\n            throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n        }\n    }\n\n    _createLoader() {\n        this._loader = new this._loaderClass(this._seekHandler, this._config);\n        if (this._loader.needStashBuffer === false) {\n            this._enableStash = false;\n        }\n        this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n        this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n        this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n        this._loader.onComplete = this._onLoaderComplete.bind(this);\n        this._loader.onError = this._onLoaderError.bind(this);\n    }\n\n    open(optionalFrom) {\n        this._currentRange = {from: 0, to: -1};\n        if (optionalFrom) {\n            this._currentRange.from = optionalFrom;\n        }\n\n        this._speedSampler.reset();\n        if (!optionalFrom) {\n            this._fullRequestFlag = true;\n        }\n\n        this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n    }\n\n    abort() {\n        this._loader.abort();\n\n        if (this._paused) {\n            this._paused = false;\n            this._resumeFrom = 0;\n        }\n    }\n\n    pause() {\n        if (this.isWorking()) {\n            this._loader.abort();\n\n            if (this._stashUsed !== 0) {\n                this._resumeFrom = this._stashByteStart;\n                this._currentRange.to = this._stashByteStart - 1;\n            } else {\n                this._resumeFrom = this._currentRange.to + 1;\n            }\n            this._stashUsed = 0;\n            this._stashByteStart = 0;\n            this._paused = true;\n        }\n    }\n\n    resume() {\n        if (this._paused) {\n            this._paused = false;\n            let bytes = this._resumeFrom;\n            this._resumeFrom = 0;\n            this._internalSeek(bytes, true);\n        }\n    }\n\n    seek(bytes) {\n        this._paused = false;\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        this._internalSeek(bytes, true);\n    }\n\n    /**\n     * When seeking request is from media seeking, unconsumed stash data should be dropped\n     * However, stash data shouldn't be dropped if seeking requested from http reconnection\n     *\n     * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n     */\n    _internalSeek(bytes, dropUnconsumed) {\n        if (this._loader.isWorking()) {\n            this._loader.abort();\n        }\n\n        // dispatch & flush stash buffer before seek\n        this._flushStashBuffer(dropUnconsumed);\n\n        this._loader.destroy();\n        this._loader = null;\n\n        let requestRange = {from: bytes, to: -1};\n        this._currentRange = {from: requestRange.from, to: -1};\n\n        this._speedSampler.reset();\n        this._stashSize = this._stashInitialSize;\n        this._createLoader();\n        this._loader.open(this._dataSource, requestRange);\n\n        if (this._onSeeked) {\n            this._onSeeked();\n        }\n    }\n\n    updateUrl(url) {\n        if (!url || typeof url !== 'string' || url.length === 0) {\n            throw new InvalidArgumentException('Url must be a non-empty string!');\n        }\n\n        this._dataSource.url = url;\n\n        // TODO: replace with new url\n    }\n\n    _expandBuffer(expectedBytes) {\n        let bufferNewSize = this._stashSize;\n        while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n            bufferNewSize *= 2;\n        }\n\n        bufferNewSize += 1024 * 1024 * 1;  // bufferSize = stashSize + 1MB\n        if (bufferNewSize === this._bufferSize) {\n            return;\n        }\n\n        let newBuffer = new ArrayBuffer(bufferNewSize);\n\n        if (this._stashUsed > 0) {  // copy existing data into new buffer\n            let stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n            let stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n            stashNewArray.set(stashOldArray, 0);\n        }\n\n        this._stashBuffer = newBuffer;\n        this._bufferSize = bufferNewSize;\n    }\n\n    _normalizeSpeed(input) {\n        let list = this._speedNormalizeList;\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (input < list[0]) {\n            return list[0];\n        }\n\n        // binary search\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (input >= list[mid] && input < list[mid + 1])) {\n                return list[mid];\n            } else if (list[mid] < input) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n    }\n\n    _adjustStashSize(normalized) {\n        let stashSizeKB = 0;\n\n        if (this._config.isLive) {\n            // live stream: always use single normalized speed for size of stashSizeKB\n            stashSizeKB = normalized;\n        } else {\n            if (normalized < 512) {\n                stashSizeKB = normalized;\n            } else if (normalized >= 512 && normalized <= 1024) {\n                stashSizeKB = Math.floor(normalized * 1.5);\n            } else {\n                stashSizeKB = normalized * 2;\n            }\n        }\n\n        if (stashSizeKB > 8192) {\n            stashSizeKB = 8192;\n        }\n\n        let bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1;  // stashSize + 1MB\n        if (this._bufferSize < bufferSize) {\n            this._expandBuffer(bufferSize);\n        }\n        this._stashSize = stashSizeKB * 1024;\n    }\n\n    _dispatchChunks(chunks, byteStart) {\n        this._currentRange.to = byteStart + chunks.byteLength - 1;\n        return this._onDataArrival(chunks, byteStart);\n    }\n\n    _onURLRedirect(redirectedURL) {\n        this._redirectedURL = redirectedURL;\n        if (this._onRedirect) {\n            this._onRedirect(redirectedURL);\n        }\n    }\n\n    _onContentLengthKnown(contentLength) {\n        if (contentLength && this._fullRequestFlag) {\n            this._totalLength = contentLength;\n            this._fullRequestFlag = false;\n        }\n    }\n\n    _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n        if (!this._onDataArrival) {\n            throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n        }\n        if (this._paused) {\n            return;\n        }\n        if (this._isEarlyEofReconnecting) {\n            // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n            this._isEarlyEofReconnecting = false;\n            if (this._onRecoveredEarlyEof) {\n                this._onRecoveredEarlyEof();\n            }\n        }\n\n        this._speedSampler.addBytes(chunk.byteLength);\n\n        // adjust stash buffer size according to network speed dynamically\n        let KBps = this._speedSampler.lastSecondKBps;\n        if (KBps !== 0) {\n            let normalized = this._normalizeSpeed(KBps);\n            if (this._speedNormalized !== normalized) {\n                this._speedNormalized = normalized;\n                this._adjustStashSize(normalized);\n            }\n        }\n\n        if (!this._enableStash) {  // disable stash\n            if (this._stashUsed === 0) {\n                // dispatch chunk directly to consumer;\n                // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n                let consumed = this._dispatchChunks(chunk, byteStart);\n                if (consumed < chunk.byteLength) {  // unconsumed data remain.\n                    let remain = chunk.byteLength - consumed;\n                    if (remain > this._bufferSize) {\n                        this._expandBuffer(remain);\n                    }\n                    let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                    stashArray.set(new Uint8Array(chunk, consumed), 0);\n                    this._stashUsed += remain;\n                    this._stashByteStart = byteStart + consumed;\n                }\n            } else {\n                // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n                if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n                    this._expandBuffer(this._stashUsed + chunk.byteLength);\n                }\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                this._stashUsed += chunk.byteLength;\n                let consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n                if (consumed < this._stashUsed && consumed > 0) {  // unconsumed data remain\n                    let remainArray = new Uint8Array(this._stashBuffer, consumed);\n                    stashArray.set(remainArray, 0);\n                }\n                this._stashUsed -= consumed;\n                this._stashByteStart += consumed;\n            }\n        } else {  // enable stash\n            if (this._stashUsed === 0 && this._stashByteStart === 0) {  // seeked? or init chunk?\n                // This is the first chunk after seek action\n                this._stashByteStart = byteStart;\n            }\n            if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n                // just stash\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n                stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                this._stashUsed += chunk.byteLength;\n            } else {  // stashUsed + chunkSize > stashSize, size limit exceeded\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                if (this._stashUsed > 0) {  // There're stash datas in buffer\n                    // dispatch the whole stashBuffer, and stash remain data\n                    // then append chunk to stashBuffer (stash)\n                    let buffer = this._stashBuffer.slice(0, this._stashUsed);\n                    let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n                    if (consumed < buffer.byteLength) {\n                        if (consumed > 0) {\n                            let remainArray = new Uint8Array(buffer, consumed);\n                            stashArray.set(remainArray, 0);\n                            this._stashUsed = remainArray.byteLength;\n                            this._stashByteStart += consumed;\n                        }\n                    } else {\n                        this._stashUsed = 0;\n                        this._stashByteStart += consumed;\n                    }\n                    if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n                        this._expandBuffer(this._stashUsed + chunk.byteLength);\n                        stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                    }\n                    stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                    this._stashUsed += chunk.byteLength;\n                } else {  // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n                    // dispatch chunk directly and stash remain data\n                    let consumed = this._dispatchChunks(chunk, byteStart);\n                    if (consumed < chunk.byteLength) {\n                        let remain = chunk.byteLength - consumed;\n                        if (remain > this._bufferSize) {\n                            this._expandBuffer(remain);\n                            stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                        }\n                        stashArray.set(new Uint8Array(chunk, consumed), 0);\n                        this._stashUsed += remain;\n                        this._stashByteStart = byteStart + consumed;\n                    }\n                }\n            }\n        }\n    }\n\n    _flushStashBuffer(dropUnconsumed) {\n        if (this._stashUsed > 0) {\n            let buffer = this._stashBuffer.slice(0, this._stashUsed);\n            let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n            let remain = buffer.byteLength - consumed;\n\n            if (consumed < buffer.byteLength) {\n                if (dropUnconsumed) {\n                    Log.w(this.TAG, `${remain} bytes unconsumed data remain when flush buffer, dropped`);\n                } else {\n                    if (consumed > 0) {\n                        let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                        let remainArray = new Uint8Array(buffer, consumed);\n                        stashArray.set(remainArray, 0);\n                        this._stashUsed = remainArray.byteLength;\n                        this._stashByteStart += consumed;\n                    }\n                    return 0;\n                }\n            }\n            this._stashUsed = 0;\n            this._stashByteStart = 0;\n            return remain;\n        }\n        return 0;\n    }\n\n    _onLoaderComplete(from, to) {\n        // Force-flush stash buffer, and drop unconsumed data\n        this._flushStashBuffer(true);\n\n        if (this._onComplete) {\n            this._onComplete(this._extraData);\n        }\n    }\n\n    _onLoaderError(type, data) {\n        Log.e(this.TAG, `Loader error, code = ${data.code}, msg = ${data.msg}`);\n\n        this._flushStashBuffer(false);\n\n        if (this._isEarlyEofReconnecting) {\n            // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n            this._isEarlyEofReconnecting = false;\n            type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n        }\n\n        switch (type) {\n            case LoaderErrors.EARLY_EOF: {\n                if (!this._config.isLive) {\n                    // Do internal http reconnect if not live stream\n                    if (this._totalLength) {\n                        let nextFrom = this._currentRange.to + 1;\n                        if (nextFrom < this._totalLength) {\n                            Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                            this._isEarlyEofReconnecting = true;\n                            this._internalSeek(nextFrom, false);\n                        }\n                        return;\n                    }\n                    // else: We don't know totalLength, throw UnrecoverableEarlyEof\n                }\n                // live stream: throw UnrecoverableEarlyEof error to upper-layer\n                type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n                break;\n            }\n            case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n            case LoaderErrors.CONNECTING_TIMEOUT:\n            case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n            case LoaderErrors.EXCEPTION:\n                break;\n        }\n\n        if (this._onError) {\n            this._onError(type, data);\n        } else {\n            throw new RuntimeException('IOException: ' + data.msg);\n        }\n    }\n\n}\n\nexport default IOController;"]},"metadata":{},"sourceType":"module"}