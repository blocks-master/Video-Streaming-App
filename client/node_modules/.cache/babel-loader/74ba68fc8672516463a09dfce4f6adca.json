{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js'; // Universal IO Loader, implemented by adding Range header in xhr's request header\n\nclass RangeLoader extends BaseLoader {\n  static isSupported() {\n    try {\n      let xhr = new XMLHttpRequest();\n      xhr.open('GET', 'https://example.com', true);\n      xhr.responseType = 'arraybuffer';\n      return xhr.responseType === 'arraybuffer';\n    } catch (e) {\n      Log.w('RangeLoader', e.message);\n      return false;\n    }\n  }\n\n  constructor(seekHandler, config) {\n    super('xhr-range-loader');\n    this.TAG = 'RangeLoader';\n    this._seekHandler = seekHandler;\n    this._config = config;\n    this._needStash = false;\n    this._chunkSizeKBList = [128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192];\n    this._currentChunkSizeKB = 384;\n    this._currentSpeedNormalized = 0;\n    this._zeroSpeedChunkCount = 0;\n    this._xhr = null;\n    this._speedSampler = new SpeedSampler();\n    this._requestAbort = false;\n    this._waitForTotalLength = false;\n    this._totalLengthReceived = false;\n    this._currentRequestURL = null;\n    this._currentRedirectedURL = null;\n    this._currentRequestRange = null;\n    this._totalLength = null; // size of the entire file\n\n    this._contentLength = null; // Content-Length of entire request range\n\n    this._receivedLength = 0; // total received bytes\n\n    this._lastTimeLoaded = 0; // received bytes of current request sub-range\n  }\n\n  destroy() {\n    if (this.isWorking()) {\n      this.abort();\n    }\n\n    if (this._xhr) {\n      this._xhr.onreadystatechange = null;\n      this._xhr.onprogress = null;\n      this._xhr.onload = null;\n      this._xhr.onerror = null;\n      this._xhr = null;\n    }\n\n    super.destroy();\n  }\n\n  get currentSpeed() {\n    return this._speedSampler.lastSecondKBps;\n  }\n\n  open(dataSource, range) {\n    this._dataSource = dataSource;\n    this._range = range;\n    this._status = LoaderStatus.kConnecting;\n    let useRefTotalLength = false;\n\n    if (this._dataSource.filesize != undefined && this._dataSource.filesize !== 0) {\n      useRefTotalLength = true;\n      this._totalLength = this._dataSource.filesize;\n    }\n\n    if (!this._totalLengthReceived && !useRefTotalLength) {\n      // We need total filesize\n      this._waitForTotalLength = true;\n\n      this._internalOpen(this._dataSource, {\n        from: 0,\n        to: -1\n      });\n    } else {\n      // We have filesize, start loading\n      this._openSubRange();\n    }\n  }\n\n  _openSubRange() {\n    let chunkSize = this._currentChunkSizeKB * 1024;\n    let from = this._range.from + this._receivedLength;\n    let to = from + chunkSize;\n\n    if (this._contentLength != null) {\n      if (to - this._range.from >= this._contentLength) {\n        to = this._range.from + this._contentLength - 1;\n      }\n    }\n\n    this._currentRequestRange = {\n      from,\n      to\n    };\n\n    this._internalOpen(this._dataSource, this._currentRequestRange);\n  }\n\n  _internalOpen(dataSource, range) {\n    this._lastTimeLoaded = 0;\n    let sourceURL = dataSource.url;\n\n    if (this._config.reuseRedirectedURL) {\n      if (this._currentRedirectedURL != undefined) {\n        sourceURL = this._currentRedirectedURL;\n      } else if (dataSource.redirectedURL != undefined) {\n        sourceURL = dataSource.redirectedURL;\n      }\n    }\n\n    let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n    this._currentRequestURL = seekConfig.url;\n    let xhr = this._xhr = new XMLHttpRequest();\n    xhr.open('GET', seekConfig.url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n    xhr.onprogress = this._onProgress.bind(this);\n    xhr.onload = this._onLoad.bind(this);\n    xhr.onerror = this._onXhrError.bind(this);\n\n    if (dataSource.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    if (typeof seekConfig.headers === 'object') {\n      let headers = seekConfig.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    } // add additional headers\n\n\n    if (typeof this._config.headers === 'object') {\n      let headers = this._config.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    }\n\n    xhr.send();\n  }\n\n  abort() {\n    this._requestAbort = true;\n\n    this._internalAbort();\n\n    this._status = LoaderStatus.kComplete;\n  }\n\n  _internalAbort() {\n    if (this._xhr) {\n      this._xhr.onreadystatechange = null;\n      this._xhr.onprogress = null;\n      this._xhr.onload = null;\n      this._xhr.onerror = null;\n\n      this._xhr.abort();\n\n      this._xhr = null;\n    }\n  }\n\n  _onReadyStateChange(e) {\n    let xhr = e.target;\n\n    if (xhr.readyState === 2) {\n      // HEADERS_RECEIVED\n      if (xhr.responseURL != undefined) {\n        // if the browser support this property\n        let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n\n        if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n          this._currentRedirectedURL = redirectedURL;\n\n          if (this._onURLRedirect) {\n            this._onURLRedirect(redirectedURL);\n          }\n        }\n      }\n\n      if (xhr.status >= 200 && xhr.status <= 299) {\n        if (this._waitForTotalLength) {\n          return;\n        }\n\n        this._status = LoaderStatus.kBuffering;\n      } else {\n        this._status = LoaderStatus.kError;\n\n        if (this._onError) {\n          this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n            code: xhr.status,\n            msg: xhr.statusText\n          });\n        } else {\n          throw new RuntimeException('RangeLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n        }\n      }\n    }\n  }\n\n  _onProgress(e) {\n    if (this._status === LoaderStatus.kError) {\n      // Ignore error response\n      return;\n    }\n\n    if (this._contentLength === null) {\n      let openNextRange = false;\n\n      if (this._waitForTotalLength) {\n        this._waitForTotalLength = false;\n        this._totalLengthReceived = true;\n        openNextRange = true;\n        let total = e.total;\n\n        this._internalAbort();\n\n        if (total != null & total !== 0) {\n          this._totalLength = total;\n        }\n      } // calculate currrent request range's contentLength\n\n\n      if (this._range.to === -1) {\n        this._contentLength = this._totalLength - this._range.from;\n      } else {\n        // to !== -1\n        this._contentLength = this._range.to - this._range.from + 1;\n      }\n\n      if (openNextRange) {\n        this._openSubRange();\n\n        return;\n      }\n\n      if (this._onContentLengthKnown) {\n        this._onContentLengthKnown(this._contentLength);\n      }\n    }\n\n    let delta = e.loaded - this._lastTimeLoaded;\n    this._lastTimeLoaded = e.loaded;\n\n    this._speedSampler.addBytes(delta);\n  }\n\n  _normalizeSpeed(input) {\n    let list = this._chunkSizeKBList;\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n\n    if (input < list[0]) {\n      return list[0];\n    }\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n        return list[mid];\n      } else if (list[mid] < input) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n  }\n\n  _onLoad(e) {\n    if (this._status === LoaderStatus.kError) {\n      // Ignore error response\n      return;\n    }\n\n    if (this._waitForTotalLength) {\n      this._waitForTotalLength = false;\n      return;\n    }\n\n    this._lastTimeLoaded = 0;\n    let KBps = this._speedSampler.lastSecondKBps;\n\n    if (KBps === 0) {\n      this._zeroSpeedChunkCount++;\n\n      if (this._zeroSpeedChunkCount >= 3) {\n        // Try get currentKBps after 3 chunks\n        KBps = this._speedSampler.currentKBps;\n      }\n    }\n\n    if (KBps !== 0) {\n      let normalized = this._normalizeSpeed(KBps);\n\n      if (this._currentSpeedNormalized !== normalized) {\n        this._currentSpeedNormalized = normalized;\n        this._currentChunkSizeKB = normalized;\n      }\n    }\n\n    let chunk = e.target.response;\n    let byteStart = this._range.from + this._receivedLength;\n    this._receivedLength += chunk.byteLength;\n    let reportComplete = false;\n\n    if (this._contentLength != null && this._receivedLength < this._contentLength) {\n      // continue load next chunk\n      this._openSubRange();\n    } else {\n      reportComplete = true;\n    } // dispatch received chunk\n\n\n    if (this._onDataArrival) {\n      this._onDataArrival(chunk, byteStart, this._receivedLength);\n    }\n\n    if (reportComplete) {\n      this._status = LoaderStatus.kComplete;\n\n      if (this._onComplete) {\n        this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n      }\n    }\n  }\n\n  _onXhrError(e) {\n    this._status = LoaderStatus.kError;\n    let type = 0;\n    let info = null;\n\n    if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength) {\n      type = LoaderErrors.EARLY_EOF;\n      info = {\n        code: -1,\n        msg: 'RangeLoader meet Early-Eof'\n      };\n    } else {\n      type = LoaderErrors.EXCEPTION;\n      info = {\n        code: -1,\n        msg: e.constructor.name + ' ' + e.type\n      };\n    }\n\n    if (this._onError) {\n      this._onError(type, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n}\n\nexport default RangeLoader;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/io/xhr-range-loader.js"],"names":["Log","SpeedSampler","BaseLoader","LoaderStatus","LoaderErrors","RuntimeException","RangeLoader","isSupported","xhr","XMLHttpRequest","open","responseType","e","w","message","constructor","seekHandler","config","TAG","_seekHandler","_config","_needStash","_chunkSizeKBList","_currentChunkSizeKB","_currentSpeedNormalized","_zeroSpeedChunkCount","_xhr","_speedSampler","_requestAbort","_waitForTotalLength","_totalLengthReceived","_currentRequestURL","_currentRedirectedURL","_currentRequestRange","_totalLength","_contentLength","_receivedLength","_lastTimeLoaded","destroy","isWorking","abort","onreadystatechange","onprogress","onload","onerror","currentSpeed","lastSecondKBps","dataSource","range","_dataSource","_range","_status","kConnecting","useRefTotalLength","filesize","undefined","_internalOpen","from","to","_openSubRange","chunkSize","sourceURL","url","reuseRedirectedURL","redirectedURL","seekConfig","getConfig","_onReadyStateChange","bind","_onProgress","_onLoad","_onXhrError","withCredentials","headers","key","hasOwnProperty","setRequestHeader","send","_internalAbort","kComplete","target","readyState","responseURL","removeURLParameters","_onURLRedirect","status","kBuffering","kError","_onError","HTTP_STATUS_CODE_INVALID","code","msg","statusText","openNextRange","total","_onContentLengthKnown","delta","loaded","addBytes","_normalizeSpeed","input","list","last","length","mid","lbound","ubound","Math","floor","KBps","currentKBps","normalized","chunk","response","byteStart","byteLength","reportComplete","_onDataArrival","_onComplete","type","info","EARLY_EOF","EXCEPTION","name"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport {BaseLoader, LoaderStatus, LoaderErrors} from './loader.js';\nimport {RuntimeException} from '../utils/exception.js';\n\n// Universal IO Loader, implemented by adding Range header in xhr's request header\nclass RangeLoader extends BaseLoader {\n\n    static isSupported() {\n        try {\n            let xhr = new XMLHttpRequest();\n            xhr.open('GET', 'https://example.com', true);\n            xhr.responseType = 'arraybuffer';\n            return (xhr.responseType === 'arraybuffer');\n        } catch (e) {\n            Log.w('RangeLoader', e.message);\n            return false;\n        }\n    }\n\n    constructor(seekHandler, config) {\n        super('xhr-range-loader');\n        this.TAG = 'RangeLoader';\n\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n\n        this._chunkSizeKBList = [\n            128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192\n        ];\n        this._currentChunkSizeKB = 384;\n        this._currentSpeedNormalized = 0;\n        this._zeroSpeedChunkCount = 0;\n\n        this._xhr = null;\n        this._speedSampler = new SpeedSampler();\n\n        this._requestAbort = false;\n        this._waitForTotalLength = false;\n        this._totalLengthReceived = false;\n\n        this._currentRequestURL = null;\n        this._currentRedirectedURL = null;\n        this._currentRequestRange = null;\n        this._totalLength = null;  // size of the entire file\n        this._contentLength = null;  // Content-Length of entire request range\n        this._receivedLength = 0;  // total received bytes\n        this._lastTimeLoaded = 0;  // received bytes of current request sub-range\n    }\n\n    destroy() {\n        if (this.isWorking()) {\n            this.abort();\n        }\n        if (this._xhr) {\n            this._xhr.onreadystatechange = null;\n            this._xhr.onprogress = null;\n            this._xhr.onload = null;\n            this._xhr.onerror = null;\n            this._xhr = null;\n        }\n        super.destroy();\n    }\n\n    get currentSpeed() {\n        return this._speedSampler.lastSecondKBps;\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._status = LoaderStatus.kConnecting;\n\n        let useRefTotalLength = false;\n        if (this._dataSource.filesize != undefined && this._dataSource.filesize !== 0) {\n            useRefTotalLength = true;\n            this._totalLength = this._dataSource.filesize;\n        }\n\n        if (!this._totalLengthReceived && !useRefTotalLength) {\n            // We need total filesize\n            this._waitForTotalLength = true;\n            this._internalOpen(this._dataSource, {from: 0, to: -1});\n        } else {\n            // We have filesize, start loading\n            this._openSubRange();\n        }\n    }\n\n    _openSubRange() {\n        let chunkSize = this._currentChunkSizeKB * 1024;\n\n        let from = this._range.from + this._receivedLength;\n        let to = from + chunkSize;\n\n        if (this._contentLength != null) {\n            if (to - this._range.from >= this._contentLength) {\n                to = this._range.from + this._contentLength - 1;\n            }\n        }\n\n        this._currentRequestRange = {from, to};\n        this._internalOpen(this._dataSource, this._currentRequestRange);\n    }\n\n    _internalOpen(dataSource, range) {\n        this._lastTimeLoaded = 0;\n\n        let sourceURL = dataSource.url;\n        if (this._config.reuseRedirectedURL) {\n            if (this._currentRedirectedURL != undefined) {\n                sourceURL = this._currentRedirectedURL;\n            } else if (dataSource.redirectedURL != undefined) {\n                sourceURL = dataSource.redirectedURL;\n            }\n        }\n\n        let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n        this._currentRequestURL = seekConfig.url;\n\n        let xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', seekConfig.url, true);\n        xhr.responseType = 'arraybuffer';\n        xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        xhr.onprogress = this._onProgress.bind(this);\n        xhr.onload = this._onLoad.bind(this);\n        xhr.onerror = this._onXhrError.bind(this);\n\n        if (dataSource.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (typeof seekConfig.headers === 'object') {\n            let headers = seekConfig.headers;\n\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        // add additional headers\n        if (typeof this._config.headers === 'object') {\n            let headers = this._config.headers;\n\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        xhr.send();\n    }\n\n    abort() {\n        this._requestAbort = true;\n        this._internalAbort();\n        this._status = LoaderStatus.kComplete;\n    }\n\n    _internalAbort() {\n        if (this._xhr) {\n            this._xhr.onreadystatechange = null;\n            this._xhr.onprogress = null;\n            this._xhr.onload = null;\n            this._xhr.onerror = null;\n            this._xhr.abort();\n            this._xhr = null;\n        }\n    }\n\n    _onReadyStateChange(e) {\n        let xhr = e.target;\n\n        if (xhr.readyState === 2) {  // HEADERS_RECEIVED\n            if (xhr.responseURL != undefined) {  // if the browser support this property\n                let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n                if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n                    this._currentRedirectedURL = redirectedURL;\n                    if (this._onURLRedirect) {\n                        this._onURLRedirect(redirectedURL);\n                    }\n                }\n            }\n\n            if ((xhr.status >= 200 && xhr.status <= 299)) {\n                if (this._waitForTotalLength) {\n                    return;\n                }\n                this._status = LoaderStatus.kBuffering;\n            } else {\n                this._status = LoaderStatus.kError;\n                if (this._onError) {\n                    this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {code: xhr.status, msg: xhr.statusText});\n                } else {\n                    throw new RuntimeException('RangeLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n                }\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (this._status === LoaderStatus.kError) {\n            // Ignore error response\n            return;\n        }\n\n        if (this._contentLength === null) {\n            let openNextRange = false;\n\n            if (this._waitForTotalLength) {\n                this._waitForTotalLength = false;\n                this._totalLengthReceived = true;\n                openNextRange = true;\n\n                let total = e.total;\n                this._internalAbort();\n                if (total != null & total !== 0) {\n                    this._totalLength = total;\n                }\n            }\n\n            // calculate currrent request range's contentLength\n            if (this._range.to === -1) {\n                this._contentLength = this._totalLength - this._range.from;\n            } else {  // to !== -1\n                this._contentLength = this._range.to - this._range.from + 1;\n            }\n\n            if (openNextRange) {\n                this._openSubRange();\n                return;\n            }\n            if (this._onContentLengthKnown) {\n                this._onContentLengthKnown(this._contentLength);\n            }\n        }\n\n        let delta = e.loaded - this._lastTimeLoaded;\n        this._lastTimeLoaded = e.loaded;\n        this._speedSampler.addBytes(delta);\n    }\n\n    _normalizeSpeed(input) {\n        let list = this._chunkSizeKBList;\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (input < list[0]) {\n            return list[0];\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (input >= list[mid] && input < list[mid + 1])) {\n                return list[mid];\n            } else if (list[mid] < input) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n    }\n\n    _onLoad(e) {\n        if (this._status === LoaderStatus.kError) {\n            // Ignore error response\n            return;\n        }\n\n        if (this._waitForTotalLength) {\n            this._waitForTotalLength = false;\n            return;\n        }\n\n        this._lastTimeLoaded = 0;\n        let KBps = this._speedSampler.lastSecondKBps;\n        if (KBps === 0) {\n            this._zeroSpeedChunkCount++;\n            if (this._zeroSpeedChunkCount >= 3) {\n                // Try get currentKBps after 3 chunks\n                KBps = this._speedSampler.currentKBps;\n            }\n        }\n\n        if (KBps !== 0) {\n            let normalized = this._normalizeSpeed(KBps);\n            if (this._currentSpeedNormalized !== normalized) {\n                this._currentSpeedNormalized = normalized;\n                this._currentChunkSizeKB = normalized;\n            }\n        }\n\n        let chunk = e.target.response;\n        let byteStart = this._range.from + this._receivedLength;\n        this._receivedLength += chunk.byteLength;\n\n        let reportComplete = false;\n\n        if (this._contentLength != null && this._receivedLength < this._contentLength) {\n            // continue load next chunk\n            this._openSubRange();\n        } else {\n            reportComplete = true;\n        }\n\n        // dispatch received chunk\n        if (this._onDataArrival) {\n            this._onDataArrival(chunk, byteStart, this._receivedLength);\n        }\n\n        if (reportComplete) {\n            this._status = LoaderStatus.kComplete;\n            if (this._onComplete) {\n                this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n            }\n        }\n    }\n\n    _onXhrError(e) {\n        this._status = LoaderStatus.kError;\n        let type = 0;\n        let info = null;\n\n        if (this._contentLength && this._receivedLength > 0\n                                && this._receivedLength < this._contentLength) {\n            type = LoaderErrors.EARLY_EOF;\n            info = {code: -1, msg: 'RangeLoader meet Early-Eof'};\n        } else {\n            type = LoaderErrors.EXCEPTION;\n            info = {code: -1, msg: e.constructor.name + ' ' + e.type};\n        }\n\n        if (this._onError) {\n            this._onError(type, info);\n        } else {\n            throw new RuntimeException(info.msg);\n        }\n    }\n\n}\n\nexport default RangeLoader;"]},"metadata":{},"sourceType":"module"}