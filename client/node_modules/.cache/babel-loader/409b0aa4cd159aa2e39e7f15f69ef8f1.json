{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Utility class to calculate realtime network I/O speed\nclass SpeedSampler {\n  constructor() {\n    // milliseconds\n    this._firstCheckpoint = 0;\n    this._lastCheckpoint = 0;\n    this._intervalBytes = 0;\n    this._totalBytes = 0;\n    this._lastSecondBytes = 0; // compatibility detection\n\n    if (self.performance && self.performance.now) {\n      this._now = self.performance.now.bind(self.performance);\n    } else {\n      this._now = Date.now;\n    }\n  }\n\n  reset() {\n    this._firstCheckpoint = this._lastCheckpoint = 0;\n    this._totalBytes = this._intervalBytes = 0;\n    this._lastSecondBytes = 0;\n  }\n\n  addBytes(bytes) {\n    if (this._firstCheckpoint === 0) {\n      this._firstCheckpoint = this._now();\n      this._lastCheckpoint = this._firstCheckpoint;\n      this._intervalBytes += bytes;\n      this._totalBytes += bytes;\n    } else if (this._now() - this._lastCheckpoint < 1000) {\n      this._intervalBytes += bytes;\n      this._totalBytes += bytes;\n    } else {\n      // duration >= 1000\n      this._lastSecondBytes = this._intervalBytes;\n      this._intervalBytes = bytes;\n      this._totalBytes += bytes;\n      this._lastCheckpoint = this._now();\n    }\n  }\n\n  get currentKBps() {\n    this.addBytes(0);\n    let durationSeconds = (this._now() - this._lastCheckpoint) / 1000;\n    if (durationSeconds == 0) durationSeconds = 1;\n    return this._intervalBytes / durationSeconds / 1024;\n  }\n\n  get lastSecondKBps() {\n    this.addBytes(0);\n\n    if (this._lastSecondBytes !== 0) {\n      return this._lastSecondBytes / 1024;\n    } else {\n      // lastSecondBytes === 0\n      if (this._now() - this._lastCheckpoint >= 500) {\n        // if time interval since last checkpoint has exceeded 500ms\n        // the speed is nearly accurate\n        return this.currentKBps;\n      } else {\n        // We don't know\n        return 0;\n      }\n    }\n  }\n\n  get averageKBps() {\n    let durationSeconds = (this._now() - this._firstCheckpoint) / 1000;\n    return this._totalBytes / durationSeconds / 1024;\n  }\n\n}\n\nexport default SpeedSampler;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/io/speed-sampler.js"],"names":["SpeedSampler","constructor","_firstCheckpoint","_lastCheckpoint","_intervalBytes","_totalBytes","_lastSecondBytes","self","performance","now","_now","bind","Date","reset","addBytes","bytes","currentKBps","durationSeconds","lastSecondKBps","averageKBps"],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAkBA;AACA,MAAMA,YAAN,CAAmB;AAEfC,EAAAA,WAAW,GAAG;AACV;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKC,gBAAL,GAAwB,CAAxB,CANU,CAQV;;AACA,QAAIC,IAAI,CAACC,WAAL,IAAoBD,IAAI,CAACC,WAAL,CAAiBC,GAAzC,EAA8C;AAC1C,WAAKC,IAAL,GAAYH,IAAI,CAACC,WAAL,CAAiBC,GAAjB,CAAqBE,IAArB,CAA0BJ,IAAI,CAACC,WAA/B,CAAZ;AACH,KAFD,MAEO;AACH,WAAKE,IAAL,GAAYE,IAAI,CAACH,GAAjB;AACH;AACJ;;AAEDI,EAAAA,KAAK,GAAG;AACJ,SAAKX,gBAAL,GAAwB,KAAKC,eAAL,GAAuB,CAA/C;AACA,SAAKE,WAAL,GAAmB,KAAKD,cAAL,GAAsB,CAAzC;AACA,SAAKE,gBAAL,GAAwB,CAAxB;AACH;;AAEDQ,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACZ,QAAI,KAAKb,gBAAL,KAA0B,CAA9B,EAAiC;AAC7B,WAAKA,gBAAL,GAAwB,KAAKQ,IAAL,EAAxB;AACA,WAAKP,eAAL,GAAuB,KAAKD,gBAA5B;AACA,WAAKE,cAAL,IAAuBW,KAAvB;AACA,WAAKV,WAAL,IAAoBU,KAApB;AACH,KALD,MAKO,IAAI,KAAKL,IAAL,KAAc,KAAKP,eAAnB,GAAqC,IAAzC,EAA+C;AAClD,WAAKC,cAAL,IAAuBW,KAAvB;AACA,WAAKV,WAAL,IAAoBU,KAApB;AACH,KAHM,MAGA;AAAG;AACN,WAAKT,gBAAL,GAAwB,KAAKF,cAA7B;AACA,WAAKA,cAAL,GAAsBW,KAAtB;AACA,WAAKV,WAAL,IAAoBU,KAApB;AACA,WAAKZ,eAAL,GAAuB,KAAKO,IAAL,EAAvB;AACH;AACJ;;AAED,MAAIM,WAAJ,GAAkB;AACd,SAAKF,QAAL,CAAc,CAAd;AAEA,QAAIG,eAAe,GAAG,CAAC,KAAKP,IAAL,KAAc,KAAKP,eAApB,IAAuC,IAA7D;AACA,QAAIc,eAAe,IAAI,CAAvB,EAA0BA,eAAe,GAAG,CAAlB;AAC1B,WAAQ,KAAKb,cAAL,GAAsBa,eAAvB,GAA0C,IAAjD;AACH;;AAED,MAAIC,cAAJ,GAAqB;AACjB,SAAKJ,QAAL,CAAc,CAAd;;AAEA,QAAI,KAAKR,gBAAL,KAA0B,CAA9B,EAAiC;AAC7B,aAAO,KAAKA,gBAAL,GAAwB,IAA/B;AACH,KAFD,MAEO;AAAG;AACN,UAAI,KAAKI,IAAL,KAAc,KAAKP,eAAnB,IAAsC,GAA1C,EAA+C;AAC3C;AACA;AACA,eAAO,KAAKa,WAAZ;AACH,OAJD,MAIO;AACH;AACA,eAAO,CAAP;AACH;AACJ;AACJ;;AAED,MAAIG,WAAJ,GAAkB;AACd,QAAIF,eAAe,GAAG,CAAC,KAAKP,IAAL,KAAc,KAAKR,gBAApB,IAAwC,IAA9D;AACA,WAAQ,KAAKG,WAAL,GAAmBY,eAApB,GAAuC,IAA9C;AACH;;AArEc;;AAyEnB,eAAejB,YAAf","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Utility class to calculate realtime network I/O speed\nclass SpeedSampler {\n\n    constructor() {\n        // milliseconds\n        this._firstCheckpoint = 0;\n        this._lastCheckpoint = 0;\n        this._intervalBytes = 0;\n        this._totalBytes = 0;\n        this._lastSecondBytes = 0;\n\n        // compatibility detection\n        if (self.performance && self.performance.now) {\n            this._now = self.performance.now.bind(self.performance);\n        } else {\n            this._now = Date.now;\n        }\n    }\n\n    reset() {\n        this._firstCheckpoint = this._lastCheckpoint = 0;\n        this._totalBytes = this._intervalBytes = 0;\n        this._lastSecondBytes = 0;\n    }\n\n    addBytes(bytes) {\n        if (this._firstCheckpoint === 0) {\n            this._firstCheckpoint = this._now();\n            this._lastCheckpoint = this._firstCheckpoint;\n            this._intervalBytes += bytes;\n            this._totalBytes += bytes;\n        } else if (this._now() - this._lastCheckpoint < 1000) {\n            this._intervalBytes += bytes;\n            this._totalBytes += bytes;\n        } else {  // duration >= 1000\n            this._lastSecondBytes = this._intervalBytes;\n            this._intervalBytes = bytes;\n            this._totalBytes += bytes;\n            this._lastCheckpoint = this._now();\n        }\n    }\n\n    get currentKBps() {\n        this.addBytes(0);\n\n        let durationSeconds = (this._now() - this._lastCheckpoint) / 1000;\n        if (durationSeconds == 0) durationSeconds = 1;\n        return (this._intervalBytes / durationSeconds) / 1024;\n    }\n\n    get lastSecondKBps() {\n        this.addBytes(0);\n\n        if (this._lastSecondBytes !== 0) {\n            return this._lastSecondBytes / 1024;\n        } else {  // lastSecondBytes === 0\n            if (this._now() - this._lastCheckpoint >= 500) {\n                // if time interval since last checkpoint has exceeded 500ms\n                // the speed is nearly accurate\n                return this.currentKBps;\n            } else {\n                // We don't know\n                return 0;\n            }\n        }\n    }\n\n    get averageKBps() {\n        let durationSeconds = (this._now() - this._firstCheckpoint) / 1000;\n        return (this._totalBytes / durationSeconds) / 1024;\n    }\n\n}\n\nexport default SpeedSampler;"]},"metadata":{},"sourceType":"module"}