{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MSEEvents from './mse-events.js';\nimport { SampleInfo, IDRSampleList } from './media-segment-info.js';\nimport { IllegalStateException } from '../utils/exception.js'; // Media Source Extensions controller\n\nclass MSEController {\n  constructor(config) {\n    this.TAG = 'MSEController';\n    this._config = config;\n    this._emitter = new EventEmitter();\n\n    if (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n      // For live stream, do auto cleanup by default\n      this._config.autoCleanupSourceBuffer = true;\n    }\n\n    this.e = {\n      onSourceOpen: this._onSourceOpen.bind(this),\n      onSourceEnded: this._onSourceEnded.bind(this),\n      onSourceClose: this._onSourceClose.bind(this),\n      onSourceBufferError: this._onSourceBufferError.bind(this),\n      onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n    };\n    this._mediaSource = null;\n    this._mediaSourceObjectURL = null;\n    this._mediaElement = null;\n    this._isBufferFull = false;\n    this._hasPendingEos = false;\n    this._requireSetMediaDuration = false;\n    this._pendingMediaDuration = 0;\n    this._pendingSourceBufferInit = [];\n    this._mimeTypes = {\n      video: null,\n      audio: null\n    };\n    this._sourceBuffers = {\n      video: null,\n      audio: null\n    };\n    this._lastInitSegments = {\n      video: null,\n      audio: null\n    };\n    this._pendingSegments = {\n      video: [],\n      audio: []\n    };\n    this._pendingRemoveRanges = {\n      video: [],\n      audio: []\n    };\n    this._idrList = new IDRSampleList();\n  }\n\n  destroy() {\n    if (this._mediaElement || this._mediaSource) {\n      this.detachMediaElement();\n    }\n\n    this.e = null;\n\n    this._emitter.removeAllListeners();\n\n    this._emitter = null;\n  }\n\n  on(event, listener) {\n    this._emitter.addListener(event, listener);\n  }\n\n  off(event, listener) {\n    this._emitter.removeListener(event, listener);\n  }\n\n  attachMediaElement(mediaElement) {\n    if (this._mediaSource) {\n      throw new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n    }\n\n    let ms = this._mediaSource = new window.MediaSource();\n    ms.addEventListener('sourceopen', this.e.onSourceOpen);\n    ms.addEventListener('sourceended', this.e.onSourceEnded);\n    ms.addEventListener('sourceclose', this.e.onSourceClose);\n    this._mediaElement = mediaElement;\n    this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n    mediaElement.src = this._mediaSourceObjectURL;\n  }\n\n  detachMediaElement() {\n    if (this._mediaSource) {\n      let ms = this._mediaSource;\n\n      for (let type in this._sourceBuffers) {\n        // pending segments should be discard\n        let ps = this._pendingSegments[type];\n        ps.splice(0, ps.length);\n        this._pendingSegments[type] = null;\n        this._pendingRemoveRanges[type] = null;\n        this._lastInitSegments[type] = null; // remove all sourcebuffers\n\n        let sb = this._sourceBuffers[type];\n\n        if (sb) {\n          if (ms.readyState !== 'closed') {\n            // ms edge can throw an error: Unexpected call to method or property access\n            try {\n              ms.removeSourceBuffer(sb);\n            } catch (error) {\n              Log.e(this.TAG, error.message);\n            }\n\n            sb.removeEventListener('error', this.e.onSourceBufferError);\n            sb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n          }\n\n          this._mimeTypes[type] = null;\n          this._sourceBuffers[type] = null;\n        }\n      }\n\n      if (ms.readyState === 'open') {\n        try {\n          ms.endOfStream();\n        } catch (error) {\n          Log.e(this.TAG, error.message);\n        }\n      }\n\n      ms.removeEventListener('sourceopen', this.e.onSourceOpen);\n      ms.removeEventListener('sourceended', this.e.onSourceEnded);\n      ms.removeEventListener('sourceclose', this.e.onSourceClose);\n      this._pendingSourceBufferInit = [];\n      this._isBufferFull = false;\n\n      this._idrList.clear();\n\n      this._mediaSource = null;\n    }\n\n    if (this._mediaElement) {\n      this._mediaElement.src = '';\n\n      this._mediaElement.removeAttribute('src');\n\n      this._mediaElement = null;\n    }\n\n    if (this._mediaSourceObjectURL) {\n      window.URL.revokeObjectURL(this._mediaSourceObjectURL);\n      this._mediaSourceObjectURL = null;\n    }\n  }\n\n  appendInitSegment(initSegment, deferred) {\n    if (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n      // sourcebuffer creation requires mediaSource.readyState === 'open'\n      // so we defer the sourcebuffer creation, until sourceopen event triggered\n      this._pendingSourceBufferInit.push(initSegment); // make sure that this InitSegment is in the front of pending segments queue\n\n\n      this._pendingSegments[initSegment.type].push(initSegment);\n\n      return;\n    }\n\n    let is = initSegment;\n    let mimeType = `${is.container}`;\n\n    if (is.codec && is.codec.length > 0) {\n      mimeType += `;codecs=${is.codec}`;\n    }\n\n    let firstInitSegment = false;\n    Log.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n    this._lastInitSegments[is.type] = is;\n\n    if (mimeType !== this._mimeTypes[is.type]) {\n      if (!this._mimeTypes[is.type]) {\n        // empty, first chance create sourcebuffer\n        firstInitSegment = true;\n\n        try {\n          let sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n\n          sb.addEventListener('error', this.e.onSourceBufferError);\n          sb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n        } catch (error) {\n          Log.e(this.TAG, error.message);\n\n          this._emitter.emit(MSEEvents.ERROR, {\n            code: error.code,\n            msg: error.message\n          });\n\n          return;\n        }\n      } else {\n        Log.v(this.TAG, `Notice: ${is.type} mimeType changed, origin: ${this._mimeTypes[is.type]}, target: ${mimeType}`);\n      }\n\n      this._mimeTypes[is.type] = mimeType;\n    }\n\n    if (!deferred) {\n      // deferred means this InitSegment has been pushed to pendingSegments queue\n      this._pendingSegments[is.type].push(is);\n    }\n\n    if (!firstInitSegment) {\n      // append immediately only if init segment in subsequence\n      if (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n        this._doAppendSegments();\n      }\n    }\n\n    if (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n      // 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n      // Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n      this._requireSetMediaDuration = true;\n      this._pendingMediaDuration = is.mediaDuration / 1000; // in seconds\n\n      this._updateMediaSourceDuration();\n    }\n  }\n\n  appendMediaSegment(mediaSegment) {\n    let ms = mediaSegment;\n\n    this._pendingSegments[ms.type].push(ms);\n\n    if (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n      this._doCleanupSourceBuffer();\n    }\n\n    let sb = this._sourceBuffers[ms.type];\n\n    if (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n      this._doAppendSegments();\n    }\n  }\n\n  seek(seconds) {\n    // remove all appended buffers\n    for (let type in this._sourceBuffers) {\n      if (!this._sourceBuffers[type]) {\n        continue;\n      } // abort current buffer append algorithm\n\n\n      let sb = this._sourceBuffers[type];\n\n      if (this._mediaSource.readyState === 'open') {\n        try {\n          // If range removal algorithm is running, InvalidStateError will be throwed\n          // Ignore it.\n          sb.abort();\n        } catch (error) {\n          Log.e(this.TAG, error.message);\n        }\n      } // IDRList should be clear\n\n\n      this._idrList.clear(); // pending segments should be discard\n\n\n      let ps = this._pendingSegments[type];\n      ps.splice(0, ps.length);\n\n      if (this._mediaSource.readyState === 'closed') {\n        // Parent MediaSource object has been detached from HTMLMediaElement\n        continue;\n      } // record ranges to be remove from SourceBuffer\n\n\n      for (let i = 0; i < sb.buffered.length; i++) {\n        let start = sb.buffered.start(i);\n        let end = sb.buffered.end(i);\n\n        this._pendingRemoveRanges[type].push({\n          start,\n          end\n        });\n      } // if sb is not updating, let's remove ranges now!\n\n\n      if (!sb.updating) {\n        this._doRemoveRanges();\n      } // Safari 10 may get InvalidStateError in the later appendBuffer() after SourceBuffer.remove() call\n      // Internal parser's state may be invalid at this time. Re-append last InitSegment to workaround.\n      // Related issue: https://bugs.webkit.org/show_bug.cgi?id=159230\n\n\n      if (Browser.safari) {\n        let lastInitSegment = this._lastInitSegments[type];\n\n        if (lastInitSegment) {\n          this._pendingSegments[type].push(lastInitSegment);\n\n          if (!sb.updating) {\n            this._doAppendSegments();\n          }\n        }\n      }\n    }\n  }\n\n  endOfStream() {\n    let ms = this._mediaSource;\n    let sb = this._sourceBuffers;\n\n    if (!ms || ms.readyState !== 'open') {\n      if (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n        // If MediaSource hasn't turned into open state, and there're pending segments\n        // Mark pending endOfStream, defer call until all pending segments appended complete\n        this._hasPendingEos = true;\n      }\n\n      return;\n    }\n\n    if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n      // If any sourcebuffer is updating, defer endOfStream operation\n      // See _onSourceBufferUpdateEnd()\n      this._hasPendingEos = true;\n    } else {\n      this._hasPendingEos = false; // Notify media data loading complete\n      // This is helpful for correcting total duration to match last media segment\n      // Otherwise MediaElement's ended event may not be triggered\n\n      ms.endOfStream();\n    }\n  }\n\n  getNearestKeyframe(dts) {\n    return this._idrList.getLastSyncPointBeforeDts(dts);\n  }\n\n  _needCleanupSourceBuffer() {\n    if (!this._config.autoCleanupSourceBuffer) {\n      return false;\n    }\n\n    let currentTime = this._mediaElement.currentTime;\n\n    for (let type in this._sourceBuffers) {\n      let sb = this._sourceBuffers[type];\n\n      if (sb) {\n        let buffered = sb.buffered;\n\n        if (buffered.length >= 1) {\n          if (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  _doCleanupSourceBuffer() {\n    let currentTime = this._mediaElement.currentTime;\n\n    for (let type in this._sourceBuffers) {\n      let sb = this._sourceBuffers[type];\n\n      if (sb) {\n        let buffered = sb.buffered;\n        let doRemove = false;\n\n        for (let i = 0; i < buffered.length; i++) {\n          let start = buffered.start(i);\n          let end = buffered.end(i);\n\n          if (start <= currentTime && currentTime < end + 3) {\n            // padding 3 seconds\n            if (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n              doRemove = true;\n              let removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n\n              this._pendingRemoveRanges[type].push({\n                start: start,\n                end: removeEnd\n              });\n            }\n          } else if (end < currentTime) {\n            doRemove = true;\n\n            this._pendingRemoveRanges[type].push({\n              start: start,\n              end: end\n            });\n          }\n        }\n\n        if (doRemove && !sb.updating) {\n          this._doRemoveRanges();\n        }\n      }\n    }\n  }\n\n  _updateMediaSourceDuration() {\n    let sb = this._sourceBuffers;\n\n    if (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n      return;\n    }\n\n    if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n      return;\n    }\n\n    let current = this._mediaSource.duration;\n    let target = this._pendingMediaDuration;\n\n    if (target > 0 && (isNaN(current) || target > current)) {\n      Log.v(this.TAG, `Update MediaSource duration from ${current} to ${target}`);\n      this._mediaSource.duration = target;\n    }\n\n    this._requireSetMediaDuration = false;\n    this._pendingMediaDuration = 0;\n  }\n\n  _doRemoveRanges() {\n    for (let type in this._pendingRemoveRanges) {\n      if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n        continue;\n      }\n\n      let sb = this._sourceBuffers[type];\n      let ranges = this._pendingRemoveRanges[type];\n\n      while (ranges.length && !sb.updating) {\n        let range = ranges.shift();\n        sb.remove(range.start, range.end);\n      }\n    }\n  }\n\n  _doAppendSegments() {\n    let pendingSegments = this._pendingSegments;\n\n    for (let type in pendingSegments) {\n      if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n        continue;\n      }\n\n      if (pendingSegments[type].length > 0) {\n        let segment = pendingSegments[type].shift();\n\n        if (segment.timestampOffset) {\n          // For MPEG audio stream in MSE, if unbuffered-seeking occurred\n          // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n          let currentOffset = this._sourceBuffers[type].timestampOffset;\n          let targetOffset = segment.timestampOffset / 1000; // in seconds\n\n          let delta = Math.abs(currentOffset - targetOffset);\n\n          if (delta > 0.1) {\n            // If time delta > 100ms\n            Log.v(this.TAG, `Update MPEG audio timestampOffset from ${currentOffset} to ${targetOffset}`);\n            this._sourceBuffers[type].timestampOffset = targetOffset;\n          }\n\n          delete segment.timestampOffset;\n        }\n\n        if (!segment.data || segment.data.byteLength === 0) {\n          // Ignore empty buffer\n          continue;\n        }\n\n        try {\n          this._sourceBuffers[type].appendBuffer(segment.data);\n\n          this._isBufferFull = false;\n\n          if (type === 'video' && segment.hasOwnProperty('info')) {\n            this._idrList.appendArray(segment.info.syncPoints);\n          }\n        } catch (error) {\n          this._pendingSegments[type].unshift(segment);\n\n          if (error.code === 22) {\n            // QuotaExceededError\n\n            /* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n             * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n             * SourceBuffer eviction policy may be changed in future version of FireFox.\n             *\n             * Related issues:\n             * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n             * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n             */\n            // report buffer full, abort network IO\n            if (!this._isBufferFull) {\n              this._emitter.emit(MSEEvents.BUFFER_FULL);\n            }\n\n            this._isBufferFull = true;\n          } else {\n            Log.e(this.TAG, error.message);\n\n            this._emitter.emit(MSEEvents.ERROR, {\n              code: error.code,\n              msg: error.message\n            });\n          }\n        }\n      }\n    }\n  }\n\n  _onSourceOpen() {\n    Log.v(this.TAG, 'MediaSource onSourceOpen');\n\n    this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen); // deferred sourcebuffer creation / initialization\n\n\n    if (this._pendingSourceBufferInit.length > 0) {\n      let pendings = this._pendingSourceBufferInit;\n\n      while (pendings.length) {\n        let segment = pendings.shift();\n        this.appendInitSegment(segment, true);\n      }\n    } // there may be some pending media segments, append them\n\n\n    if (this._hasPendingSegments()) {\n      this._doAppendSegments();\n    }\n\n    this._emitter.emit(MSEEvents.SOURCE_OPEN);\n  }\n\n  _onSourceEnded() {\n    // fired on endOfStream\n    Log.v(this.TAG, 'MediaSource onSourceEnded');\n  }\n\n  _onSourceClose() {\n    // fired on detaching from media element\n    Log.v(this.TAG, 'MediaSource onSourceClose');\n\n    if (this._mediaSource && this.e != null) {\n      this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\n      this._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n\n      this._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n    }\n  }\n\n  _hasPendingSegments() {\n    let ps = this._pendingSegments;\n    return ps.video.length > 0 || ps.audio.length > 0;\n  }\n\n  _hasPendingRemoveRanges() {\n    let prr = this._pendingRemoveRanges;\n    return prr.video.length > 0 || prr.audio.length > 0;\n  }\n\n  _onSourceBufferUpdateEnd() {\n    if (this._requireSetMediaDuration) {\n      this._updateMediaSourceDuration();\n    } else if (this._hasPendingRemoveRanges()) {\n      this._doRemoveRanges();\n    } else if (this._hasPendingSegments()) {\n      this._doAppendSegments();\n    } else if (this._hasPendingEos) {\n      this.endOfStream();\n    }\n\n    this._emitter.emit(MSEEvents.UPDATE_END);\n  }\n\n  _onSourceBufferError(e) {\n    Log.e(this.TAG, `SourceBuffer Error: ${e}`); // this error might not always be fatal, just ignore it\n  }\n\n}\n\nexport default MSEController;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/core/mse-controller.js"],"names":["EventEmitter","Log","Browser","MSEEvents","SampleInfo","IDRSampleList","IllegalStateException","MSEController","constructor","config","TAG","_config","_emitter","isLive","autoCleanupSourceBuffer","undefined","e","onSourceOpen","_onSourceOpen","bind","onSourceEnded","_onSourceEnded","onSourceClose","_onSourceClose","onSourceBufferError","_onSourceBufferError","onSourceBufferUpdateEnd","_onSourceBufferUpdateEnd","_mediaSource","_mediaSourceObjectURL","_mediaElement","_isBufferFull","_hasPendingEos","_requireSetMediaDuration","_pendingMediaDuration","_pendingSourceBufferInit","_mimeTypes","video","audio","_sourceBuffers","_lastInitSegments","_pendingSegments","_pendingRemoveRanges","_idrList","destroy","detachMediaElement","removeAllListeners","on","event","listener","addListener","off","removeListener","attachMediaElement","mediaElement","ms","window","MediaSource","addEventListener","URL","createObjectURL","src","type","ps","splice","length","sb","readyState","removeSourceBuffer","error","message","removeEventListener","endOfStream","clear","removeAttribute","revokeObjectURL","appendInitSegment","initSegment","deferred","push","is","mimeType","container","codec","firstInitSegment","v","addSourceBuffer","emit","ERROR","code","msg","updating","_doAppendSegments","safari","mediaDuration","_updateMediaSourceDuration","appendMediaSegment","mediaSegment","_needCleanupSourceBuffer","_doCleanupSourceBuffer","_hasPendingRemoveRanges","seek","seconds","abort","i","buffered","start","end","_doRemoveRanges","lastInitSegment","_hasPendingSegments","getNearestKeyframe","dts","getLastSyncPointBeforeDts","currentTime","autoCleanupMaxBackwardDuration","doRemove","removeEnd","autoCleanupMinBackwardDuration","current","duration","target","isNaN","ranges","range","shift","remove","pendingSegments","segment","timestampOffset","currentOffset","targetOffset","delta","Math","abs","data","byteLength","appendBuffer","hasOwnProperty","appendArray","info","syncPoints","unshift","BUFFER_FULL","pendings","SOURCE_OPEN","prr","UPDATE_END"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MSEEvents from './mse-events.js';\nimport {SampleInfo, IDRSampleList} from './media-segment-info.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\n// Media Source Extensions controller\nclass MSEController {\n\n    constructor(config) {\n        this.TAG = 'MSEController';\n\n        this._config = config;\n        this._emitter = new EventEmitter();\n\n        if (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n            // For live stream, do auto cleanup by default\n            this._config.autoCleanupSourceBuffer = true;\n        }\n\n        this.e = {\n            onSourceOpen: this._onSourceOpen.bind(this),\n            onSourceEnded: this._onSourceEnded.bind(this),\n            onSourceClose: this._onSourceClose.bind(this),\n            onSourceBufferError: this._onSourceBufferError.bind(this),\n            onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n        };\n\n        this._mediaSource = null;\n        this._mediaSourceObjectURL = null;\n        this._mediaElement = null;\n\n        this._isBufferFull = false;\n        this._hasPendingEos = false;\n\n        this._requireSetMediaDuration = false;\n        this._pendingMediaDuration = 0;\n\n        this._pendingSourceBufferInit = [];\n        this._mimeTypes = {\n            video: null,\n            audio: null\n        };\n        this._sourceBuffers = {\n            video: null,\n            audio: null\n        };\n        this._lastInitSegments = {\n            video: null,\n            audio: null\n        };\n        this._pendingSegments = {\n            video: [],\n            audio: []\n        };\n        this._pendingRemoveRanges = {\n            video: [],\n            audio: []\n        };\n        this._idrList = new IDRSampleList();\n    }\n\n    destroy() {\n        if (this._mediaElement || this._mediaSource) {\n            this.detachMediaElement();\n        }\n        this.e = null;\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n    }\n\n    on(event, listener) {\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n\n    attachMediaElement(mediaElement) {\n        if (this._mediaSource) {\n            throw new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n        }\n        let ms = this._mediaSource = new window.MediaSource();\n        ms.addEventListener('sourceopen', this.e.onSourceOpen);\n        ms.addEventListener('sourceended', this.e.onSourceEnded);\n        ms.addEventListener('sourceclose', this.e.onSourceClose);\n\n        this._mediaElement = mediaElement;\n        this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n        mediaElement.src = this._mediaSourceObjectURL;\n    }\n\n    detachMediaElement() {\n        if (this._mediaSource) {\n            let ms = this._mediaSource;\n            for (let type in this._sourceBuffers) {\n                // pending segments should be discard\n                let ps = this._pendingSegments[type];\n                ps.splice(0, ps.length);\n                this._pendingSegments[type] = null;\n                this._pendingRemoveRanges[type] = null;\n                this._lastInitSegments[type] = null;\n\n                // remove all sourcebuffers\n                let sb = this._sourceBuffers[type];\n                if (sb) {\n                    if (ms.readyState !== 'closed') {\n                        // ms edge can throw an error: Unexpected call to method or property access\n                        try {\n                            ms.removeSourceBuffer(sb);\n                        } catch (error) {\n                            Log.e(this.TAG, error.message);\n                        }\n                        sb.removeEventListener('error', this.e.onSourceBufferError);\n                        sb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n                    }\n                    this._mimeTypes[type] = null;\n                    this._sourceBuffers[type] = null;\n                }\n            }\n            if (ms.readyState === 'open') {\n                try {\n                    ms.endOfStream();\n                } catch (error) {\n                    Log.e(this.TAG, error.message);\n                }\n            }\n            ms.removeEventListener('sourceopen', this.e.onSourceOpen);\n            ms.removeEventListener('sourceended', this.e.onSourceEnded);\n            ms.removeEventListener('sourceclose', this.e.onSourceClose);\n            this._pendingSourceBufferInit = [];\n            this._isBufferFull = false;\n            this._idrList.clear();\n            this._mediaSource = null;\n        }\n\n        if (this._mediaElement) {\n            this._mediaElement.src = '';\n            this._mediaElement.removeAttribute('src');\n            this._mediaElement = null;\n        }\n        if (this._mediaSourceObjectURL) {\n            window.URL.revokeObjectURL(this._mediaSourceObjectURL);\n            this._mediaSourceObjectURL = null;\n        }\n    }\n\n    appendInitSegment(initSegment, deferred) {\n        if (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n            // sourcebuffer creation requires mediaSource.readyState === 'open'\n            // so we defer the sourcebuffer creation, until sourceopen event triggered\n            this._pendingSourceBufferInit.push(initSegment);\n            // make sure that this InitSegment is in the front of pending segments queue\n            this._pendingSegments[initSegment.type].push(initSegment);\n            return;\n        }\n\n        let is = initSegment;\n        let mimeType = `${is.container}`;\n        if (is.codec && is.codec.length > 0) {\n            mimeType += `;codecs=${is.codec}`;\n        }\n\n        let firstInitSegment = false;\n\n        Log.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n        this._lastInitSegments[is.type] = is;\n\n        if (mimeType !== this._mimeTypes[is.type]) {\n            if (!this._mimeTypes[is.type]) {  // empty, first chance create sourcebuffer\n                firstInitSegment = true;\n                try {\n                    let sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n                    sb.addEventListener('error', this.e.onSourceBufferError);\n                    sb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n                } catch (error) {\n                    Log.e(this.TAG, error.message);\n                    this._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n                    return;\n                }\n            } else {\n                Log.v(this.TAG, `Notice: ${is.type} mimeType changed, origin: ${this._mimeTypes[is.type]}, target: ${mimeType}`);\n            }\n            this._mimeTypes[is.type] = mimeType;\n        }\n\n        if (!deferred) {\n            // deferred means this InitSegment has been pushed to pendingSegments queue\n            this._pendingSegments[is.type].push(is);\n        }\n        if (!firstInitSegment) {  // append immediately only if init segment in subsequence\n            if (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n                this._doAppendSegments();\n            }\n        }\n        if (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n            // 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n            // Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n            this._requireSetMediaDuration = true;\n            this._pendingMediaDuration = is.mediaDuration / 1000;  // in seconds\n            this._updateMediaSourceDuration();\n        }\n    }\n\n    appendMediaSegment(mediaSegment) {\n        let ms = mediaSegment;\n        this._pendingSegments[ms.type].push(ms);\n\n        if (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n            this._doCleanupSourceBuffer();\n        }\n\n        let sb = this._sourceBuffers[ms.type];\n        if (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n            this._doAppendSegments();\n        }\n    }\n\n    seek(seconds) {\n        // remove all appended buffers\n        for (let type in this._sourceBuffers) {\n            if (!this._sourceBuffers[type]) {\n                continue;\n            }\n\n            // abort current buffer append algorithm\n            let sb = this._sourceBuffers[type];\n            if (this._mediaSource.readyState === 'open') {\n                try {\n                    // If range removal algorithm is running, InvalidStateError will be throwed\n                    // Ignore it.\n                    sb.abort();\n                } catch (error) {\n                    Log.e(this.TAG, error.message);\n                }\n            }\n\n            // IDRList should be clear\n            this._idrList.clear();\n\n            // pending segments should be discard\n            let ps = this._pendingSegments[type];\n            ps.splice(0, ps.length);\n\n            if (this._mediaSource.readyState === 'closed') {\n                // Parent MediaSource object has been detached from HTMLMediaElement\n                continue;\n            }\n\n            // record ranges to be remove from SourceBuffer\n            for (let i = 0; i < sb.buffered.length; i++) {\n                let start = sb.buffered.start(i);\n                let end = sb.buffered.end(i);\n                this._pendingRemoveRanges[type].push({start, end});\n            }\n\n            // if sb is not updating, let's remove ranges now!\n            if (!sb.updating) {\n                this._doRemoveRanges();\n            }\n\n            // Safari 10 may get InvalidStateError in the later appendBuffer() after SourceBuffer.remove() call\n            // Internal parser's state may be invalid at this time. Re-append last InitSegment to workaround.\n            // Related issue: https://bugs.webkit.org/show_bug.cgi?id=159230\n            if (Browser.safari) {\n                let lastInitSegment = this._lastInitSegments[type];\n                if (lastInitSegment) {\n                    this._pendingSegments[type].push(lastInitSegment);\n                    if (!sb.updating) {\n                        this._doAppendSegments();\n                    }\n                }\n            }\n        }\n    }\n\n    endOfStream() {\n        let ms = this._mediaSource;\n        let sb = this._sourceBuffers;\n        if (!ms || ms.readyState !== 'open') {\n            if (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n                // If MediaSource hasn't turned into open state, and there're pending segments\n                // Mark pending endOfStream, defer call until all pending segments appended complete\n                this._hasPendingEos = true;\n            }\n            return;\n        }\n        if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n            // If any sourcebuffer is updating, defer endOfStream operation\n            // See _onSourceBufferUpdateEnd()\n            this._hasPendingEos = true;\n        } else {\n            this._hasPendingEos = false;\n            // Notify media data loading complete\n            // This is helpful for correcting total duration to match last media segment\n            // Otherwise MediaElement's ended event may not be triggered\n            ms.endOfStream();\n        }\n    }\n\n    getNearestKeyframe(dts) {\n        return this._idrList.getLastSyncPointBeforeDts(dts);\n    }\n\n    _needCleanupSourceBuffer() {\n        if (!this._config.autoCleanupSourceBuffer) {\n            return false;\n        }\n\n        let currentTime = this._mediaElement.currentTime;\n\n        for (let type in this._sourceBuffers) {\n            let sb = this._sourceBuffers[type];\n            if (sb) {\n                let buffered = sb.buffered;\n                if (buffered.length >= 1) {\n                    if (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    _doCleanupSourceBuffer() {\n        let currentTime = this._mediaElement.currentTime;\n\n        for (let type in this._sourceBuffers) {\n            let sb = this._sourceBuffers[type];\n            if (sb) {\n                let buffered = sb.buffered;\n                let doRemove = false;\n\n                for (let i = 0; i < buffered.length; i++) {\n                    let start = buffered.start(i);\n                    let end = buffered.end(i);\n\n                    if (start <= currentTime && currentTime < end + 3) {  // padding 3 seconds\n                        if (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n                            doRemove = true;\n                            let removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n                            this._pendingRemoveRanges[type].push({start: start, end: removeEnd});\n                        }\n                    } else if (end < currentTime) {\n                        doRemove = true;\n                        this._pendingRemoveRanges[type].push({start: start, end: end});\n                    }\n                }\n\n                if (doRemove && !sb.updating) {\n                    this._doRemoveRanges();\n                }\n            }\n        }\n    }\n\n    _updateMediaSourceDuration() {\n        let sb = this._sourceBuffers;\n        if (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n            return;\n        }\n        if ((sb.video && sb.video.updating) || (sb.audio && sb.audio.updating)) {\n            return;\n        }\n\n        let current = this._mediaSource.duration;\n        let target = this._pendingMediaDuration;\n\n        if (target > 0 && (isNaN(current) || target > current)) {\n            Log.v(this.TAG, `Update MediaSource duration from ${current} to ${target}`);\n            this._mediaSource.duration = target;\n        }\n\n        this._requireSetMediaDuration = false;\n        this._pendingMediaDuration = 0;\n    }\n\n    _doRemoveRanges() {\n        for (let type in this._pendingRemoveRanges) {\n            if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n                continue;\n            }\n            let sb = this._sourceBuffers[type];\n            let ranges = this._pendingRemoveRanges[type];\n            while (ranges.length && !sb.updating) {\n                let range = ranges.shift();\n                sb.remove(range.start, range.end);\n            }\n        }\n    }\n\n    _doAppendSegments() {\n        let pendingSegments = this._pendingSegments;\n\n        for (let type in pendingSegments) {\n            if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n                continue;\n            }\n\n            if (pendingSegments[type].length > 0) {\n                let segment = pendingSegments[type].shift();\n\n                if (segment.timestampOffset) {\n                    // For MPEG audio stream in MSE, if unbuffered-seeking occurred\n                    // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n                    let currentOffset = this._sourceBuffers[type].timestampOffset;\n                    let targetOffset = segment.timestampOffset / 1000;  // in seconds\n\n                    let delta = Math.abs(currentOffset - targetOffset);\n                    if (delta > 0.1) {  // If time delta > 100ms\n                        Log.v(this.TAG, `Update MPEG audio timestampOffset from ${currentOffset} to ${targetOffset}`);\n                        this._sourceBuffers[type].timestampOffset = targetOffset;\n                    }\n                    delete segment.timestampOffset;\n                }\n\n                if (!segment.data || segment.data.byteLength === 0) {\n                    // Ignore empty buffer\n                    continue;\n                }\n\n                try {\n                    this._sourceBuffers[type].appendBuffer(segment.data);\n                    this._isBufferFull = false;\n                    if (type === 'video' && segment.hasOwnProperty('info')) {\n                        this._idrList.appendArray(segment.info.syncPoints);\n                    }\n                } catch (error) {\n                    this._pendingSegments[type].unshift(segment);\n                    if (error.code === 22) {  // QuotaExceededError\n                        /* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n                         * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n                         * SourceBuffer eviction policy may be changed in future version of FireFox.\n                         *\n                         * Related issues:\n                         * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n                         * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n                         */\n\n                        // report buffer full, abort network IO\n                        if (!this._isBufferFull) {\n                            this._emitter.emit(MSEEvents.BUFFER_FULL);\n                        }\n                        this._isBufferFull = true;\n                    } else {\n                        Log.e(this.TAG, error.message);\n                        this._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n                    }\n                }\n            }\n        }\n    }\n\n    _onSourceOpen() {\n        Log.v(this.TAG, 'MediaSource onSourceOpen');\n        this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n        // deferred sourcebuffer creation / initialization\n        if (this._pendingSourceBufferInit.length > 0) {\n            let pendings = this._pendingSourceBufferInit;\n            while (pendings.length) {\n                let segment = pendings.shift();\n                this.appendInitSegment(segment, true);\n            }\n        }\n        // there may be some pending media segments, append them\n        if (this._hasPendingSegments()) {\n            this._doAppendSegments();\n        }\n        this._emitter.emit(MSEEvents.SOURCE_OPEN);\n    }\n\n    _onSourceEnded() {\n        // fired on endOfStream\n        Log.v(this.TAG, 'MediaSource onSourceEnded');\n    }\n\n    _onSourceClose() {\n        // fired on detaching from media element\n        Log.v(this.TAG, 'MediaSource onSourceClose');\n        if (this._mediaSource && this.e != null) {\n            this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n            this._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n            this._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n        }\n    }\n\n    _hasPendingSegments() {\n        let ps = this._pendingSegments;\n        return ps.video.length > 0 || ps.audio.length > 0;\n    }\n\n    _hasPendingRemoveRanges() {\n        let prr = this._pendingRemoveRanges;\n        return prr.video.length > 0 || prr.audio.length > 0;\n    }\n\n    _onSourceBufferUpdateEnd() {\n        if (this._requireSetMediaDuration) {\n            this._updateMediaSourceDuration();\n        } else if (this._hasPendingRemoveRanges()) {\n            this._doRemoveRanges();\n        } else if (this._hasPendingSegments()) {\n            this._doAppendSegments();\n        } else if (this._hasPendingEos) {\n            this.endOfStream();\n        }\n        this._emitter.emit(MSEEvents.UPDATE_END);\n    }\n\n    _onSourceBufferError(e) {\n        Log.e(this.TAG, `SourceBuffer Error: ${e}`);\n        // this error might not always be fatal, just ignore it\n    }\n\n}\n\nexport default MSEController;"]},"metadata":{},"sourceType":"module"}