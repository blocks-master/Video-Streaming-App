{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js';\n/* Notice: ms-stream may cause IE/Edge browser crash if seek too frequently!!!\n * The browser may crash in wininet.dll. Disable for now.\n *\n * For IE11/Edge browser by microsoft which supports `xhr.responseType = 'ms-stream'`\n * Notice that ms-stream API sucks. The buffer is always expanding along with downloading.\n *\n * We need to abort the xhr if buffer size exceeded limit size (e.g. 16 MiB), then do reconnect.\n * in order to release previous ArrayBuffer to avoid memory leak\n *\n * Otherwise, the ArrayBuffer will increase to a terrible size that equals final file size.\n */\n\nclass MSStreamLoader extends BaseLoader {\n  static isSupported() {\n    try {\n      if (typeof self.MSStream === 'undefined' || typeof self.MSStreamReader === 'undefined') {\n        return false;\n      }\n\n      let xhr = new XMLHttpRequest();\n      xhr.open('GET', 'https://example.com', true);\n      xhr.responseType = 'ms-stream';\n      return xhr.responseType === 'ms-stream';\n    } catch (e) {\n      Log.w('MSStreamLoader', e.message);\n      return false;\n    }\n  }\n\n  constructor(seekHandler, config) {\n    super('xhr-msstream-loader');\n    this.TAG = 'MSStreamLoader';\n    this._seekHandler = seekHandler;\n    this._config = config;\n    this._needStash = true;\n    this._xhr = null;\n    this._reader = null; // MSStreamReader\n\n    this._totalRange = null;\n    this._currentRange = null;\n    this._currentRequestURL = null;\n    this._currentRedirectedURL = null;\n    this._contentLength = null;\n    this._receivedLength = 0;\n    this._bufferLimit = 16 * 1024 * 1024; // 16MB\n\n    this._lastTimeBufferSize = 0;\n    this._isReconnecting = false;\n  }\n\n  destroy() {\n    if (this.isWorking()) {\n      this.abort();\n    }\n\n    if (this._reader) {\n      this._reader.onprogress = null;\n      this._reader.onload = null;\n      this._reader.onerror = null;\n      this._reader = null;\n    }\n\n    if (this._xhr) {\n      this._xhr.onreadystatechange = null;\n      this._xhr = null;\n    }\n\n    super.destroy();\n  }\n\n  open(dataSource, range) {\n    this._internalOpen(dataSource, range, false);\n  }\n\n  _internalOpen(dataSource, range, isSubrange) {\n    this._dataSource = dataSource;\n\n    if (!isSubrange) {\n      this._totalRange = range;\n    } else {\n      this._currentRange = range;\n    }\n\n    let sourceURL = dataSource.url;\n\n    if (this._config.reuseRedirectedURL) {\n      if (this._currentRedirectedURL != undefined) {\n        sourceURL = this._currentRedirectedURL;\n      } else if (dataSource.redirectedURL != undefined) {\n        sourceURL = dataSource.redirectedURL;\n      }\n    }\n\n    let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n    this._currentRequestURL = seekConfig.url;\n    let reader = this._reader = new self.MSStreamReader();\n    reader.onprogress = this._msrOnProgress.bind(this);\n    reader.onload = this._msrOnLoad.bind(this);\n    reader.onerror = this._msrOnError.bind(this);\n    let xhr = this._xhr = new XMLHttpRequest();\n    xhr.open('GET', seekConfig.url, true);\n    xhr.responseType = 'ms-stream';\n    xhr.onreadystatechange = this._xhrOnReadyStateChange.bind(this);\n    xhr.onerror = this._xhrOnError.bind(this);\n\n    if (dataSource.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    if (typeof seekConfig.headers === 'object') {\n      let headers = seekConfig.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    } // add additional headers\n\n\n    if (typeof this._config.headers === 'object') {\n      let headers = this._config.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    }\n\n    if (this._isReconnecting) {\n      this._isReconnecting = false;\n    } else {\n      this._status = LoaderStatus.kConnecting;\n    }\n\n    xhr.send();\n  }\n\n  abort() {\n    this._internalAbort();\n\n    this._status = LoaderStatus.kComplete;\n  }\n\n  _internalAbort() {\n    if (this._reader) {\n      if (this._reader.readyState === 1) {\n        // LOADING\n        this._reader.abort();\n      }\n\n      this._reader.onprogress = null;\n      this._reader.onload = null;\n      this._reader.onerror = null;\n      this._reader = null;\n    }\n\n    if (this._xhr) {\n      this._xhr.abort();\n\n      this._xhr.onreadystatechange = null;\n      this._xhr = null;\n    }\n  }\n\n  _xhrOnReadyStateChange(e) {\n    let xhr = e.target;\n\n    if (xhr.readyState === 2) {\n      // HEADERS_RECEIVED\n      if (xhr.status >= 200 && xhr.status <= 299) {\n        this._status = LoaderStatus.kBuffering;\n\n        if (xhr.responseURL != undefined) {\n          let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n\n          if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n            this._currentRedirectedURL = redirectedURL;\n\n            if (this._onURLRedirect) {\n              this._onURLRedirect(redirectedURL);\n            }\n          }\n        }\n\n        let lengthHeader = xhr.getResponseHeader('Content-Length');\n\n        if (lengthHeader != null && this._contentLength == null) {\n          let length = parseInt(lengthHeader);\n\n          if (length > 0) {\n            this._contentLength = length;\n\n            if (this._onContentLengthKnown) {\n              this._onContentLengthKnown(this._contentLength);\n            }\n          }\n        }\n      } else {\n        this._status = LoaderStatus.kError;\n\n        if (this._onError) {\n          this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n            code: xhr.status,\n            msg: xhr.statusText\n          });\n        } else {\n          throw new RuntimeException('MSStreamLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n        }\n      }\n    } else if (xhr.readyState === 3) {\n      // LOADING\n      if (xhr.status >= 200 && xhr.status <= 299) {\n        this._status = LoaderStatus.kBuffering;\n        let msstream = xhr.response;\n\n        this._reader.readAsArrayBuffer(msstream);\n      }\n    }\n  }\n\n  _xhrOnError(e) {\n    this._status = LoaderStatus.kError;\n    let type = LoaderErrors.EXCEPTION;\n    let info = {\n      code: -1,\n      msg: e.constructor.name + ' ' + e.type\n    };\n\n    if (this._onError) {\n      this._onError(type, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n  _msrOnProgress(e) {\n    let reader = e.target;\n    let bigbuffer = reader.result;\n\n    if (bigbuffer == null) {\n      // result may be null, workaround for buggy M$\n      this._doReconnectIfNeeded();\n\n      return;\n    }\n\n    let slice = bigbuffer.slice(this._lastTimeBufferSize);\n    this._lastTimeBufferSize = bigbuffer.byteLength;\n    let byteStart = this._totalRange.from + this._receivedLength;\n    this._receivedLength += slice.byteLength;\n\n    if (this._onDataArrival) {\n      this._onDataArrival(slice, byteStart, this._receivedLength);\n    }\n\n    if (bigbuffer.byteLength >= this._bufferLimit) {\n      Log.v(this.TAG, `MSStream buffer exceeded max size near ${byteStart + slice.byteLength}, reconnecting...`);\n\n      this._doReconnectIfNeeded();\n    }\n  }\n\n  _doReconnectIfNeeded() {\n    if (this._contentLength == null || this._receivedLength < this._contentLength) {\n      this._isReconnecting = true;\n      this._lastTimeBufferSize = 0;\n\n      this._internalAbort();\n\n      let range = {\n        from: this._totalRange.from + this._receivedLength,\n        to: -1\n      };\n\n      this._internalOpen(this._dataSource, range, true);\n    }\n  }\n\n  _msrOnLoad(e) {\n    // actually it is onComplete event\n    this._status = LoaderStatus.kComplete;\n\n    if (this._onComplete) {\n      this._onComplete(this._totalRange.from, this._totalRange.from + this._receivedLength - 1);\n    }\n  }\n\n  _msrOnError(e) {\n    this._status = LoaderStatus.kError;\n    let type = 0;\n    let info = null;\n\n    if (this._contentLength && this._receivedLength < this._contentLength) {\n      type = LoaderErrors.EARLY_EOF;\n      info = {\n        code: -1,\n        msg: 'MSStream meet Early-Eof'\n      };\n    } else {\n      type = LoaderErrors.EARLY_EOF;\n      info = {\n        code: -1,\n        msg: e.constructor.name + ' ' + e.type\n      };\n    }\n\n    if (this._onError) {\n      this._onError(type, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n}\n\nexport default MSStreamLoader;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/io/xhr-msstream-loader.js"],"names":["Log","BaseLoader","LoaderStatus","LoaderErrors","RuntimeException","MSStreamLoader","isSupported","self","MSStream","MSStreamReader","xhr","XMLHttpRequest","open","responseType","e","w","message","constructor","seekHandler","config","TAG","_seekHandler","_config","_needStash","_xhr","_reader","_totalRange","_currentRange","_currentRequestURL","_currentRedirectedURL","_contentLength","_receivedLength","_bufferLimit","_lastTimeBufferSize","_isReconnecting","destroy","isWorking","abort","onprogress","onload","onerror","onreadystatechange","dataSource","range","_internalOpen","isSubrange","_dataSource","sourceURL","url","reuseRedirectedURL","undefined","redirectedURL","seekConfig","getConfig","reader","_msrOnProgress","bind","_msrOnLoad","_msrOnError","_xhrOnReadyStateChange","_xhrOnError","withCredentials","headers","key","hasOwnProperty","setRequestHeader","_status","kConnecting","send","_internalAbort","kComplete","readyState","target","status","kBuffering","responseURL","removeURLParameters","_onURLRedirect","lengthHeader","getResponseHeader","length","parseInt","_onContentLengthKnown","kError","_onError","HTTP_STATUS_CODE_INVALID","code","msg","statusText","msstream","response","readAsArrayBuffer","type","EXCEPTION","info","name","bigbuffer","result","_doReconnectIfNeeded","slice","byteLength","byteStart","from","_onDataArrival","v","to","_onComplete","EARLY_EOF"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport {BaseLoader, LoaderStatus, LoaderErrors} from './loader.js';\nimport {RuntimeException} from '../utils/exception.js';\n\n/* Notice: ms-stream may cause IE/Edge browser crash if seek too frequently!!!\n * The browser may crash in wininet.dll. Disable for now.\n *\n * For IE11/Edge browser by microsoft which supports `xhr.responseType = 'ms-stream'`\n * Notice that ms-stream API sucks. The buffer is always expanding along with downloading.\n *\n * We need to abort the xhr if buffer size exceeded limit size (e.g. 16 MiB), then do reconnect.\n * in order to release previous ArrayBuffer to avoid memory leak\n *\n * Otherwise, the ArrayBuffer will increase to a terrible size that equals final file size.\n */\nclass MSStreamLoader extends BaseLoader {\n\n    static isSupported() {\n        try {\n            if (typeof self.MSStream === 'undefined' || typeof self.MSStreamReader === 'undefined') {\n                return false;\n            }\n\n            let xhr = new XMLHttpRequest();\n            xhr.open('GET', 'https://example.com', true);\n            xhr.responseType = 'ms-stream';\n            return (xhr.responseType === 'ms-stream');\n        } catch (e) {\n            Log.w('MSStreamLoader', e.message);\n            return false;\n        }\n    }\n\n    constructor(seekHandler, config) {\n        super('xhr-msstream-loader');\n        this.TAG = 'MSStreamLoader';\n\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = true;\n\n        this._xhr = null;\n        this._reader = null;  // MSStreamReader\n\n        this._totalRange = null;\n        this._currentRange = null;\n\n        this._currentRequestURL = null;\n        this._currentRedirectedURL = null;\n\n        this._contentLength = null;\n        this._receivedLength = 0;\n\n        this._bufferLimit = 16 * 1024 * 1024;  // 16MB\n        this._lastTimeBufferSize = 0;\n        this._isReconnecting = false;\n    }\n\n    destroy() {\n        if (this.isWorking()) {\n            this.abort();\n        }\n        if (this._reader) {\n            this._reader.onprogress = null;\n            this._reader.onload = null;\n            this._reader.onerror = null;\n            this._reader = null;\n        }\n        if (this._xhr) {\n            this._xhr.onreadystatechange = null;\n            this._xhr = null;\n        }\n        super.destroy();\n    }\n\n    open(dataSource, range) {\n        this._internalOpen(dataSource, range, false);\n    }\n\n    _internalOpen(dataSource, range, isSubrange) {\n        this._dataSource = dataSource;\n\n        if (!isSubrange) {\n            this._totalRange = range;\n        } else {\n            this._currentRange = range;\n        }\n\n        let sourceURL = dataSource.url;\n        if (this._config.reuseRedirectedURL) {\n            if (this._currentRedirectedURL != undefined) {\n                sourceURL = this._currentRedirectedURL;\n            } else if (dataSource.redirectedURL != undefined) {\n                sourceURL = dataSource.redirectedURL;\n            }\n        }\n\n        let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n        this._currentRequestURL = seekConfig.url;\n\n        let reader = this._reader = new self.MSStreamReader();\n        reader.onprogress = this._msrOnProgress.bind(this);\n        reader.onload = this._msrOnLoad.bind(this);\n        reader.onerror = this._msrOnError.bind(this);\n\n        let xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', seekConfig.url, true);\n        xhr.responseType = 'ms-stream';\n        xhr.onreadystatechange = this._xhrOnReadyStateChange.bind(this);\n        xhr.onerror = this._xhrOnError.bind(this);\n\n        if (dataSource.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (typeof seekConfig.headers === 'object') {\n            let headers = seekConfig.headers;\n\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        // add additional headers\n        if (typeof this._config.headers === 'object') {\n            let headers = this._config.headers;\n\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        if (this._isReconnecting) {\n            this._isReconnecting = false;\n        } else {\n            this._status = LoaderStatus.kConnecting;\n        }\n        xhr.send();\n    }\n\n    abort() {\n        this._internalAbort();\n        this._status = LoaderStatus.kComplete;\n    }\n\n    _internalAbort() {\n        if (this._reader) {\n            if (this._reader.readyState === 1) {  // LOADING\n                this._reader.abort();\n            }\n            this._reader.onprogress = null;\n            this._reader.onload = null;\n            this._reader.onerror = null;\n            this._reader = null;\n        }\n        if (this._xhr) {\n            this._xhr.abort();\n            this._xhr.onreadystatechange = null;\n            this._xhr = null;\n        }\n    }\n\n    _xhrOnReadyStateChange(e) {\n        let xhr = e.target;\n\n        if (xhr.readyState === 2) {  // HEADERS_RECEIVED\n            if (xhr.status >= 200 && xhr.status <= 299) {\n                this._status = LoaderStatus.kBuffering;\n\n                if (xhr.responseURL != undefined) {\n                    let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n                    if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n                        this._currentRedirectedURL = redirectedURL;\n                        if (this._onURLRedirect) {\n                            this._onURLRedirect(redirectedURL);\n                        }\n                    }\n                }\n\n                let lengthHeader = xhr.getResponseHeader('Content-Length');\n                if (lengthHeader != null && this._contentLength == null) {\n                    let length = parseInt(lengthHeader);\n                    if (length > 0) {\n                        this._contentLength = length;\n                        if (this._onContentLengthKnown) {\n                            this._onContentLengthKnown(this._contentLength);\n                        }\n                    }\n                }\n            } else {\n                this._status = LoaderStatus.kError;\n                if (this._onError) {\n                    this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {code: xhr.status, msg: xhr.statusText});\n                } else {\n                    throw new RuntimeException('MSStreamLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n                }\n            }\n        } else if (xhr.readyState === 3) {  // LOADING\n            if (xhr.status >= 200 && xhr.status <= 299) {\n                this._status = LoaderStatus.kBuffering;\n\n                let msstream = xhr.response;\n                this._reader.readAsArrayBuffer(msstream);\n            }\n        }\n    }\n\n    _xhrOnError(e) {\n        this._status = LoaderStatus.kError;\n        let type = LoaderErrors.EXCEPTION;\n        let info = {code: -1, msg: e.constructor.name + ' ' + e.type};\n\n        if (this._onError) {\n            this._onError(type, info);\n        } else {\n            throw new RuntimeException(info.msg);\n        }\n    }\n\n    _msrOnProgress(e) {\n        let reader = e.target;\n        let bigbuffer = reader.result;\n        if (bigbuffer == null) {  // result may be null, workaround for buggy M$\n            this._doReconnectIfNeeded();\n            return;\n        }\n\n        let slice = bigbuffer.slice(this._lastTimeBufferSize);\n        this._lastTimeBufferSize = bigbuffer.byteLength;\n        let byteStart = this._totalRange.from + this._receivedLength;\n        this._receivedLength += slice.byteLength;\n\n        if (this._onDataArrival) {\n            this._onDataArrival(slice, byteStart, this._receivedLength);\n        }\n\n        if (bigbuffer.byteLength >= this._bufferLimit) {\n            Log.v(this.TAG, `MSStream buffer exceeded max size near ${byteStart + slice.byteLength}, reconnecting...`);\n            this._doReconnectIfNeeded();\n        }\n    }\n\n    _doReconnectIfNeeded() {\n        if (this._contentLength == null || this._receivedLength < this._contentLength) {\n            this._isReconnecting = true;\n            this._lastTimeBufferSize = 0;\n            this._internalAbort();\n\n            let range = {\n                from: this._totalRange.from + this._receivedLength,\n                to: -1\n            };\n            this._internalOpen(this._dataSource, range, true);\n        }\n    }\n\n    _msrOnLoad(e) {  // actually it is onComplete event\n        this._status = LoaderStatus.kComplete;\n        if (this._onComplete) {\n            this._onComplete(this._totalRange.from, this._totalRange.from + this._receivedLength - 1);\n        }\n    }\n\n    _msrOnError(e) {\n        this._status = LoaderStatus.kError;\n        let type = 0;\n        let info = null;\n\n        if (this._contentLength && this._receivedLength < this._contentLength) {\n            type = LoaderErrors.EARLY_EOF;\n            info = {code: -1, msg: 'MSStream meet Early-Eof'};\n        } else {\n            type = LoaderErrors.EARLY_EOF;\n            info = {code: -1, msg: e.constructor.name + ' ' + e.type};\n        }\n\n        if (this._onError) {\n            this._onError(type, info);\n        } else {\n            throw new RuntimeException(info.msg);\n        }\n    }\n}\n\nexport default MSStreamLoader;"]},"metadata":{},"sourceType":"module"}