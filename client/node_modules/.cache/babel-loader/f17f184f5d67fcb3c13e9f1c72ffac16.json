{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport PlayerEvents from './player-events.js';\nimport Transmuxer from '../core/transmuxer.js';\nimport TransmuxingEvents from '../core/transmuxing-events.js';\nimport MSEController from '../core/mse-controller.js';\nimport MSEEvents from '../core/mse-events.js';\nimport { ErrorTypes, ErrorDetails } from './player-errors.js';\nimport { createDefaultConfig } from '../config.js';\nimport { InvalidArgumentException, IllegalStateException } from '../utils/exception.js';\n\nclass FlvPlayer {\n  constructor(mediaDataSource, config) {\n    this.TAG = 'FlvPlayer';\n    this._type = 'FlvPlayer';\n    this._emitter = new EventEmitter();\n    this._config = createDefaultConfig();\n\n    if (typeof config === 'object') {\n      Object.assign(this._config, config);\n    }\n\n    if (mediaDataSource.type.toLowerCase() !== 'flv') {\n      throw new InvalidArgumentException('FlvPlayer requires an flv MediaDataSource input!');\n    }\n\n    if (mediaDataSource.isLive === true) {\n      this._config.isLive = true;\n    }\n\n    this.e = {\n      onvLoadedMetadata: this._onvLoadedMetadata.bind(this),\n      onvSeeking: this._onvSeeking.bind(this),\n      onvCanPlay: this._onvCanPlay.bind(this),\n      onvStalled: this._onvStalled.bind(this),\n      onvProgress: this._onvProgress.bind(this)\n    };\n\n    if (self.performance && self.performance.now) {\n      this._now = self.performance.now.bind(self.performance);\n    } else {\n      this._now = Date.now;\n    }\n\n    this._pendingSeekTime = null; // in seconds\n\n    this._requestSetTime = false;\n    this._seekpointRecord = null;\n    this._progressChecker = null;\n    this._mediaDataSource = mediaDataSource;\n    this._mediaElement = null;\n    this._msectl = null;\n    this._transmuxer = null;\n    this._mseSourceOpened = false;\n    this._hasPendingLoad = false;\n    this._receivedCanPlay = false;\n    this._mediaInfo = null;\n    this._statisticsInfo = null;\n    let chromeNeedIDRFix = Browser.chrome && (Browser.version.major < 50 || Browser.version.major === 50 && Browser.version.build < 2661);\n    this._alwaysSeekKeyframe = chromeNeedIDRFix || Browser.msedge || Browser.msie ? true : false;\n\n    if (this._alwaysSeekKeyframe) {\n      this._config.accurateSeek = false;\n    }\n  }\n\n  destroy() {\n    if (this._progressChecker != null) {\n      window.clearInterval(this._progressChecker);\n      this._progressChecker = null;\n    }\n\n    if (this._transmuxer) {\n      this.unload();\n    }\n\n    if (this._mediaElement) {\n      this.detachMediaElement();\n    }\n\n    this.e = null;\n    this._mediaDataSource = null;\n\n    this._emitter.removeAllListeners();\n\n    this._emitter = null;\n  }\n\n  on(event, listener) {\n    if (event === PlayerEvents.MEDIA_INFO) {\n      if (this._mediaInfo != null) {\n        Promise.resolve().then(() => {\n          this._emitter.emit(PlayerEvents.MEDIA_INFO, this.mediaInfo);\n        });\n      }\n    } else if (event === PlayerEvents.STATISTICS_INFO) {\n      if (this._statisticsInfo != null) {\n        Promise.resolve().then(() => {\n          this._emitter.emit(PlayerEvents.STATISTICS_INFO, this.statisticsInfo);\n        });\n      }\n    }\n\n    this._emitter.addListener(event, listener);\n  }\n\n  off(event, listener) {\n    this._emitter.removeListener(event, listener);\n  }\n\n  attachMediaElement(mediaElement) {\n    this._mediaElement = mediaElement;\n    mediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n    mediaElement.addEventListener('seeking', this.e.onvSeeking);\n    mediaElement.addEventListener('canplay', this.e.onvCanPlay);\n    mediaElement.addEventListener('stalled', this.e.onvStalled);\n    mediaElement.addEventListener('progress', this.e.onvProgress);\n    this._msectl = new MSEController(this._config);\n\n    this._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\n\n    this._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\n\n    this._msectl.on(MSEEvents.SOURCE_OPEN, () => {\n      this._mseSourceOpened = true;\n\n      if (this._hasPendingLoad) {\n        this._hasPendingLoad = false;\n        this.load();\n      }\n    });\n\n    this._msectl.on(MSEEvents.ERROR, info => {\n      this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, ErrorDetails.MEDIA_MSE_ERROR, info);\n    });\n\n    this._msectl.attachMediaElement(mediaElement);\n\n    if (this._pendingSeekTime != null) {\n      try {\n        mediaElement.currentTime = this._pendingSeekTime;\n        this._pendingSeekTime = null;\n      } catch (e) {// IE11 may throw InvalidStateError if readyState === 0\n        // We can defer set currentTime operation after loadedmetadata\n      }\n    }\n  }\n\n  detachMediaElement() {\n    if (this._mediaElement) {\n      this._msectl.detachMediaElement();\n\n      this._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n\n      this._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\n\n      this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n\n      this._mediaElement.removeEventListener('stalled', this.e.onvStalled);\n\n      this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n\n      this._mediaElement = null;\n    }\n\n    if (this._msectl) {\n      this._msectl.destroy();\n\n      this._msectl = null;\n    }\n  }\n\n  load() {\n    if (!this._mediaElement) {\n      throw new IllegalStateException('HTMLMediaElement must be attached before load()!');\n    }\n\n    if (this._transmuxer) {\n      throw new IllegalStateException('FlvPlayer.load() has been called, please call unload() first!');\n    }\n\n    if (this._hasPendingLoad) {\n      return;\n    }\n\n    if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === false) {\n      this._hasPendingLoad = true;\n      return;\n    }\n\n    if (this._mediaElement.readyState > 0) {\n      this._requestSetTime = true; // IE11 may throw InvalidStateError if readyState === 0\n\n      this._mediaElement.currentTime = 0;\n    }\n\n    this._transmuxer = new Transmuxer(this._mediaDataSource, this._config);\n\n    this._transmuxer.on(TransmuxingEvents.INIT_SEGMENT, (type, is) => {\n      this._msectl.appendInitSegment(is);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, (type, ms) => {\n      this._msectl.appendMediaSegment(ms); // lazyLoad check\n\n\n      if (this._config.lazyLoad && !this._config.isLive) {\n        let currentTime = this._mediaElement.currentTime;\n\n        if (ms.info.endDts >= (currentTime + this._config.lazyLoadMaxDuration) * 1000) {\n          if (this._progressChecker == null) {\n            Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n            this._suspendTransmuxer();\n          }\n        }\n      }\n    });\n\n    this._transmuxer.on(TransmuxingEvents.LOADING_COMPLETE, () => {\n      this._msectl.endOfStream();\n\n      this._emitter.emit(PlayerEvents.LOADING_COMPLETE);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.RECOVERED_EARLY_EOF, () => {\n      this._emitter.emit(PlayerEvents.RECOVERED_EARLY_EOF);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.IO_ERROR, (detail, info) => {\n      this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.NETWORK_ERROR, detail, info);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.DEMUX_ERROR, (detail, info) => {\n      this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, detail, {\n        code: -1,\n        msg: info\n      });\n    });\n\n    this._transmuxer.on(TransmuxingEvents.MEDIA_INFO, mediaInfo => {\n      this._mediaInfo = mediaInfo;\n\n      this._emitter.emit(PlayerEvents.MEDIA_INFO, Object.assign({}, mediaInfo));\n    });\n\n    this._transmuxer.on(TransmuxingEvents.METADATA_ARRIVED, metadata => {\n      this._emitter.emit(PlayerEvents.METADATA_ARRIVED, metadata);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.SCRIPTDATA_ARRIVED, data => {\n      this._emitter.emit(PlayerEvents.SCRIPTDATA_ARRIVED, data);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.STATISTICS_INFO, statInfo => {\n      this._statisticsInfo = this._fillStatisticsInfo(statInfo);\n\n      this._emitter.emit(PlayerEvents.STATISTICS_INFO, Object.assign({}, this._statisticsInfo));\n    });\n\n    this._transmuxer.on(TransmuxingEvents.RECOMMEND_SEEKPOINT, milliseconds => {\n      if (this._mediaElement && !this._config.accurateSeek) {\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = milliseconds / 1000;\n      }\n    });\n\n    this._transmuxer.open();\n  }\n\n  unload() {\n    if (this._mediaElement) {\n      this._mediaElement.pause();\n    }\n\n    if (this._msectl) {\n      this._msectl.seek(0);\n    }\n\n    if (this._transmuxer) {\n      this._transmuxer.close();\n\n      this._transmuxer.destroy();\n\n      this._transmuxer = null;\n    }\n  }\n\n  play() {\n    return this._mediaElement.play();\n  }\n\n  pause() {\n    this._mediaElement.pause();\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get buffered() {\n    return this._mediaElement.buffered;\n  }\n\n  get duration() {\n    return this._mediaElement.duration;\n  }\n\n  get volume() {\n    return this._mediaElement.volume;\n  }\n\n  set volume(value) {\n    this._mediaElement.volume = value;\n  }\n\n  get muted() {\n    return this._mediaElement.muted;\n  }\n\n  set muted(muted) {\n    this._mediaElement.muted = muted;\n  }\n\n  get currentTime() {\n    if (this._mediaElement) {\n      return this._mediaElement.currentTime;\n    }\n\n    return 0;\n  }\n\n  set currentTime(seconds) {\n    if (this._mediaElement) {\n      this._internalSeek(seconds);\n    } else {\n      this._pendingSeekTime = seconds;\n    }\n  }\n\n  get mediaInfo() {\n    return Object.assign({}, this._mediaInfo);\n  }\n\n  get statisticsInfo() {\n    if (this._statisticsInfo == null) {\n      this._statisticsInfo = {};\n    }\n\n    this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo);\n    return Object.assign({}, this._statisticsInfo);\n  }\n\n  _fillStatisticsInfo(statInfo) {\n    statInfo.playerType = this._type;\n\n    if (!(this._mediaElement instanceof HTMLVideoElement)) {\n      return statInfo;\n    }\n\n    let hasQualityInfo = true;\n    let decoded = 0;\n    let dropped = 0;\n\n    if (this._mediaElement.getVideoPlaybackQuality) {\n      let quality = this._mediaElement.getVideoPlaybackQuality();\n\n      decoded = quality.totalVideoFrames;\n      dropped = quality.droppedVideoFrames;\n    } else if (this._mediaElement.webkitDecodedFrameCount != undefined) {\n      decoded = this._mediaElement.webkitDecodedFrameCount;\n      dropped = this._mediaElement.webkitDroppedFrameCount;\n    } else {\n      hasQualityInfo = false;\n    }\n\n    if (hasQualityInfo) {\n      statInfo.decodedFrames = decoded;\n      statInfo.droppedFrames = dropped;\n    }\n\n    return statInfo;\n  }\n\n  _onmseUpdateEnd() {\n    if (!this._config.lazyLoad || this._config.isLive) {\n      return;\n    }\n\n    let buffered = this._mediaElement.buffered;\n    let currentTime = this._mediaElement.currentTime;\n    let currentRangeStart = 0;\n    let currentRangeEnd = 0;\n\n    for (let i = 0; i < buffered.length; i++) {\n      let start = buffered.start(i);\n      let end = buffered.end(i);\n\n      if (start <= currentTime && currentTime < end) {\n        currentRangeStart = start;\n        currentRangeEnd = end;\n        break;\n      }\n    }\n\n    if (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\n      Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n      this._suspendTransmuxer();\n    }\n  }\n\n  _onmseBufferFull() {\n    Log.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\n\n    if (this._progressChecker == null) {\n      this._suspendTransmuxer();\n    }\n  }\n\n  _suspendTransmuxer() {\n    if (this._transmuxer) {\n      this._transmuxer.pause();\n\n      if (this._progressChecker == null) {\n        this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1000);\n      }\n    }\n  }\n\n  _checkProgressAndResume() {\n    let currentTime = this._mediaElement.currentTime;\n    let buffered = this._mediaElement.buffered;\n    let needResume = false;\n\n    for (let i = 0; i < buffered.length; i++) {\n      let from = buffered.start(i);\n      let to = buffered.end(i);\n\n      if (currentTime >= from && currentTime < to) {\n        if (currentTime >= to - this._config.lazyLoadRecoverDuration) {\n          needResume = true;\n        }\n\n        break;\n      }\n    }\n\n    if (needResume) {\n      window.clearInterval(this._progressChecker);\n      this._progressChecker = null;\n\n      if (needResume) {\n        Log.v(this.TAG, 'Continue loading from paused position');\n\n        this._transmuxer.resume();\n      }\n    }\n  }\n\n  _isTimepointBuffered(seconds) {\n    let buffered = this._mediaElement.buffered;\n\n    for (let i = 0; i < buffered.length; i++) {\n      let from = buffered.start(i);\n      let to = buffered.end(i);\n\n      if (seconds >= from && seconds < to) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _internalSeek(seconds) {\n    let directSeek = this._isTimepointBuffered(seconds);\n\n    let directSeekBegin = false;\n    let directSeekBeginTime = 0;\n\n    if (seconds < 1.0 && this._mediaElement.buffered.length > 0) {\n      let videoBeginTime = this._mediaElement.buffered.start(0);\n\n      if (videoBeginTime < 1.0 && seconds < videoBeginTime || Browser.safari) {\n        directSeekBegin = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n        directSeekBeginTime = Browser.safari ? 0.1 : videoBeginTime;\n      }\n    }\n\n    if (directSeekBegin) {\n      // seek to video begin, set currentTime directly if beginPTS buffered\n      this._requestSetTime = true;\n      this._mediaElement.currentTime = directSeekBeginTime;\n    } else if (directSeek) {\n      // buffered position\n      if (!this._alwaysSeekKeyframe) {\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = seconds;\n      } else {\n        let idr = this._msectl.getNearestKeyframe(Math.floor(seconds * 1000));\n\n        this._requestSetTime = true;\n\n        if (idr != null) {\n          this._mediaElement.currentTime = idr.dts / 1000;\n        } else {\n          this._mediaElement.currentTime = seconds;\n        }\n      }\n\n      if (this._progressChecker != null) {\n        this._checkProgressAndResume();\n      }\n    } else {\n      if (this._progressChecker != null) {\n        window.clearInterval(this._progressChecker);\n        this._progressChecker = null;\n      }\n\n      this._msectl.seek(seconds);\n\n      this._transmuxer.seek(Math.floor(seconds * 1000)); // in milliseconds\n      // no need to set mediaElement.currentTime if non-accurateSeek,\n      // just wait for the recommend_seekpoint callback\n\n\n      if (this._config.accurateSeek) {\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = seconds;\n      }\n    }\n  }\n\n  _checkAndApplyUnbufferedSeekpoint() {\n    if (this._seekpointRecord) {\n      if (this._seekpointRecord.recordTime <= this._now() - 100) {\n        let target = this._mediaElement.currentTime;\n        this._seekpointRecord = null;\n\n        if (!this._isTimepointBuffered(target)) {\n          if (this._progressChecker != null) {\n            window.clearTimeout(this._progressChecker);\n            this._progressChecker = null;\n          } // .currentTime is consists with .buffered timestamp\n          // Chrome/Edge use DTS, while FireFox/Safari use PTS\n\n\n          this._msectl.seek(target);\n\n          this._transmuxer.seek(Math.floor(target * 1000)); // set currentTime if accurateSeek, or wait for recommend_seekpoint callback\n\n\n          if (this._config.accurateSeek) {\n            this._requestSetTime = true;\n            this._mediaElement.currentTime = target;\n          }\n        }\n      } else {\n        window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n      }\n    }\n  }\n\n  _checkAndResumeStuckPlayback(stalled) {\n    let media = this._mediaElement;\n\n    if (stalled || !this._receivedCanPlay || media.readyState < 2) {\n      // HAVE_CURRENT_DATA\n      let buffered = media.buffered;\n\n      if (buffered.length > 0 && media.currentTime < buffered.start(0)) {\n        Log.w(this.TAG, `Playback seems stuck at ${media.currentTime}, seek to ${buffered.start(0)}`);\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = buffered.start(0);\n\n        this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n      }\n    } else {\n      // Playback didn't stuck, remove progress event listener\n      this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n    }\n  }\n\n  _onvLoadedMetadata(e) {\n    if (this._pendingSeekTime != null) {\n      this._mediaElement.currentTime = this._pendingSeekTime;\n      this._pendingSeekTime = null;\n    }\n  }\n\n  _onvSeeking(e) {\n    // handle seeking request from browser's progress bar\n    let target = this._mediaElement.currentTime;\n    let buffered = this._mediaElement.buffered;\n\n    if (this._requestSetTime) {\n      this._requestSetTime = false;\n      return;\n    }\n\n    if (target < 1.0 && buffered.length > 0) {\n      // seek to video begin, set currentTime directly if beginPTS buffered\n      let videoBeginTime = buffered.start(0);\n\n      if (videoBeginTime < 1.0 && target < videoBeginTime || Browser.safari) {\n        this._requestSetTime = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n        this._mediaElement.currentTime = Browser.safari ? 0.1 : videoBeginTime;\n        return;\n      }\n    }\n\n    if (this._isTimepointBuffered(target)) {\n      if (this._alwaysSeekKeyframe) {\n        let idr = this._msectl.getNearestKeyframe(Math.floor(target * 1000));\n\n        if (idr != null) {\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = idr.dts / 1000;\n        }\n      }\n\n      if (this._progressChecker != null) {\n        this._checkProgressAndResume();\n      }\n\n      return;\n    }\n\n    this._seekpointRecord = {\n      seekPoint: target,\n      recordTime: this._now()\n    };\n    window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n  }\n\n  _onvCanPlay(e) {\n    this._receivedCanPlay = true;\n\n    this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n  }\n\n  _onvStalled(e) {\n    this._checkAndResumeStuckPlayback(true);\n  }\n\n  _onvProgress(e) {\n    this._checkAndResumeStuckPlayback();\n  }\n\n}\n\nexport default FlvPlayer;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/player/flv-player.js"],"names":["EventEmitter","Log","Browser","PlayerEvents","Transmuxer","TransmuxingEvents","MSEController","MSEEvents","ErrorTypes","ErrorDetails","createDefaultConfig","InvalidArgumentException","IllegalStateException","FlvPlayer","constructor","mediaDataSource","config","TAG","_type","_emitter","_config","Object","assign","type","toLowerCase","isLive","e","onvLoadedMetadata","_onvLoadedMetadata","bind","onvSeeking","_onvSeeking","onvCanPlay","_onvCanPlay","onvStalled","_onvStalled","onvProgress","_onvProgress","self","performance","now","_now","Date","_pendingSeekTime","_requestSetTime","_seekpointRecord","_progressChecker","_mediaDataSource","_mediaElement","_msectl","_transmuxer","_mseSourceOpened","_hasPendingLoad","_receivedCanPlay","_mediaInfo","_statisticsInfo","chromeNeedIDRFix","chrome","version","major","build","_alwaysSeekKeyframe","msedge","msie","accurateSeek","destroy","window","clearInterval","unload","detachMediaElement","removeAllListeners","on","event","listener","MEDIA_INFO","Promise","resolve","then","emit","mediaInfo","STATISTICS_INFO","statisticsInfo","addListener","off","removeListener","attachMediaElement","mediaElement","addEventListener","UPDATE_END","_onmseUpdateEnd","BUFFER_FULL","_onmseBufferFull","SOURCE_OPEN","load","ERROR","info","MEDIA_ERROR","MEDIA_MSE_ERROR","currentTime","removeEventListener","deferLoadAfterSourceOpen","readyState","INIT_SEGMENT","is","appendInitSegment","MEDIA_SEGMENT","ms","appendMediaSegment","lazyLoad","endDts","lazyLoadMaxDuration","v","_suspendTransmuxer","LOADING_COMPLETE","endOfStream","RECOVERED_EARLY_EOF","IO_ERROR","detail","NETWORK_ERROR","DEMUX_ERROR","code","msg","METADATA_ARRIVED","metadata","SCRIPTDATA_ARRIVED","data","statInfo","_fillStatisticsInfo","RECOMMEND_SEEKPOINT","milliseconds","open","pause","seek","close","play","buffered","duration","volume","value","muted","seconds","_internalSeek","playerType","HTMLVideoElement","hasQualityInfo","decoded","dropped","getVideoPlaybackQuality","quality","totalVideoFrames","droppedVideoFrames","webkitDecodedFrameCount","undefined","webkitDroppedFrameCount","decodedFrames","droppedFrames","currentRangeStart","currentRangeEnd","i","length","start","end","setInterval","_checkProgressAndResume","needResume","from","to","lazyLoadRecoverDuration","resume","_isTimepointBuffered","directSeek","directSeekBegin","directSeekBeginTime","videoBeginTime","safari","idr","getNearestKeyframe","Math","floor","dts","_checkAndApplyUnbufferedSeekpoint","recordTime","target","clearTimeout","setTimeout","_checkAndResumeStuckPlayback","stalled","media","w","seekPoint"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport PlayerEvents from './player-events.js';\nimport Transmuxer from '../core/transmuxer.js';\nimport TransmuxingEvents from '../core/transmuxing-events.js';\nimport MSEController from '../core/mse-controller.js';\nimport MSEEvents from '../core/mse-events.js';\nimport {ErrorTypes, ErrorDetails} from './player-errors.js';\nimport {createDefaultConfig} from '../config.js';\nimport {InvalidArgumentException, IllegalStateException} from '../utils/exception.js';\n\nclass FlvPlayer {\n\n    constructor(mediaDataSource, config) {\n        this.TAG = 'FlvPlayer';\n        this._type = 'FlvPlayer';\n        this._emitter = new EventEmitter();\n\n        this._config = createDefaultConfig();\n        if (typeof config === 'object') {\n            Object.assign(this._config, config);\n        }\n\n        if (mediaDataSource.type.toLowerCase() !== 'flv') {\n            throw new InvalidArgumentException('FlvPlayer requires an flv MediaDataSource input!');\n        }\n\n        if (mediaDataSource.isLive === true) {\n            this._config.isLive = true;\n        }\n\n        this.e = {\n            onvLoadedMetadata: this._onvLoadedMetadata.bind(this),\n            onvSeeking: this._onvSeeking.bind(this),\n            onvCanPlay: this._onvCanPlay.bind(this),\n            onvStalled: this._onvStalled.bind(this),\n            onvProgress: this._onvProgress.bind(this)\n        };\n\n        if (self.performance && self.performance.now) {\n            this._now = self.performance.now.bind(self.performance);\n        } else {\n            this._now = Date.now;\n        }\n\n        this._pendingSeekTime = null;  // in seconds\n        this._requestSetTime = false;\n        this._seekpointRecord = null;\n        this._progressChecker = null;\n\n        this._mediaDataSource = mediaDataSource;\n        this._mediaElement = null;\n        this._msectl = null;\n        this._transmuxer = null;\n\n        this._mseSourceOpened = false;\n        this._hasPendingLoad = false;\n        this._receivedCanPlay = false;\n\n        this._mediaInfo = null;\n        this._statisticsInfo = null;\n\n        let chromeNeedIDRFix = (Browser.chrome &&\n                               (Browser.version.major < 50 ||\n                               (Browser.version.major === 50 && Browser.version.build < 2661)));\n        this._alwaysSeekKeyframe = (chromeNeedIDRFix || Browser.msedge || Browser.msie) ? true : false;\n\n        if (this._alwaysSeekKeyframe) {\n            this._config.accurateSeek = false;\n        }\n    }\n\n    destroy() {\n        if (this._progressChecker != null) {\n            window.clearInterval(this._progressChecker);\n            this._progressChecker = null;\n        }\n        if (this._transmuxer) {\n            this.unload();\n        }\n        if (this._mediaElement) {\n            this.detachMediaElement();\n        }\n        this.e = null;\n        this._mediaDataSource = null;\n\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n    }\n\n    on(event, listener) {\n        if (event === PlayerEvents.MEDIA_INFO) {\n            if (this._mediaInfo != null) {\n                Promise.resolve().then(() => {\n                    this._emitter.emit(PlayerEvents.MEDIA_INFO, this.mediaInfo);\n                });\n            }\n        } else if (event === PlayerEvents.STATISTICS_INFO) {\n            if (this._statisticsInfo != null) {\n                Promise.resolve().then(() => {\n                    this._emitter.emit(PlayerEvents.STATISTICS_INFO, this.statisticsInfo);\n                });\n            }\n        }\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n\n    attachMediaElement(mediaElement) {\n        this._mediaElement = mediaElement;\n        mediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n        mediaElement.addEventListener('seeking', this.e.onvSeeking);\n        mediaElement.addEventListener('canplay', this.e.onvCanPlay);\n        mediaElement.addEventListener('stalled', this.e.onvStalled);\n        mediaElement.addEventListener('progress', this.e.onvProgress);\n\n        this._msectl = new MSEController(this._config);\n\n        this._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\n        this._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\n        this._msectl.on(MSEEvents.SOURCE_OPEN, () => {\n            this._mseSourceOpened = true;\n            if (this._hasPendingLoad) {\n                this._hasPendingLoad = false;\n                this.load();\n            }\n        });\n        this._msectl.on(MSEEvents.ERROR, (info) => {\n            this._emitter.emit(PlayerEvents.ERROR,\n                               ErrorTypes.MEDIA_ERROR,\n                               ErrorDetails.MEDIA_MSE_ERROR,\n                               info\n            );\n        });\n\n        this._msectl.attachMediaElement(mediaElement);\n\n        if (this._pendingSeekTime != null) {\n            try {\n                mediaElement.currentTime = this._pendingSeekTime;\n                this._pendingSeekTime = null;\n            } catch (e) {\n                // IE11 may throw InvalidStateError if readyState === 0\n                // We can defer set currentTime operation after loadedmetadata\n            }\n        }\n    }\n\n    detachMediaElement() {\n        if (this._mediaElement) {\n            this._msectl.detachMediaElement();\n            this._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n            this._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\n            this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n            this._mediaElement.removeEventListener('stalled', this.e.onvStalled);\n            this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n            this._mediaElement = null;\n        }\n        if (this._msectl) {\n            this._msectl.destroy();\n            this._msectl = null;\n        }\n    }\n\n    load() {\n        if (!this._mediaElement) {\n            throw new IllegalStateException('HTMLMediaElement must be attached before load()!');\n        }\n        if (this._transmuxer) {\n            throw new IllegalStateException('FlvPlayer.load() has been called, please call unload() first!');\n        }\n        if (this._hasPendingLoad) {\n            return;\n        }\n\n        if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === false) {\n            this._hasPendingLoad = true;\n            return;\n        }\n\n        if (this._mediaElement.readyState > 0) {\n            this._requestSetTime = true;\n            // IE11 may throw InvalidStateError if readyState === 0\n            this._mediaElement.currentTime = 0;\n        }\n\n        this._transmuxer = new Transmuxer(this._mediaDataSource, this._config);\n\n        this._transmuxer.on(TransmuxingEvents.INIT_SEGMENT, (type, is) => {\n            this._msectl.appendInitSegment(is);\n        });\n        this._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, (type, ms) => {\n            this._msectl.appendMediaSegment(ms);\n\n            // lazyLoad check\n            if (this._config.lazyLoad && !this._config.isLive) {\n                let currentTime = this._mediaElement.currentTime;\n                if (ms.info.endDts >= (currentTime + this._config.lazyLoadMaxDuration) * 1000) {\n                    if (this._progressChecker == null) {\n                        Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n                        this._suspendTransmuxer();\n                    }\n                }\n            }\n        });\n        this._transmuxer.on(TransmuxingEvents.LOADING_COMPLETE, () => {\n            this._msectl.endOfStream();\n            this._emitter.emit(PlayerEvents.LOADING_COMPLETE);\n        });\n        this._transmuxer.on(TransmuxingEvents.RECOVERED_EARLY_EOF, () => {\n            this._emitter.emit(PlayerEvents.RECOVERED_EARLY_EOF);\n        });\n        this._transmuxer.on(TransmuxingEvents.IO_ERROR, (detail, info) => {\n            this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.NETWORK_ERROR, detail, info);\n        });\n        this._transmuxer.on(TransmuxingEvents.DEMUX_ERROR, (detail, info) => {\n            this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, detail, {code: -1, msg: info});\n        });\n        this._transmuxer.on(TransmuxingEvents.MEDIA_INFO, (mediaInfo) => {\n            this._mediaInfo = mediaInfo;\n            this._emitter.emit(PlayerEvents.MEDIA_INFO, Object.assign({}, mediaInfo));\n        });\n        this._transmuxer.on(TransmuxingEvents.METADATA_ARRIVED, (metadata) => {\n            this._emitter.emit(PlayerEvents.METADATA_ARRIVED, metadata);\n        });\n        this._transmuxer.on(TransmuxingEvents.SCRIPTDATA_ARRIVED, (data) => {\n            this._emitter.emit(PlayerEvents.SCRIPTDATA_ARRIVED, data);\n        });\n        this._transmuxer.on(TransmuxingEvents.STATISTICS_INFO, (statInfo) => {\n            this._statisticsInfo = this._fillStatisticsInfo(statInfo);\n            this._emitter.emit(PlayerEvents.STATISTICS_INFO, Object.assign({}, this._statisticsInfo));\n        });\n        this._transmuxer.on(TransmuxingEvents.RECOMMEND_SEEKPOINT, (milliseconds) => {\n            if (this._mediaElement && !this._config.accurateSeek) {\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = milliseconds / 1000;\n            }\n        });\n\n        this._transmuxer.open();\n    }\n\n    unload() {\n        if (this._mediaElement) {\n            this._mediaElement.pause();\n        }\n        if (this._msectl) {\n            this._msectl.seek(0);\n        }\n        if (this._transmuxer) {\n            this._transmuxer.close();\n            this._transmuxer.destroy();\n            this._transmuxer = null;\n        }\n    }\n\n    play() {\n        return this._mediaElement.play();\n    }\n\n    pause() {\n        this._mediaElement.pause();\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get buffered() {\n        return this._mediaElement.buffered;\n    }\n\n    get duration() {\n        return this._mediaElement.duration;\n    }\n\n    get volume() {\n        return this._mediaElement.volume;\n    }\n\n    set volume(value) {\n        this._mediaElement.volume = value;\n    }\n\n    get muted() {\n        return this._mediaElement.muted;\n    }\n\n    set muted(muted) {\n        this._mediaElement.muted = muted;\n    }\n\n    get currentTime() {\n        if (this._mediaElement) {\n            return this._mediaElement.currentTime;\n        }\n        return 0;\n    }\n\n    set currentTime(seconds) {\n        if (this._mediaElement) {\n            this._internalSeek(seconds);\n        } else {\n            this._pendingSeekTime = seconds;\n        }\n    }\n\n    get mediaInfo() {\n        return Object.assign({}, this._mediaInfo);\n    }\n\n    get statisticsInfo() {\n        if (this._statisticsInfo == null) {\n            this._statisticsInfo = {};\n        }\n        this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo);\n        return Object.assign({}, this._statisticsInfo);\n    }\n\n    _fillStatisticsInfo(statInfo) {\n        statInfo.playerType = this._type;\n\n        if (!(this._mediaElement instanceof HTMLVideoElement)) {\n            return statInfo;\n        }\n\n        let hasQualityInfo = true;\n        let decoded = 0;\n        let dropped = 0;\n\n        if (this._mediaElement.getVideoPlaybackQuality) {\n            let quality = this._mediaElement.getVideoPlaybackQuality();\n            decoded = quality.totalVideoFrames;\n            dropped = quality.droppedVideoFrames;\n        } else if (this._mediaElement.webkitDecodedFrameCount != undefined) {\n            decoded = this._mediaElement.webkitDecodedFrameCount;\n            dropped = this._mediaElement.webkitDroppedFrameCount;\n        } else {\n            hasQualityInfo = false;\n        }\n\n        if (hasQualityInfo) {\n            statInfo.decodedFrames = decoded;\n            statInfo.droppedFrames = dropped;\n        }\n\n        return statInfo;\n    }\n\n    _onmseUpdateEnd() {\n        if (!this._config.lazyLoad || this._config.isLive) {\n            return;\n        }\n\n        let buffered = this._mediaElement.buffered;\n        let currentTime = this._mediaElement.currentTime;\n        let currentRangeStart = 0;\n        let currentRangeEnd = 0;\n\n        for (let i = 0; i < buffered.length; i++) {\n            let start = buffered.start(i);\n            let end = buffered.end(i);\n            if (start <= currentTime && currentTime < end) {\n                currentRangeStart = start;\n                currentRangeEnd = end;\n                break;\n            }\n        }\n\n        if (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\n            Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n            this._suspendTransmuxer();\n        }\n    }\n\n    _onmseBufferFull() {\n        Log.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\n        if (this._progressChecker == null) {\n            this._suspendTransmuxer();\n        }\n    }\n\n    _suspendTransmuxer() {\n        if (this._transmuxer) {\n            this._transmuxer.pause();\n\n            if (this._progressChecker == null) {\n                this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1000);\n            }\n        }\n    }\n\n    _checkProgressAndResume() {\n        let currentTime = this._mediaElement.currentTime;\n        let buffered = this._mediaElement.buffered;\n\n        let needResume = false;\n\n        for (let i = 0; i < buffered.length; i++) {\n            let from = buffered.start(i);\n            let to = buffered.end(i);\n            if (currentTime >= from && currentTime < to) {\n                if (currentTime >= to - this._config.lazyLoadRecoverDuration) {\n                    needResume = true;\n                }\n                break;\n            }\n        }\n\n        if (needResume) {\n            window.clearInterval(this._progressChecker);\n            this._progressChecker = null;\n            if (needResume) {\n                Log.v(this.TAG, 'Continue loading from paused position');\n                this._transmuxer.resume();\n            }\n        }\n    }\n\n    _isTimepointBuffered(seconds) {\n        let buffered = this._mediaElement.buffered;\n\n        for (let i = 0; i < buffered.length; i++) {\n            let from = buffered.start(i);\n            let to = buffered.end(i);\n            if (seconds >= from && seconds < to) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _internalSeek(seconds) {\n        let directSeek = this._isTimepointBuffered(seconds);\n\n        let directSeekBegin = false;\n        let directSeekBeginTime = 0;\n\n        if (seconds < 1.0 && this._mediaElement.buffered.length > 0) {\n            let videoBeginTime = this._mediaElement.buffered.start(0);\n            if ((videoBeginTime < 1.0 && seconds < videoBeginTime) || Browser.safari) {\n                directSeekBegin = true;\n                // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n                directSeekBeginTime = Browser.safari ? 0.1 : videoBeginTime;\n            }\n        }\n\n        if (directSeekBegin) {  // seek to video begin, set currentTime directly if beginPTS buffered\n            this._requestSetTime = true;\n            this._mediaElement.currentTime = directSeekBeginTime;\n        }  else if (directSeek) {  // buffered position\n            if (!this._alwaysSeekKeyframe) {\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = seconds;\n            } else {\n                let idr = this._msectl.getNearestKeyframe(Math.floor(seconds * 1000));\n                this._requestSetTime = true;\n                if (idr != null) {\n                    this._mediaElement.currentTime = idr.dts / 1000;\n                } else {\n                    this._mediaElement.currentTime = seconds;\n                }\n            }\n            if (this._progressChecker != null) {\n                this._checkProgressAndResume();\n            }\n        } else {\n            if (this._progressChecker != null) {\n                window.clearInterval(this._progressChecker);\n                this._progressChecker = null;\n            }\n            this._msectl.seek(seconds);\n            this._transmuxer.seek(Math.floor(seconds * 1000));  // in milliseconds\n            // no need to set mediaElement.currentTime if non-accurateSeek,\n            // just wait for the recommend_seekpoint callback\n            if (this._config.accurateSeek) {\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = seconds;\n            }\n        }\n    }\n\n    _checkAndApplyUnbufferedSeekpoint() {\n        if (this._seekpointRecord) {\n            if (this._seekpointRecord.recordTime <= this._now() - 100) {\n                let target = this._mediaElement.currentTime;\n                this._seekpointRecord = null;\n                if (!this._isTimepointBuffered(target)) {\n                    if (this._progressChecker != null) {\n                        window.clearTimeout(this._progressChecker);\n                        this._progressChecker = null;\n                    }\n                    // .currentTime is consists with .buffered timestamp\n                    // Chrome/Edge use DTS, while FireFox/Safari use PTS\n                    this._msectl.seek(target);\n                    this._transmuxer.seek(Math.floor(target * 1000));\n                    // set currentTime if accurateSeek, or wait for recommend_seekpoint callback\n                    if (this._config.accurateSeek) {\n                        this._requestSetTime = true;\n                        this._mediaElement.currentTime = target;\n                    }\n                }\n            } else {\n                window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n            }\n        }\n    }\n\n    _checkAndResumeStuckPlayback(stalled) {\n        let media = this._mediaElement;\n        if (stalled || !this._receivedCanPlay || media.readyState < 2) {  // HAVE_CURRENT_DATA\n            let buffered = media.buffered;\n            if (buffered.length > 0 && media.currentTime < buffered.start(0)) {\n                Log.w(this.TAG, `Playback seems stuck at ${media.currentTime}, seek to ${buffered.start(0)}`);\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = buffered.start(0);\n                this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n            }\n        } else {\n            // Playback didn't stuck, remove progress event listener\n            this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n        }\n    }\n\n    _onvLoadedMetadata(e) {\n        if (this._pendingSeekTime != null) {\n            this._mediaElement.currentTime = this._pendingSeekTime;\n            this._pendingSeekTime = null;\n        }\n    }\n\n    _onvSeeking(e) {  // handle seeking request from browser's progress bar\n        let target = this._mediaElement.currentTime;\n        let buffered = this._mediaElement.buffered;\n\n        if (this._requestSetTime) {\n            this._requestSetTime = false;\n            return;\n        }\n\n        if (target < 1.0 && buffered.length > 0) {\n            // seek to video begin, set currentTime directly if beginPTS buffered\n            let videoBeginTime = buffered.start(0);\n            if ((videoBeginTime < 1.0 && target < videoBeginTime) || Browser.safari) {\n                this._requestSetTime = true;\n                // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n                this._mediaElement.currentTime = Browser.safari ? 0.1 : videoBeginTime;\n                return;\n            }\n        }\n\n        if (this._isTimepointBuffered(target)) {\n            if (this._alwaysSeekKeyframe) {\n                let idr = this._msectl.getNearestKeyframe(Math.floor(target * 1000));\n                if (idr != null) {\n                    this._requestSetTime = true;\n                    this._mediaElement.currentTime = idr.dts / 1000;\n                }\n            }\n            if (this._progressChecker != null) {\n                this._checkProgressAndResume();\n            }\n            return;\n        }\n\n        this._seekpointRecord = {\n            seekPoint: target,\n            recordTime: this._now()\n        };\n        window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n    }\n\n    _onvCanPlay(e) {\n        this._receivedCanPlay = true;\n        this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n    }\n\n    _onvStalled(e) {\n        this._checkAndResumeStuckPlayback(true);\n    }\n\n    _onvProgress(e) {\n        this._checkAndResumeStuckPlayback();\n    }\n\n}\n\nexport default FlvPlayer;"]},"metadata":{},"sourceType":"module"}