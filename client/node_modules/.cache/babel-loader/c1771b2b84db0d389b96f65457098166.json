{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport MP4 from './mp4-generator.js';\nimport AAC from './aac-silent.js';\nimport Browser from '../utils/browser.js';\nimport { SampleInfo, MediaSegmentInfo, MediaSegmentInfoList } from '../core/media-segment-info.js';\nimport { IllegalStateException } from '../utils/exception.js'; // Fragmented mp4 remuxer\n\nclass MP4Remuxer {\n  constructor(config) {\n    this.TAG = 'MP4Remuxer';\n    this._config = config;\n    this._isLive = config.isLive === true ? true : false;\n    this._dtsBase = -1;\n    this._dtsBaseInited = false;\n    this._audioDtsBase = Infinity;\n    this._videoDtsBase = Infinity;\n    this._audioNextDts = undefined;\n    this._videoNextDts = undefined;\n    this._audioStashedLastSample = null;\n    this._videoStashedLastSample = null;\n    this._audioMeta = null;\n    this._videoMeta = null;\n    this._audioSegmentInfoList = new MediaSegmentInfoList('audio');\n    this._videoSegmentInfoList = new MediaSegmentInfoList('video');\n    this._onInitSegment = null;\n    this._onMediaSegment = null; // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n    // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n\n    this._forceFirstIDR = Browser.chrome && (Browser.version.major < 50 || Browser.version.major === 50 && Browser.version.build < 2661) ? true : false; // Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\n    // Make audio beginDts equals with video beginDts, in order to fix seek freeze\n\n    this._fillSilentAfterSeek = Browser.msedge || Browser.msie; // While only FireFox supports 'audio/mp4, codecs=\"mp3\"', use 'audio/mpeg' for chrome, safari, ...\n\n    this._mp3UseMpegAudio = !Browser.firefox;\n    this._fillAudioTimestampGap = this._config.fixAudioTimestampGap;\n  }\n\n  destroy() {\n    this._dtsBase = -1;\n    this._dtsBaseInited = false;\n    this._audioMeta = null;\n    this._videoMeta = null;\n\n    this._audioSegmentInfoList.clear();\n\n    this._audioSegmentInfoList = null;\n\n    this._videoSegmentInfoList.clear();\n\n    this._videoSegmentInfoList = null;\n    this._onInitSegment = null;\n    this._onMediaSegment = null;\n  }\n\n  bindDataSource(producer) {\n    producer.onDataAvailable = this.remux.bind(this);\n    producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n    return this;\n  }\n  /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void\n     InitSegment: {\n         type: string,\n         data: ArrayBuffer,\n         codec: string,\n         container: string\n     }\n  */\n\n\n  get onInitSegment() {\n    return this._onInitSegment;\n  }\n\n  set onInitSegment(callback) {\n    this._onInitSegment = callback;\n  }\n  /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void\n     MediaSegment: {\n         type: string,\n         data: ArrayBuffer,\n         sampleCount: int32\n         info: MediaSegmentInfo\n     }\n  */\n\n\n  get onMediaSegment() {\n    return this._onMediaSegment;\n  }\n\n  set onMediaSegment(callback) {\n    this._onMediaSegment = callback;\n  }\n\n  insertDiscontinuity() {\n    this._audioNextDts = this._videoNextDts = undefined;\n  }\n\n  seek(originalDts) {\n    this._audioStashedLastSample = null;\n    this._videoStashedLastSample = null;\n\n    this._videoSegmentInfoList.clear();\n\n    this._audioSegmentInfoList.clear();\n  }\n\n  remux(audioTrack, videoTrack) {\n    if (!this._onMediaSegment) {\n      throw new IllegalStateException('MP4Remuxer: onMediaSegment callback must be specificed!');\n    }\n\n    if (!this._dtsBaseInited) {\n      this._calculateDtsBase(audioTrack, videoTrack);\n    }\n\n    this._remuxVideo(videoTrack);\n\n    this._remuxAudio(audioTrack);\n  }\n\n  _onTrackMetadataReceived(type, metadata) {\n    let metabox = null;\n    let container = 'mp4';\n    let codec = metadata.codec;\n\n    if (type === 'audio') {\n      this._audioMeta = metadata;\n\n      if (metadata.codec === 'mp3' && this._mp3UseMpegAudio) {\n        // 'audio/mpeg' for MP3 audio track\n        container = 'mpeg';\n        codec = '';\n        metabox = new Uint8Array();\n      } else {\n        // 'audio/mp4, codecs=\"codec\"'\n        metabox = MP4.generateInitSegment(metadata);\n      }\n    } else if (type === 'video') {\n      this._videoMeta = metadata;\n      metabox = MP4.generateInitSegment(metadata);\n    } else {\n      return;\n    } // dispatch metabox (Initialization Segment)\n\n\n    if (!this._onInitSegment) {\n      throw new IllegalStateException('MP4Remuxer: onInitSegment callback must be specified!');\n    }\n\n    this._onInitSegment(type, {\n      type: type,\n      data: metabox.buffer,\n      codec: codec,\n      container: `${type}/${container}`,\n      mediaDuration: metadata.duration // in timescale 1000 (milliseconds)\n\n    });\n  }\n\n  _calculateDtsBase(audioTrack, videoTrack) {\n    if (this._dtsBaseInited) {\n      return;\n    }\n\n    if (audioTrack.samples && audioTrack.samples.length) {\n      this._audioDtsBase = audioTrack.samples[0].dts;\n    }\n\n    if (videoTrack.samples && videoTrack.samples.length) {\n      this._videoDtsBase = videoTrack.samples[0].dts;\n    }\n\n    this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\n    this._dtsBaseInited = true;\n  }\n\n  flushStashedSamples() {\n    let videoSample = this._videoStashedLastSample;\n    let audioSample = this._audioStashedLastSample;\n    let videoTrack = {\n      type: 'video',\n      id: 1,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n\n    if (videoSample != null) {\n      videoTrack.samples.push(videoSample);\n      videoTrack.length = videoSample.length;\n    }\n\n    let audioTrack = {\n      type: 'audio',\n      id: 2,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n\n    if (audioSample != null) {\n      audioTrack.samples.push(audioSample);\n      audioTrack.length = audioSample.length;\n    }\n\n    this._videoStashedLastSample = null;\n    this._audioStashedLastSample = null;\n\n    this._remuxVideo(videoTrack, true);\n\n    this._remuxAudio(audioTrack, true);\n  }\n\n  _remuxAudio(audioTrack, force) {\n    if (this._audioMeta == null) {\n      return;\n    }\n\n    let track = audioTrack;\n    let samples = track.samples;\n    let dtsCorrection = undefined;\n    let firstDts = -1,\n        lastDts = -1,\n        lastPts = -1;\n    let refSampleDuration = this._audioMeta.refSampleDuration;\n    let mpegRawTrack = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio;\n    let firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === undefined;\n    let insertPrefixSilentFrame = false;\n\n    if (!samples || samples.length === 0) {\n      return;\n    }\n\n    if (samples.length === 1 && !force) {\n      // If [sample count in current batch] === 1 && (force != true)\n      // Ignore and keep in demuxer's queue\n      return;\n    } // else if (force === true) do remux\n\n\n    let offset = 0;\n    let mdatbox = null;\n    let mdatBytes = 0; // calculate initial mdat size\n\n    if (mpegRawTrack) {\n      // for raw mpeg buffer\n      offset = 0;\n      mdatBytes = track.length;\n    } else {\n      // for fmp4 mdat box\n      offset = 8; // size + type\n\n      mdatBytes = 8 + track.length;\n    }\n\n    let lastSample = null; // Pop the lastSample and waiting for stash\n\n    if (samples.length > 1) {\n      lastSample = samples.pop();\n      mdatBytes -= lastSample.length;\n    } // Insert [stashed lastSample in the previous batch] to the front\n\n\n    if (this._audioStashedLastSample != null) {\n      let sample = this._audioStashedLastSample;\n      this._audioStashedLastSample = null;\n      samples.unshift(sample);\n      mdatBytes += sample.length;\n    } // Stash the lastSample of current batch, waiting for next batch\n\n\n    if (lastSample != null) {\n      this._audioStashedLastSample = lastSample;\n    }\n\n    let firstSampleOriginalDts = samples[0].dts - this._dtsBase; // calculate dtsCorrection\n\n    if (this._audioNextDts) {\n      dtsCorrection = firstSampleOriginalDts - this._audioNextDts;\n    } else {\n      // this._audioNextDts == undefined\n      if (this._audioSegmentInfoList.isEmpty()) {\n        dtsCorrection = 0;\n\n        if (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\n          if (this._audioMeta.originalCodec !== 'mp3') {\n            insertPrefixSilentFrame = true;\n          }\n        }\n      } else {\n        let lastSample = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n\n        if (lastSample != null) {\n          let distance = firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration);\n\n          if (distance <= 3) {\n            distance = 0;\n          }\n\n          let expectedDts = lastSample.dts + lastSample.duration + distance;\n          dtsCorrection = firstSampleOriginalDts - expectedDts;\n        } else {\n          // lastSample == null, cannot found\n          dtsCorrection = 0;\n        }\n      }\n    }\n\n    if (insertPrefixSilentFrame) {\n      // align audio segment beginDts to match with current video segment's beginDts\n      let firstSampleDts = firstSampleOriginalDts - dtsCorrection;\n\n      let videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);\n\n      if (videoSegment != null && videoSegment.beginDts < firstSampleDts) {\n        let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n\n        if (silentUnit) {\n          let dts = videoSegment.beginDts;\n          let silentFrameDuration = firstSampleDts - videoSegment.beginDts;\n          Log.v(this.TAG, `InsertPrefixSilentAudio: dts: ${dts}, duration: ${silentFrameDuration}`);\n          samples.unshift({\n            unit: silentUnit,\n            dts: dts,\n            pts: dts\n          });\n          mdatBytes += silentUnit.byteLength;\n        } // silentUnit == null: Cannot generate, skip\n\n      } else {\n        insertPrefixSilentFrame = false;\n      }\n    }\n\n    let mp4Samples = []; // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n\n    for (let i = 0; i < samples.length; i++) {\n      let sample = samples[i];\n      let unit = sample.unit;\n      let originalDts = sample.dts - this._dtsBase;\n      let dts = originalDts - dtsCorrection;\n\n      if (firstDts === -1) {\n        firstDts = dts;\n      }\n\n      let sampleDuration = 0;\n\n      if (i !== samples.length - 1) {\n        let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n        sampleDuration = nextDts - dts;\n      } else {\n        // the last sample\n        if (lastSample != null) {\n          // use stashed sample's dts to calculate sample duration\n          let nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n          sampleDuration = nextDts - dts;\n        } else if (mp4Samples.length >= 1) {\n          // use second last sample duration\n          sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n        } else {\n          // the only one sample, use reference sample duration\n          sampleDuration = Math.floor(refSampleDuration);\n        }\n      }\n\n      let needFillSilentFrames = false;\n      let silentFrames = null; // Silent frame generation, if large timestamp gap detected && config.fixAudioTimestampGap\n\n      if (sampleDuration > refSampleDuration * 1.5 && this._audioMeta.codec !== 'mp3' && this._fillAudioTimestampGap && !Browser.safari) {\n        // We need to insert silent frames to fill timestamp gap\n        needFillSilentFrames = true;\n        let delta = Math.abs(sampleDuration - refSampleDuration);\n        let frameCount = Math.ceil(delta / refSampleDuration);\n        let currentDts = dts + refSampleDuration; // Notice: in float\n\n        Log.w(this.TAG, 'Large audio timestamp gap detected, may cause AV sync to drift. ' + 'Silent frames will be generated to avoid unsync.\\n' + `dts: ${dts + sampleDuration} ms, expected: ${dts + Math.round(refSampleDuration)} ms, ` + `delta: ${Math.round(delta)} ms, generate: ${frameCount} frames`);\n        let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n\n        if (silentUnit == null) {\n          Log.w(this.TAG, 'Unable to generate silent frame for ' + `${this._audioMeta.originalCodec} with ${this._audioMeta.channelCount} channels, repeat last frame`); // Repeat last frame\n\n          silentUnit = unit;\n        }\n\n        silentFrames = [];\n\n        for (let j = 0; j < frameCount; j++) {\n          let intDts = Math.round(currentDts); // round to integer\n\n          if (silentFrames.length > 0) {\n            // Set previous frame sample duration\n            let previousFrame = silentFrames[silentFrames.length - 1];\n            previousFrame.duration = intDts - previousFrame.dts;\n          }\n\n          let frame = {\n            dts: intDts,\n            pts: intDts,\n            cts: 0,\n            unit: silentUnit,\n            size: silentUnit.byteLength,\n            duration: 0,\n            // wait for next sample\n            originalDts: originalDts,\n            flags: {\n              isLeading: 0,\n              dependsOn: 1,\n              isDependedOn: 0,\n              hasRedundancy: 0\n            }\n          };\n          silentFrames.push(frame);\n          mdatBytes += frame.size;\n          currentDts += refSampleDuration;\n        } // last frame: align end time to next frame dts\n\n\n        let lastFrame = silentFrames[silentFrames.length - 1];\n        lastFrame.duration = dts + sampleDuration - lastFrame.dts; // silentFrames.forEach((frame) => {\n        //     Log.w(this.TAG, `SilentAudio: dts: ${frame.dts}, duration: ${frame.duration}`);\n        // });\n        // Set correct sample duration for current frame\n\n        sampleDuration = Math.round(refSampleDuration);\n      }\n\n      mp4Samples.push({\n        dts: dts,\n        pts: dts,\n        cts: 0,\n        unit: sample.unit,\n        size: sample.unit.byteLength,\n        duration: sampleDuration,\n        originalDts: originalDts,\n        flags: {\n          isLeading: 0,\n          dependsOn: 1,\n          isDependedOn: 0,\n          hasRedundancy: 0\n        }\n      });\n\n      if (needFillSilentFrames) {\n        // Silent frames should be inserted after wrong-duration frame\n        mp4Samples.push.apply(mp4Samples, silentFrames);\n      }\n    } // allocate mdatbox\n\n\n    if (mpegRawTrack) {\n      // allocate for raw mpeg buffer\n      mdatbox = new Uint8Array(mdatBytes);\n    } else {\n      // allocate for fmp4 mdat box\n      mdatbox = new Uint8Array(mdatBytes); // size field\n\n      mdatbox[0] = mdatBytes >>> 24 & 0xFF;\n      mdatbox[1] = mdatBytes >>> 16 & 0xFF;\n      mdatbox[2] = mdatBytes >>> 8 & 0xFF;\n      mdatbox[3] = mdatBytes & 0xFF; // type field (fourCC)\n\n      mdatbox.set(MP4.types.mdat, 4);\n    } // Write samples into mdatbox\n\n\n    for (let i = 0; i < mp4Samples.length; i++) {\n      let unit = mp4Samples[i].unit;\n      mdatbox.set(unit, offset);\n      offset += unit.byteLength;\n    }\n\n    let latest = mp4Samples[mp4Samples.length - 1];\n    lastDts = latest.dts + latest.duration;\n    this._audioNextDts = lastDts; // fill media segment info & add to info list\n\n    let info = new MediaSegmentInfo();\n    info.beginDts = firstDts;\n    info.endDts = lastDts;\n    info.beginPts = firstDts;\n    info.endPts = lastDts;\n    info.originalBeginDts = mp4Samples[0].originalDts;\n    info.originalEndDts = latest.originalDts + latest.duration;\n    info.firstSample = new SampleInfo(mp4Samples[0].dts, mp4Samples[0].pts, mp4Samples[0].duration, mp4Samples[0].originalDts, false);\n    info.lastSample = new SampleInfo(latest.dts, latest.pts, latest.duration, latest.originalDts, false);\n\n    if (!this._isLive) {\n      this._audioSegmentInfoList.append(info);\n    }\n\n    track.samples = mp4Samples;\n    track.sequenceNumber++;\n    let moofbox = null;\n\n    if (mpegRawTrack) {\n      // Generate empty buffer, because useless for raw mpeg\n      moofbox = new Uint8Array();\n    } else {\n      // Generate moof for fmp4 segment\n      moofbox = MP4.moof(track, firstDts);\n    }\n\n    track.samples = [];\n    track.length = 0;\n    let segment = {\n      type: 'audio',\n      data: this._mergeBoxes(moofbox, mdatbox).buffer,\n      sampleCount: mp4Samples.length,\n      info: info\n    };\n\n    if (mpegRawTrack && firstSegmentAfterSeek) {\n      // For MPEG audio stream in MSE, if seeking occurred, before appending new buffer\n      // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n      segment.timestampOffset = firstDts;\n    }\n\n    this._onMediaSegment('audio', segment);\n  }\n\n  _remuxVideo(videoTrack, force) {\n    if (this._videoMeta == null) {\n      return;\n    }\n\n    let track = videoTrack;\n    let samples = track.samples;\n    let dtsCorrection = undefined;\n    let firstDts = -1,\n        lastDts = -1;\n    let firstPts = -1,\n        lastPts = -1;\n\n    if (!samples || samples.length === 0) {\n      return;\n    }\n\n    if (samples.length === 1 && !force) {\n      // If [sample count in current batch] === 1 && (force != true)\n      // Ignore and keep in demuxer's queue\n      return;\n    } // else if (force === true) do remux\n\n\n    let offset = 8;\n    let mdatbox = null;\n    let mdatBytes = 8 + videoTrack.length;\n    let lastSample = null; // Pop the lastSample and waiting for stash\n\n    if (samples.length > 1) {\n      lastSample = samples.pop();\n      mdatBytes -= lastSample.length;\n    } // Insert [stashed lastSample in the previous batch] to the front\n\n\n    if (this._videoStashedLastSample != null) {\n      let sample = this._videoStashedLastSample;\n      this._videoStashedLastSample = null;\n      samples.unshift(sample);\n      mdatBytes += sample.length;\n    } // Stash the lastSample of current batch, waiting for next batch\n\n\n    if (lastSample != null) {\n      this._videoStashedLastSample = lastSample;\n    }\n\n    let firstSampleOriginalDts = samples[0].dts - this._dtsBase; // calculate dtsCorrection\n\n    if (this._videoNextDts) {\n      dtsCorrection = firstSampleOriginalDts - this._videoNextDts;\n    } else {\n      // this._videoNextDts == undefined\n      if (this._videoSegmentInfoList.isEmpty()) {\n        dtsCorrection = 0;\n      } else {\n        let lastSample = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n\n        if (lastSample != null) {\n          let distance = firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration);\n\n          if (distance <= 3) {\n            distance = 0;\n          }\n\n          let expectedDts = lastSample.dts + lastSample.duration + distance;\n          dtsCorrection = firstSampleOriginalDts - expectedDts;\n        } else {\n          // lastSample == null, cannot found\n          dtsCorrection = 0;\n        }\n      }\n    }\n\n    let info = new MediaSegmentInfo();\n    let mp4Samples = []; // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n\n    for (let i = 0; i < samples.length; i++) {\n      let sample = samples[i];\n      let originalDts = sample.dts - this._dtsBase;\n      let isKeyframe = sample.isKeyframe;\n      let dts = originalDts - dtsCorrection;\n      let cts = sample.cts;\n      let pts = dts + cts;\n\n      if (firstDts === -1) {\n        firstDts = dts;\n        firstPts = pts;\n      }\n\n      let sampleDuration = 0;\n\n      if (i !== samples.length - 1) {\n        let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n        sampleDuration = nextDts - dts;\n      } else {\n        // the last sample\n        if (lastSample != null) {\n          // use stashed sample's dts to calculate sample duration\n          let nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n          sampleDuration = nextDts - dts;\n        } else if (mp4Samples.length >= 1) {\n          // use second last sample duration\n          sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n        } else {\n          // the only one sample, use reference sample duration\n          sampleDuration = Math.floor(this._videoMeta.refSampleDuration);\n        }\n      }\n\n      if (isKeyframe) {\n        let syncPoint = new SampleInfo(dts, pts, sampleDuration, sample.dts, true);\n        syncPoint.fileposition = sample.fileposition;\n        info.appendSyncPoint(syncPoint);\n      }\n\n      mp4Samples.push({\n        dts: dts,\n        pts: pts,\n        cts: cts,\n        units: sample.units,\n        size: sample.length,\n        isKeyframe: isKeyframe,\n        duration: sampleDuration,\n        originalDts: originalDts,\n        flags: {\n          isLeading: 0,\n          dependsOn: isKeyframe ? 2 : 1,\n          isDependedOn: isKeyframe ? 1 : 0,\n          hasRedundancy: 0,\n          isNonSync: isKeyframe ? 0 : 1\n        }\n      });\n    } // allocate mdatbox\n\n\n    mdatbox = new Uint8Array(mdatBytes);\n    mdatbox[0] = mdatBytes >>> 24 & 0xFF;\n    mdatbox[1] = mdatBytes >>> 16 & 0xFF;\n    mdatbox[2] = mdatBytes >>> 8 & 0xFF;\n    mdatbox[3] = mdatBytes & 0xFF;\n    mdatbox.set(MP4.types.mdat, 4); // Write samples into mdatbox\n\n    for (let i = 0; i < mp4Samples.length; i++) {\n      let units = mp4Samples[i].units;\n\n      while (units.length) {\n        let unit = units.shift();\n        let data = unit.data;\n        mdatbox.set(data, offset);\n        offset += data.byteLength;\n      }\n    }\n\n    let latest = mp4Samples[mp4Samples.length - 1];\n    lastDts = latest.dts + latest.duration;\n    lastPts = latest.pts + latest.duration;\n    this._videoNextDts = lastDts; // fill media segment info & add to info list\n\n    info.beginDts = firstDts;\n    info.endDts = lastDts;\n    info.beginPts = firstPts;\n    info.endPts = lastPts;\n    info.originalBeginDts = mp4Samples[0].originalDts;\n    info.originalEndDts = latest.originalDts + latest.duration;\n    info.firstSample = new SampleInfo(mp4Samples[0].dts, mp4Samples[0].pts, mp4Samples[0].duration, mp4Samples[0].originalDts, mp4Samples[0].isKeyframe);\n    info.lastSample = new SampleInfo(latest.dts, latest.pts, latest.duration, latest.originalDts, latest.isKeyframe);\n\n    if (!this._isLive) {\n      this._videoSegmentInfoList.append(info);\n    }\n\n    track.samples = mp4Samples;\n    track.sequenceNumber++; // workaround for chrome < 50: force first sample as a random access point\n    // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n\n    if (this._forceFirstIDR) {\n      let flags = mp4Samples[0].flags;\n      flags.dependsOn = 2;\n      flags.isNonSync = 0;\n    }\n\n    let moofbox = MP4.moof(track, firstDts);\n    track.samples = [];\n    track.length = 0;\n\n    this._onMediaSegment('video', {\n      type: 'video',\n      data: this._mergeBoxes(moofbox, mdatbox).buffer,\n      sampleCount: mp4Samples.length,\n      info: info\n    });\n  }\n\n  _mergeBoxes(moof, mdat) {\n    let result = new Uint8Array(moof.byteLength + mdat.byteLength);\n    result.set(moof, 0);\n    result.set(mdat, moof.byteLength);\n    return result;\n  }\n\n}\n\nexport default MP4Remuxer;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/remux/mp4-remuxer.js"],"names":["Log","MP4","AAC","Browser","SampleInfo","MediaSegmentInfo","MediaSegmentInfoList","IllegalStateException","MP4Remuxer","constructor","config","TAG","_config","_isLive","isLive","_dtsBase","_dtsBaseInited","_audioDtsBase","Infinity","_videoDtsBase","_audioNextDts","undefined","_videoNextDts","_audioStashedLastSample","_videoStashedLastSample","_audioMeta","_videoMeta","_audioSegmentInfoList","_videoSegmentInfoList","_onInitSegment","_onMediaSegment","_forceFirstIDR","chrome","version","major","build","_fillSilentAfterSeek","msedge","msie","_mp3UseMpegAudio","firefox","_fillAudioTimestampGap","fixAudioTimestampGap","destroy","clear","bindDataSource","producer","onDataAvailable","remux","bind","onTrackMetadata","_onTrackMetadataReceived","onInitSegment","callback","onMediaSegment","insertDiscontinuity","seek","originalDts","audioTrack","videoTrack","_calculateDtsBase","_remuxVideo","_remuxAudio","type","metadata","metabox","container","codec","Uint8Array","generateInitSegment","data","buffer","mediaDuration","duration","samples","length","dts","Math","min","flushStashedSamples","videoSample","audioSample","id","sequenceNumber","push","force","track","dtsCorrection","firstDts","lastDts","lastPts","refSampleDuration","mpegRawTrack","firstSegmentAfterSeek","insertPrefixSilentFrame","offset","mdatbox","mdatBytes","lastSample","pop","sample","unshift","firstSampleOriginalDts","isEmpty","originalCodec","getLastSampleBefore","distance","expectedDts","firstSampleDts","videoSegment","getLastSegmentBefore","beginDts","silentUnit","getSilentFrame","channelCount","silentFrameDuration","v","unit","pts","byteLength","mp4Samples","i","sampleDuration","nextDts","floor","needFillSilentFrames","silentFrames","safari","delta","abs","frameCount","ceil","currentDts","w","round","j","intDts","previousFrame","frame","cts","size","flags","isLeading","dependsOn","isDependedOn","hasRedundancy","lastFrame","apply","set","types","mdat","latest","info","endDts","beginPts","endPts","originalBeginDts","originalEndDts","firstSample","append","moofbox","moof","segment","_mergeBoxes","sampleCount","timestampOffset","firstPts","isKeyframe","syncPoint","fileposition","appendSyncPoint","units","isNonSync","shift","result"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport MP4 from './mp4-generator.js';\nimport AAC from './aac-silent.js';\nimport Browser from '../utils/browser.js';\nimport {SampleInfo, MediaSegmentInfo, MediaSegmentInfoList} from '../core/media-segment-info.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\n\n// Fragmented mp4 remuxer\nclass MP4Remuxer {\n\n    constructor(config) {\n        this.TAG = 'MP4Remuxer';\n\n        this._config = config;\n        this._isLive = (config.isLive === true) ? true : false;\n\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioDtsBase = Infinity;\n        this._videoDtsBase = Infinity;\n        this._audioNextDts = undefined;\n        this._videoNextDts = undefined;\n        this._audioStashedLastSample = null;\n        this._videoStashedLastSample = null;\n\n        this._audioMeta = null;\n        this._videoMeta = null;\n\n        this._audioSegmentInfoList = new MediaSegmentInfoList('audio');\n        this._videoSegmentInfoList = new MediaSegmentInfoList('video');\n\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n\n        // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        this._forceFirstIDR = (Browser.chrome &&\n                              (Browser.version.major < 50 ||\n                              (Browser.version.major === 50 && Browser.version.build < 2661))) ? true : false;\n\n        // Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\n        // Make audio beginDts equals with video beginDts, in order to fix seek freeze\n        this._fillSilentAfterSeek = (Browser.msedge || Browser.msie);\n\n        // While only FireFox supports 'audio/mp4, codecs=\"mp3\"', use 'audio/mpeg' for chrome, safari, ...\n        this._mp3UseMpegAudio = !Browser.firefox;\n\n        this._fillAudioTimestampGap = this._config.fixAudioTimestampGap;\n    }\n\n    destroy() {\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioMeta = null;\n        this._videoMeta = null;\n        this._audioSegmentInfoList.clear();\n        this._audioSegmentInfoList = null;\n        this._videoSegmentInfoList.clear();\n        this._videoSegmentInfoList = null;\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n    }\n\n    bindDataSource(producer) {\n        producer.onDataAvailable = this.remux.bind(this);\n        producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n        return this;\n    }\n\n    /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void\n       InitSegment: {\n           type: string,\n           data: ArrayBuffer,\n           codec: string,\n           container: string\n       }\n    */\n    get onInitSegment() {\n        return this._onInitSegment;\n    }\n\n    set onInitSegment(callback) {\n        this._onInitSegment = callback;\n    }\n\n    /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void\n       MediaSegment: {\n           type: string,\n           data: ArrayBuffer,\n           sampleCount: int32\n           info: MediaSegmentInfo\n       }\n    */\n    get onMediaSegment() {\n        return this._onMediaSegment;\n    }\n\n    set onMediaSegment(callback) {\n        this._onMediaSegment = callback;\n    }\n\n    insertDiscontinuity() {\n        this._audioNextDts = this._videoNextDts = undefined;\n    }\n\n    seek(originalDts) {\n        this._audioStashedLastSample = null;\n        this._videoStashedLastSample = null;\n        this._videoSegmentInfoList.clear();\n        this._audioSegmentInfoList.clear();\n    }\n\n    remux(audioTrack, videoTrack) {\n        if (!this._onMediaSegment) {\n            throw new IllegalStateException('MP4Remuxer: onMediaSegment callback must be specificed!');\n        }\n        if (!this._dtsBaseInited) {\n            this._calculateDtsBase(audioTrack, videoTrack);\n        }\n        this._remuxVideo(videoTrack);\n        this._remuxAudio(audioTrack);\n    }\n\n    _onTrackMetadataReceived(type, metadata) {\n        let metabox = null;\n\n        let container = 'mp4';\n        let codec = metadata.codec;\n\n        if (type === 'audio') {\n            this._audioMeta = metadata;\n            if (metadata.codec === 'mp3' && this._mp3UseMpegAudio) {\n                // 'audio/mpeg' for MP3 audio track\n                container = 'mpeg';\n                codec = '';\n                metabox = new Uint8Array();\n            } else {\n                // 'audio/mp4, codecs=\"codec\"'\n                metabox = MP4.generateInitSegment(metadata);\n            }\n        } else if (type === 'video') {\n            this._videoMeta = metadata;\n            metabox = MP4.generateInitSegment(metadata);\n        } else {\n            return;\n        }\n\n        // dispatch metabox (Initialization Segment)\n        if (!this._onInitSegment) {\n            throw new IllegalStateException('MP4Remuxer: onInitSegment callback must be specified!');\n        }\n        this._onInitSegment(type, {\n            type: type,\n            data: metabox.buffer,\n            codec: codec,\n            container: `${type}/${container}`,\n            mediaDuration: metadata.duration  // in timescale 1000 (milliseconds)\n        });\n    }\n\n    _calculateDtsBase(audioTrack, videoTrack) {\n        if (this._dtsBaseInited) {\n            return;\n        }\n\n        if (audioTrack.samples && audioTrack.samples.length) {\n            this._audioDtsBase = audioTrack.samples[0].dts;\n        }\n        if (videoTrack.samples && videoTrack.samples.length) {\n            this._videoDtsBase = videoTrack.samples[0].dts;\n        }\n\n        this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\n        this._dtsBaseInited = true;\n    }\n\n    flushStashedSamples() {\n        let videoSample = this._videoStashedLastSample;\n        let audioSample = this._audioStashedLastSample;\n\n        let videoTrack = {\n            type: 'video',\n            id: 1,\n            sequenceNumber: 0,\n            samples: [],\n            length: 0\n        };\n\n        if (videoSample != null) {\n            videoTrack.samples.push(videoSample);\n            videoTrack.length = videoSample.length;\n        }\n\n        let audioTrack = {\n            type: 'audio',\n            id: 2,\n            sequenceNumber: 0,\n            samples: [],\n            length: 0\n        };\n\n        if (audioSample != null) {\n            audioTrack.samples.push(audioSample);\n            audioTrack.length = audioSample.length;\n        }\n\n        this._videoStashedLastSample = null;\n        this._audioStashedLastSample = null;\n\n        this._remuxVideo(videoTrack, true);\n        this._remuxAudio(audioTrack, true);\n    }\n\n    _remuxAudio(audioTrack, force) {\n        if (this._audioMeta == null) {\n            return;\n        }\n\n        let track = audioTrack;\n        let samples = track.samples;\n        let dtsCorrection = undefined;\n        let firstDts = -1, lastDts = -1, lastPts = -1;\n        let refSampleDuration = this._audioMeta.refSampleDuration;\n\n        let mpegRawTrack = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio;\n        let firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === undefined;\n\n        let insertPrefixSilentFrame = false;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n        if (samples.length === 1 && !force) {\n            // If [sample count in current batch] === 1 && (force != true)\n            // Ignore and keep in demuxer's queue\n            return;\n        }  // else if (force === true) do remux\n\n        let offset = 0;\n        let mdatbox = null;\n        let mdatBytes = 0;\n\n        // calculate initial mdat size\n        if (mpegRawTrack) {\n            // for raw mpeg buffer\n            offset = 0;\n            mdatBytes = track.length;\n        } else {\n            // for fmp4 mdat box\n            offset = 8;  // size + type\n            mdatBytes = 8 + track.length;\n        }\n\n\n        let lastSample = null;\n\n        // Pop the lastSample and waiting for stash\n        if (samples.length > 1) {\n            lastSample = samples.pop();\n            mdatBytes -= lastSample.length;\n        }\n\n        // Insert [stashed lastSample in the previous batch] to the front\n        if (this._audioStashedLastSample != null) {\n            let sample = this._audioStashedLastSample;\n            this._audioStashedLastSample = null;\n            samples.unshift(sample);\n            mdatBytes += sample.length;\n        }\n\n        // Stash the lastSample of current batch, waiting for next batch\n        if (lastSample != null) {\n            this._audioStashedLastSample = lastSample;\n        }\n\n\n        let firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n        // calculate dtsCorrection\n        if (this._audioNextDts) {\n            dtsCorrection = firstSampleOriginalDts - this._audioNextDts;\n        } else {  // this._audioNextDts == undefined\n            if (this._audioSegmentInfoList.isEmpty()) {\n                dtsCorrection = 0;\n                if (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\n                    if (this._audioMeta.originalCodec !== 'mp3') {\n                        insertPrefixSilentFrame = true;\n                    }\n                }\n            } else {\n                let lastSample = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n                if (lastSample != null) {\n                    let distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n                    if (distance <= 3) {\n                        distance = 0;\n                    }\n                    let expectedDts = lastSample.dts + lastSample.duration + distance;\n                    dtsCorrection = firstSampleOriginalDts - expectedDts;\n                } else { // lastSample == null, cannot found\n                    dtsCorrection = 0;\n                }\n            }\n        }\n\n        if (insertPrefixSilentFrame) {\n            // align audio segment beginDts to match with current video segment's beginDts\n            let firstSampleDts = firstSampleOriginalDts - dtsCorrection;\n            let videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);\n            if (videoSegment != null && videoSegment.beginDts < firstSampleDts) {\n                let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n                if (silentUnit) {\n                    let dts = videoSegment.beginDts;\n                    let silentFrameDuration = firstSampleDts - videoSegment.beginDts;\n                    Log.v(this.TAG, `InsertPrefixSilentAudio: dts: ${dts}, duration: ${silentFrameDuration}`);\n                    samples.unshift({unit: silentUnit, dts: dts, pts: dts});\n                    mdatBytes += silentUnit.byteLength;\n                }  // silentUnit == null: Cannot generate, skip\n            } else {\n                insertPrefixSilentFrame = false;\n            }\n        }\n\n        let mp4Samples = [];\n\n        // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n        for (let i = 0; i < samples.length; i++) {\n            let sample = samples[i];\n            let unit = sample.unit;\n            let originalDts = sample.dts - this._dtsBase;\n            let dts = originalDts - dtsCorrection;\n\n            if (firstDts === -1) {\n                firstDts = dts;\n            }\n\n            let sampleDuration = 0;\n\n            if (i !== samples.length - 1) {\n                let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {  // the last sample\n                if (lastSample != null) {  // use stashed sample's dts to calculate sample duration\n                    let nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n                    sampleDuration = nextDts - dts;\n                } else if (mp4Samples.length >= 1) {  // use second last sample duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else {  // the only one sample, use reference sample duration\n                    sampleDuration = Math.floor(refSampleDuration);\n                }\n            }\n\n            let needFillSilentFrames = false;\n            let silentFrames = null;\n\n            // Silent frame generation, if large timestamp gap detected && config.fixAudioTimestampGap\n            if (sampleDuration > refSampleDuration * 1.5 && this._audioMeta.codec !== 'mp3' && this._fillAudioTimestampGap && !Browser.safari) {\n                // We need to insert silent frames to fill timestamp gap\n                needFillSilentFrames = true;\n                let delta = Math.abs(sampleDuration - refSampleDuration);\n                let frameCount = Math.ceil(delta / refSampleDuration);\n                let currentDts = dts + refSampleDuration;  // Notice: in float\n\n                Log.w(this.TAG, 'Large audio timestamp gap detected, may cause AV sync to drift. ' +\n                                'Silent frames will be generated to avoid unsync.\\n' +\n                                `dts: ${dts + sampleDuration} ms, expected: ${dts + Math.round(refSampleDuration)} ms, ` +\n                                `delta: ${Math.round(delta)} ms, generate: ${frameCount} frames`);\n\n                let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n                if (silentUnit == null) {\n                    Log.w(this.TAG, 'Unable to generate silent frame for ' +\n                                    `${this._audioMeta.originalCodec} with ${this._audioMeta.channelCount} channels, repeat last frame`);\n                    // Repeat last frame\n                    silentUnit = unit;\n                }\n                silentFrames = [];\n\n                for (let j = 0; j < frameCount; j++) {\n                    let intDts = Math.round(currentDts);  // round to integer\n                    if (silentFrames.length > 0) {\n                        // Set previous frame sample duration\n                        let previousFrame = silentFrames[silentFrames.length - 1];\n                        previousFrame.duration = intDts - previousFrame.dts;\n                    }\n                    let frame = {\n                        dts: intDts,\n                        pts: intDts,\n                        cts: 0,\n                        unit: silentUnit,\n                        size: silentUnit.byteLength,\n                        duration: 0,  // wait for next sample\n                        originalDts: originalDts,\n                        flags: {\n                            isLeading: 0,\n                            dependsOn: 1,\n                            isDependedOn: 0,\n                            hasRedundancy: 0\n                        }\n                    };\n                    silentFrames.push(frame);\n                    mdatBytes += frame.size;\n                    currentDts += refSampleDuration;\n                }\n\n                // last frame: align end time to next frame dts\n                let lastFrame = silentFrames[silentFrames.length - 1];\n                lastFrame.duration = dts + sampleDuration - lastFrame.dts;\n\n                // silentFrames.forEach((frame) => {\n                //     Log.w(this.TAG, `SilentAudio: dts: ${frame.dts}, duration: ${frame.duration}`);\n                // });\n\n                // Set correct sample duration for current frame\n                sampleDuration = Math.round(refSampleDuration);\n            }\n\n            mp4Samples.push({\n                dts: dts,\n                pts: dts,\n                cts: 0,\n                unit: sample.unit,\n                size: sample.unit.byteLength,\n                duration: sampleDuration,\n                originalDts: originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: 1,\n                    isDependedOn: 0,\n                    hasRedundancy: 0\n                }\n            });\n\n            if (needFillSilentFrames) {\n                // Silent frames should be inserted after wrong-duration frame\n                mp4Samples.push.apply(mp4Samples, silentFrames);\n            }\n        }\n\n        // allocate mdatbox\n        if (mpegRawTrack) {\n            // allocate for raw mpeg buffer\n            mdatbox = new Uint8Array(mdatBytes);\n        } else {\n            // allocate for fmp4 mdat box\n            mdatbox = new Uint8Array(mdatBytes);\n            // size field\n            mdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n            mdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n            mdatbox[2] = (mdatBytes >>>  8) & 0xFF;\n            mdatbox[3] = (mdatBytes) & 0xFF;\n            // type field (fourCC)\n            mdatbox.set(MP4.types.mdat, 4);\n        }\n\n        // Write samples into mdatbox\n        for (let i = 0; i < mp4Samples.length; i++) {\n            let unit = mp4Samples[i].unit;\n            mdatbox.set(unit, offset);\n            offset += unit.byteLength;\n        }\n\n        let latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        this._audioNextDts = lastDts;\n\n        // fill media segment info & add to info list\n        let info = new MediaSegmentInfo();\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstDts;\n        info.endPts = lastDts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new SampleInfo(mp4Samples[0].dts,\n                                          mp4Samples[0].pts,\n                                          mp4Samples[0].duration,\n                                          mp4Samples[0].originalDts,\n                                          false);\n        info.lastSample = new SampleInfo(latest.dts,\n                                         latest.pts,\n                                         latest.duration,\n                                         latest.originalDts,\n                                         false);\n        if (!this._isLive) {\n            this._audioSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber++;\n\n        let moofbox = null;\n\n        if (mpegRawTrack) {\n            // Generate empty buffer, because useless for raw mpeg\n            moofbox = new Uint8Array();\n        } else {\n            // Generate moof for fmp4 segment\n            moofbox = MP4.moof(track, firstDts);\n        }\n\n        track.samples = [];\n        track.length = 0;\n\n        let segment = {\n            type: 'audio',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info: info\n        };\n\n        if (mpegRawTrack && firstSegmentAfterSeek) {\n            // For MPEG audio stream in MSE, if seeking occurred, before appending new buffer\n            // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n            segment.timestampOffset = firstDts;\n        }\n\n        this._onMediaSegment('audio', segment);\n    }\n\n    _remuxVideo(videoTrack, force) {\n        if (this._videoMeta == null) {\n            return;\n        }\n\n        let track = videoTrack;\n        let samples = track.samples;\n        let dtsCorrection = undefined;\n        let firstDts = -1, lastDts = -1;\n        let firstPts = -1, lastPts = -1;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n        if (samples.length === 1 && !force) {\n            // If [sample count in current batch] === 1 && (force != true)\n            // Ignore and keep in demuxer's queue\n            return;\n        }  // else if (force === true) do remux\n\n        let offset = 8;\n        let mdatbox = null;\n        let mdatBytes = 8 + videoTrack.length;\n\n\n        let lastSample = null;\n\n        // Pop the lastSample and waiting for stash\n        if (samples.length > 1) {\n            lastSample = samples.pop();\n            mdatBytes -= lastSample.length;\n        }\n\n        // Insert [stashed lastSample in the previous batch] to the front\n        if (this._videoStashedLastSample != null) {\n            let sample = this._videoStashedLastSample;\n            this._videoStashedLastSample = null;\n            samples.unshift(sample);\n            mdatBytes += sample.length;\n        }\n\n        // Stash the lastSample of current batch, waiting for next batch\n        if (lastSample != null) {\n            this._videoStashedLastSample = lastSample;\n        }\n\n\n        let firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n        // calculate dtsCorrection\n        if (this._videoNextDts) {\n            dtsCorrection = firstSampleOriginalDts - this._videoNextDts;\n        } else {  // this._videoNextDts == undefined\n            if (this._videoSegmentInfoList.isEmpty()) {\n                dtsCorrection = 0;\n            } else {\n                let lastSample = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n                if (lastSample != null) {\n                    let distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n                    if (distance <= 3) {\n                        distance = 0;\n                    }\n                    let expectedDts = lastSample.dts + lastSample.duration + distance;\n                    dtsCorrection = firstSampleOriginalDts - expectedDts;\n                } else { // lastSample == null, cannot found\n                    dtsCorrection = 0;\n                }\n            }\n        }\n\n        let info = new MediaSegmentInfo();\n        let mp4Samples = [];\n\n        // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n        for (let i = 0; i < samples.length; i++) {\n            let sample = samples[i];\n            let originalDts = sample.dts - this._dtsBase;\n            let isKeyframe = sample.isKeyframe;\n            let dts = originalDts - dtsCorrection;\n            let cts = sample.cts;\n            let pts = dts + cts;\n\n            if (firstDts === -1) {\n                firstDts = dts;\n                firstPts = pts;\n            }\n\n            let sampleDuration = 0;\n\n            if (i !== samples.length - 1) {\n                let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {  // the last sample\n                if (lastSample != null) {  // use stashed sample's dts to calculate sample duration\n                    let nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n                    sampleDuration = nextDts - dts;\n                } else if (mp4Samples.length >= 1) {  // use second last sample duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else {  // the only one sample, use reference sample duration\n                    sampleDuration = Math.floor(this._videoMeta.refSampleDuration);\n                }\n            }\n\n            if (isKeyframe) {\n                let syncPoint = new SampleInfo(dts, pts, sampleDuration, sample.dts, true);\n                syncPoint.fileposition = sample.fileposition;\n                info.appendSyncPoint(syncPoint);\n            }\n\n            mp4Samples.push({\n                dts: dts,\n                pts: pts,\n                cts: cts,\n                units: sample.units,\n                size: sample.length,\n                isKeyframe: isKeyframe,\n                duration: sampleDuration,\n                originalDts: originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: isKeyframe ? 2 : 1,\n                    isDependedOn: isKeyframe ? 1 : 0,\n                    hasRedundancy: 0,\n                    isNonSync: isKeyframe ? 0 : 1\n                }\n            });\n        }\n\n        // allocate mdatbox\n        mdatbox = new Uint8Array(mdatBytes);\n        mdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n        mdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n        mdatbox[2] = (mdatBytes >>>  8) & 0xFF;\n        mdatbox[3] = (mdatBytes) & 0xFF;\n        mdatbox.set(MP4.types.mdat, 4);\n\n        // Write samples into mdatbox\n        for (let i = 0; i < mp4Samples.length; i++) {\n            let units = mp4Samples[i].units;\n            while (units.length) {\n                let unit = units.shift();\n                let data = unit.data;\n                mdatbox.set(data, offset);\n                offset += data.byteLength;\n            }\n        }\n\n        let latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        lastPts = latest.pts + latest.duration;\n        this._videoNextDts = lastDts;\n\n        // fill media segment info & add to info list\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstPts;\n        info.endPts = lastPts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new SampleInfo(mp4Samples[0].dts,\n                                          mp4Samples[0].pts,\n                                          mp4Samples[0].duration,\n                                          mp4Samples[0].originalDts,\n                                          mp4Samples[0].isKeyframe);\n        info.lastSample = new SampleInfo(latest.dts,\n                                         latest.pts,\n                                         latest.duration,\n                                         latest.originalDts,\n                                         latest.isKeyframe);\n        if (!this._isLive) {\n            this._videoSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber++;\n\n        // workaround for chrome < 50: force first sample as a random access point\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        if (this._forceFirstIDR) {\n            let flags = mp4Samples[0].flags;\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n        }\n\n        let moofbox = MP4.moof(track, firstDts);\n        track.samples = [];\n        track.length = 0;\n\n        this._onMediaSegment('video', {\n            type: 'video',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info: info\n        });\n    }\n\n    _mergeBoxes(moof, mdat) {\n        let result = new Uint8Array(moof.byteLength + mdat.byteLength);\n        result.set(moof, 0);\n        result.set(mdat, moof.byteLength);\n        return result;\n    }\n\n}\n\nexport default MP4Remuxer;"]},"metadata":{},"sourceType":"module"}