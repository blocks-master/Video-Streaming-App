{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport decodeUTF8 from '../utils/utf8-conv.js';\nimport { IllegalStateException } from '../utils/exception.js';\n\nlet le = function () {\n  let buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nclass AMF {\n  static parseScriptData(arrayBuffer, dataOffset, dataSize) {\n    let data = {};\n\n    try {\n      let name = AMF.parseValue(arrayBuffer, dataOffset, dataSize);\n      let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n      data[name.data] = value.data;\n    } catch (e) {\n      Log.e('AMF', e.toString());\n    }\n\n    return data;\n  }\n\n  static parseObject(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 3) {\n      throw new IllegalStateException('Data not enough when parse ScriptDataObject');\n    }\n\n    let name = AMF.parseString(arrayBuffer, dataOffset, dataSize);\n    let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n    let isObjectEnd = value.objectEnd;\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      size: name.size + value.size,\n      objectEnd: isObjectEnd\n    };\n  }\n\n  static parseVariable(arrayBuffer, dataOffset, dataSize) {\n    return AMF.parseObject(arrayBuffer, dataOffset, dataSize);\n  }\n\n  static parseString(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 2) {\n      throw new IllegalStateException('Data not enough when parse String');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let length = v.getUint16(0, !le);\n    let str;\n\n    if (length > 0) {\n      str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n    } else {\n      str = '';\n    }\n\n    return {\n      data: str,\n      size: 2 + length\n    };\n  }\n\n  static parseLongString(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 4) {\n      throw new IllegalStateException('Data not enough when parse LongString');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let length = v.getUint32(0, !le);\n    let str;\n\n    if (length > 0) {\n      str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n    } else {\n      str = '';\n    }\n\n    return {\n      data: str,\n      size: 4 + length\n    };\n  }\n\n  static parseDate(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 10) {\n      throw new IllegalStateException('Data size invalid when parse Date');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let timestamp = v.getFloat64(0, !le);\n    let localTimeOffset = v.getInt16(8, !le);\n    timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n    return {\n      data: new Date(timestamp),\n      size: 8 + 2\n    };\n  }\n\n  static parseValue(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 1) {\n      throw new IllegalStateException('Data not enough when parse Value');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let offset = 1;\n    let type = v.getUint8(0);\n    let value;\n    let objectEnd = false;\n\n    try {\n      switch (type) {\n        case 0:\n          // Number(Double) type\n          value = v.getFloat64(1, !le);\n          offset += 8;\n          break;\n\n        case 1:\n          {\n            // Boolean type\n            let b = v.getUint8(1);\n            value = b ? true : false;\n            offset += 1;\n            break;\n          }\n\n        case 2:\n          {\n            // String type\n            let amfstr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n            value = amfstr.data;\n            offset += amfstr.size;\n            break;\n          }\n\n        case 3:\n          {\n            // Object(s) type\n            value = {};\n            let terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n\n            if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n              terminal = 3;\n            }\n\n            while (offset < dataSize - 4) {\n              // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n              let amfobj = AMF.parseObject(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n              if (amfobj.objectEnd) break;\n              value[amfobj.data.name] = amfobj.data.value;\n              offset += amfobj.size;\n            }\n\n            if (offset <= dataSize - 3) {\n              let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n\n              if (marker === 9) {\n                offset += 3;\n              }\n            }\n\n            break;\n          }\n\n        case 8:\n          {\n            // ECMA array type (Mixed array)\n            value = {};\n            offset += 4; // ECMAArrayLength(UI32)\n\n            let terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n\n            if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n              terminal = 3;\n            }\n\n            while (offset < dataSize - 8) {\n              // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n              let amfvar = AMF.parseVariable(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n              if (amfvar.objectEnd) break;\n              value[amfvar.data.name] = amfvar.data.value;\n              offset += amfvar.size;\n            }\n\n            if (offset <= dataSize - 3) {\n              let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n\n              if (marker === 9) {\n                offset += 3;\n              }\n            }\n\n            break;\n          }\n\n        case 9:\n          // ScriptDataObjectEnd\n          value = undefined;\n          offset = 1;\n          objectEnd = true;\n          break;\n\n        case 10:\n          {\n            // Strict array type\n            // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n            value = [];\n            let strictArrayLength = v.getUint32(1, !le);\n            offset += 4;\n\n            for (let i = 0; i < strictArrayLength; i++) {\n              let val = AMF.parseValue(arrayBuffer, dataOffset + offset, dataSize - offset);\n              value.push(val.data);\n              offset += val.size;\n            }\n\n            break;\n          }\n\n        case 11:\n          {\n            // Date type\n            let date = AMF.parseDate(arrayBuffer, dataOffset + 1, dataSize - 1);\n            value = date.data;\n            offset += date.size;\n            break;\n          }\n\n        case 12:\n          {\n            // Long string type\n            let amfLongStr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n            value = amfLongStr.data;\n            offset += amfLongStr.size;\n            break;\n          }\n\n        default:\n          // ignore and skip\n          offset = dataSize;\n          Log.w('AMF', 'Unsupported AMF value type ' + type);\n      }\n    } catch (e) {\n      Log.e('AMF', e.toString());\n    }\n\n    return {\n      data: value,\n      size: offset,\n      objectEnd: objectEnd\n    };\n  }\n\n}\n\nexport default AMF;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/demux/amf-parser.js"],"names":["Log","decodeUTF8","IllegalStateException","le","buf","ArrayBuffer","DataView","setInt16","Int16Array","AMF","parseScriptData","arrayBuffer","dataOffset","dataSize","data","name","parseValue","value","size","e","toString","parseObject","parseString","isObjectEnd","objectEnd","parseVariable","v","length","getUint16","str","Uint8Array","parseLongString","getUint32","parseDate","timestamp","getFloat64","localTimeOffset","getInt16","Date","offset","type","getUint8","b","amfstr","terminal","amfobj","marker","amfvar","undefined","strictArrayLength","i","val","push","date","amfLongStr","w"],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAkBA,OAAOA,GAAP,MAAgB,oBAAhB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,SAAQC,qBAAR,QAAoC,uBAApC;;AAEA,IAAIC,EAAE,GAAI,YAAY;AAClB,MAAIC,GAAG,GAAG,IAAIC,WAAJ,CAAgB,CAAhB,CAAV;AACC,MAAIC,QAAJ,CAAaF,GAAb,CAAD,CAAoBG,QAApB,CAA6B,CAA7B,EAAgC,GAAhC,EAAqC,IAArC,EAFkB,CAE2B;;AAC7C,SAAQ,IAAIC,UAAJ,CAAeJ,GAAf,CAAD,CAAsB,CAAtB,MAA6B,GAApC,CAHkB,CAGwB;AAC7C,CAJQ,EAAT;;AAMA,MAAMK,GAAN,CAAU;AAEN,SAAOC,eAAP,CAAuBC,WAAvB,EAAoCC,UAApC,EAAgDC,QAAhD,EAA0D;AACtD,QAAIC,IAAI,GAAG,EAAX;;AAEA,QAAI;AACA,UAAIC,IAAI,GAAGN,GAAG,CAACO,UAAJ,CAAeL,WAAf,EAA4BC,UAA5B,EAAwCC,QAAxC,CAAX;AACA,UAAII,KAAK,GAAGR,GAAG,CAACO,UAAJ,CAAeL,WAAf,EAA4BC,UAAU,GAAGG,IAAI,CAACG,IAA9C,EAAoDL,QAAQ,GAAGE,IAAI,CAACG,IAApE,CAAZ;AAEAJ,MAAAA,IAAI,CAACC,IAAI,CAACD,IAAN,CAAJ,GAAkBG,KAAK,CAACH,IAAxB;AACH,KALD,CAKE,OAAOK,CAAP,EAAU;AACRnB,MAAAA,GAAG,CAACmB,CAAJ,CAAM,KAAN,EAAaA,CAAC,CAACC,QAAF,EAAb;AACH;;AAED,WAAON,IAAP;AACH;;AAED,SAAOO,WAAP,CAAmBV,WAAnB,EAAgCC,UAAhC,EAA4CC,QAA5C,EAAsD;AAClD,QAAIA,QAAQ,GAAG,CAAf,EAAkB;AACd,YAAM,IAAIX,qBAAJ,CAA0B,6CAA1B,CAAN;AACH;;AACD,QAAIa,IAAI,GAAGN,GAAG,CAACa,WAAJ,CAAgBX,WAAhB,EAA6BC,UAA7B,EAAyCC,QAAzC,CAAX;AACA,QAAII,KAAK,GAAGR,GAAG,CAACO,UAAJ,CAAeL,WAAf,EAA4BC,UAAU,GAAGG,IAAI,CAACG,IAA9C,EAAoDL,QAAQ,GAAGE,IAAI,CAACG,IAApE,CAAZ;AACA,QAAIK,WAAW,GAAGN,KAAK,CAACO,SAAxB;AAEA,WAAO;AACHV,MAAAA,IAAI,EAAE;AACFC,QAAAA,IAAI,EAAEA,IAAI,CAACD,IADT;AAEFG,QAAAA,KAAK,EAAEA,KAAK,CAACH;AAFX,OADH;AAKHI,MAAAA,IAAI,EAAEH,IAAI,CAACG,IAAL,GAAYD,KAAK,CAACC,IALrB;AAMHM,MAAAA,SAAS,EAAED;AANR,KAAP;AAQH;;AAED,SAAOE,aAAP,CAAqBd,WAArB,EAAkCC,UAAlC,EAA8CC,QAA9C,EAAwD;AACpD,WAAOJ,GAAG,CAACY,WAAJ,CAAgBV,WAAhB,EAA6BC,UAA7B,EAAyCC,QAAzC,CAAP;AACH;;AAED,SAAOS,WAAP,CAAmBX,WAAnB,EAAgCC,UAAhC,EAA4CC,QAA5C,EAAsD;AAClD,QAAIA,QAAQ,GAAG,CAAf,EAAkB;AACd,YAAM,IAAIX,qBAAJ,CAA0B,mCAA1B,CAAN;AACH;;AACD,QAAIwB,CAAC,GAAG,IAAIpB,QAAJ,CAAaK,WAAb,EAA0BC,UAA1B,EAAsCC,QAAtC,CAAR;AACA,QAAIc,MAAM,GAAGD,CAAC,CAACE,SAAF,CAAY,CAAZ,EAAe,CAACzB,EAAhB,CAAb;AAEA,QAAI0B,GAAJ;;AACA,QAAIF,MAAM,GAAG,CAAb,EAAgB;AACZE,MAAAA,GAAG,GAAG5B,UAAU,CAAC,IAAI6B,UAAJ,CAAenB,WAAf,EAA4BC,UAAU,GAAG,CAAzC,EAA4Ce,MAA5C,CAAD,CAAhB;AACH,KAFD,MAEO;AACHE,MAAAA,GAAG,GAAG,EAAN;AACH;;AAED,WAAO;AACHf,MAAAA,IAAI,EAAEe,GADH;AAEHX,MAAAA,IAAI,EAAE,IAAIS;AAFP,KAAP;AAIH;;AAED,SAAOI,eAAP,CAAuBpB,WAAvB,EAAoCC,UAApC,EAAgDC,QAAhD,EAA0D;AACtD,QAAIA,QAAQ,GAAG,CAAf,EAAkB;AACd,YAAM,IAAIX,qBAAJ,CAA0B,uCAA1B,CAAN;AACH;;AACD,QAAIwB,CAAC,GAAG,IAAIpB,QAAJ,CAAaK,WAAb,EAA0BC,UAA1B,EAAsCC,QAAtC,CAAR;AACA,QAAIc,MAAM,GAAGD,CAAC,CAACM,SAAF,CAAY,CAAZ,EAAe,CAAC7B,EAAhB,CAAb;AAEA,QAAI0B,GAAJ;;AACA,QAAIF,MAAM,GAAG,CAAb,EAAgB;AACZE,MAAAA,GAAG,GAAG5B,UAAU,CAAC,IAAI6B,UAAJ,CAAenB,WAAf,EAA4BC,UAAU,GAAG,CAAzC,EAA4Ce,MAA5C,CAAD,CAAhB;AACH,KAFD,MAEO;AACHE,MAAAA,GAAG,GAAG,EAAN;AACH;;AAED,WAAO;AACHf,MAAAA,IAAI,EAAEe,GADH;AAEHX,MAAAA,IAAI,EAAE,IAAIS;AAFP,KAAP;AAIH;;AAED,SAAOM,SAAP,CAAiBtB,WAAjB,EAA8BC,UAA9B,EAA0CC,QAA1C,EAAoD;AAChD,QAAIA,QAAQ,GAAG,EAAf,EAAmB;AACf,YAAM,IAAIX,qBAAJ,CAA0B,mCAA1B,CAAN;AACH;;AACD,QAAIwB,CAAC,GAAG,IAAIpB,QAAJ,CAAaK,WAAb,EAA0BC,UAA1B,EAAsCC,QAAtC,CAAR;AACA,QAAIqB,SAAS,GAAGR,CAAC,CAACS,UAAF,CAAa,CAAb,EAAgB,CAAChC,EAAjB,CAAhB;AACA,QAAIiC,eAAe,GAAGV,CAAC,CAACW,QAAF,CAAW,CAAX,EAAc,CAAClC,EAAf,CAAtB;AACA+B,IAAAA,SAAS,IAAIE,eAAe,GAAG,EAAlB,GAAuB,IAApC,CAPgD,CAOL;;AAE3C,WAAO;AACHtB,MAAAA,IAAI,EAAE,IAAIwB,IAAJ,CAASJ,SAAT,CADH;AAEHhB,MAAAA,IAAI,EAAE,IAAI;AAFP,KAAP;AAIH;;AAED,SAAOF,UAAP,CAAkBL,WAAlB,EAA+BC,UAA/B,EAA2CC,QAA3C,EAAqD;AACjD,QAAIA,QAAQ,GAAG,CAAf,EAAkB;AACd,YAAM,IAAIX,qBAAJ,CAA0B,kCAA1B,CAAN;AACH;;AAED,QAAIwB,CAAC,GAAG,IAAIpB,QAAJ,CAAaK,WAAb,EAA0BC,UAA1B,EAAsCC,QAAtC,CAAR;AAEA,QAAI0B,MAAM,GAAG,CAAb;AACA,QAAIC,IAAI,GAAGd,CAAC,CAACe,QAAF,CAAW,CAAX,CAAX;AACA,QAAIxB,KAAJ;AACA,QAAIO,SAAS,GAAG,KAAhB;;AAEA,QAAI;AACA,cAAQgB,IAAR;AACI,aAAK,CAAL;AAAS;AACLvB,UAAAA,KAAK,GAAGS,CAAC,CAACS,UAAF,CAAa,CAAb,EAAgB,CAAChC,EAAjB,CAAR;AACAoC,UAAAA,MAAM,IAAI,CAAV;AACA;;AACJ,aAAK,CAAL;AAAQ;AAAG;AACP,gBAAIG,CAAC,GAAGhB,CAAC,CAACe,QAAF,CAAW,CAAX,CAAR;AACAxB,YAAAA,KAAK,GAAGyB,CAAC,GAAG,IAAH,GAAU,KAAnB;AACAH,YAAAA,MAAM,IAAI,CAAV;AACA;AACH;;AACD,aAAK,CAAL;AAAQ;AAAG;AACP,gBAAII,MAAM,GAAGlC,GAAG,CAACa,WAAJ,CAAgBX,WAAhB,EAA6BC,UAAU,GAAG,CAA1C,EAA6CC,QAAQ,GAAG,CAAxD,CAAb;AACAI,YAAAA,KAAK,GAAG0B,MAAM,CAAC7B,IAAf;AACAyB,YAAAA,MAAM,IAAII,MAAM,CAACzB,IAAjB;AACA;AACH;;AACD,aAAK,CAAL;AAAQ;AAAE;AACND,YAAAA,KAAK,GAAG,EAAR;AACA,gBAAI2B,QAAQ,GAAG,CAAf,CAFI,CAEe;;AACnB,gBAAI,CAAClB,CAAC,CAACM,SAAF,CAAYnB,QAAQ,GAAG,CAAvB,EAA0B,CAACV,EAA3B,IAAiC,UAAlC,MAAkD,CAAtD,EAAyD;AACrDyC,cAAAA,QAAQ,GAAG,CAAX;AACH;;AACD,mBAAOL,MAAM,GAAG1B,QAAQ,GAAG,CAA3B,EAA8B;AAAG;AAC7B,kBAAIgC,MAAM,GAAGpC,GAAG,CAACY,WAAJ,CAAgBV,WAAhB,EAA6BC,UAAU,GAAG2B,MAA1C,EAAkD1B,QAAQ,GAAG0B,MAAX,GAAoBK,QAAtE,CAAb;AACA,kBAAIC,MAAM,CAACrB,SAAX,EACI;AACJP,cAAAA,KAAK,CAAC4B,MAAM,CAAC/B,IAAP,CAAYC,IAAb,CAAL,GAA0B8B,MAAM,CAAC/B,IAAP,CAAYG,KAAtC;AACAsB,cAAAA,MAAM,IAAIM,MAAM,CAAC3B,IAAjB;AACH;;AACD,gBAAIqB,MAAM,IAAI1B,QAAQ,GAAG,CAAzB,EAA4B;AACxB,kBAAIiC,MAAM,GAAGpB,CAAC,CAACM,SAAF,CAAYO,MAAM,GAAG,CAArB,EAAwB,CAACpC,EAAzB,IAA+B,UAA5C;;AACA,kBAAI2C,MAAM,KAAK,CAAf,EAAkB;AACdP,gBAAAA,MAAM,IAAI,CAAV;AACH;AACJ;;AACD;AACH;;AACD,aAAK,CAAL;AAAQ;AAAE;AACNtB,YAAAA,KAAK,GAAG,EAAR;AACAsB,YAAAA,MAAM,IAAI,CAAV,CAFI,CAEU;;AACd,gBAAIK,QAAQ,GAAG,CAAf,CAHI,CAGe;;AACnB,gBAAI,CAAClB,CAAC,CAACM,SAAF,CAAYnB,QAAQ,GAAG,CAAvB,EAA0B,CAACV,EAA3B,IAAiC,UAAlC,MAAkD,CAAtD,EAAyD;AACrDyC,cAAAA,QAAQ,GAAG,CAAX;AACH;;AACD,mBAAOL,MAAM,GAAG1B,QAAQ,GAAG,CAA3B,EAA8B;AAAG;AAC7B,kBAAIkC,MAAM,GAAGtC,GAAG,CAACgB,aAAJ,CAAkBd,WAAlB,EAA+BC,UAAU,GAAG2B,MAA5C,EAAoD1B,QAAQ,GAAG0B,MAAX,GAAoBK,QAAxE,CAAb;AACA,kBAAIG,MAAM,CAACvB,SAAX,EACI;AACJP,cAAAA,KAAK,CAAC8B,MAAM,CAACjC,IAAP,CAAYC,IAAb,CAAL,GAA0BgC,MAAM,CAACjC,IAAP,CAAYG,KAAtC;AACAsB,cAAAA,MAAM,IAAIQ,MAAM,CAAC7B,IAAjB;AACH;;AACD,gBAAIqB,MAAM,IAAI1B,QAAQ,GAAG,CAAzB,EAA4B;AACxB,kBAAIiC,MAAM,GAAGpB,CAAC,CAACM,SAAF,CAAYO,MAAM,GAAG,CAArB,EAAwB,CAACpC,EAAzB,IAA+B,UAA5C;;AACA,kBAAI2C,MAAM,KAAK,CAAf,EAAkB;AACdP,gBAAAA,MAAM,IAAI,CAAV;AACH;AACJ;;AACD;AACH;;AACD,aAAK,CAAL;AAAS;AACLtB,UAAAA,KAAK,GAAG+B,SAAR;AACAT,UAAAA,MAAM,GAAG,CAAT;AACAf,UAAAA,SAAS,GAAG,IAAZ;AACA;;AACJ,aAAK,EAAL;AAAS;AAAG;AACR;AACAP,YAAAA,KAAK,GAAG,EAAR;AACA,gBAAIgC,iBAAiB,GAAGvB,CAAC,CAACM,SAAF,CAAY,CAAZ,EAAe,CAAC7B,EAAhB,CAAxB;AACAoC,YAAAA,MAAM,IAAI,CAAV;;AACA,iBAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,iBAApB,EAAuCC,CAAC,EAAxC,EAA4C;AACxC,kBAAIC,GAAG,GAAG1C,GAAG,CAACO,UAAJ,CAAeL,WAAf,EAA4BC,UAAU,GAAG2B,MAAzC,EAAiD1B,QAAQ,GAAG0B,MAA5D,CAAV;AACAtB,cAAAA,KAAK,CAACmC,IAAN,CAAWD,GAAG,CAACrC,IAAf;AACAyB,cAAAA,MAAM,IAAIY,GAAG,CAACjC,IAAd;AACH;;AACD;AACH;;AACD,aAAK,EAAL;AAAS;AAAG;AACR,gBAAImC,IAAI,GAAG5C,GAAG,CAACwB,SAAJ,CAActB,WAAd,EAA2BC,UAAU,GAAG,CAAxC,EAA2CC,QAAQ,GAAG,CAAtD,CAAX;AACAI,YAAAA,KAAK,GAAGoC,IAAI,CAACvC,IAAb;AACAyB,YAAAA,MAAM,IAAIc,IAAI,CAACnC,IAAf;AACA;AACH;;AACD,aAAK,EAAL;AAAS;AAAG;AACR,gBAAIoC,UAAU,GAAG7C,GAAG,CAACa,WAAJ,CAAgBX,WAAhB,EAA6BC,UAAU,GAAG,CAA1C,EAA6CC,QAAQ,GAAG,CAAxD,CAAjB;AACAI,YAAAA,KAAK,GAAGqC,UAAU,CAACxC,IAAnB;AACAyB,YAAAA,MAAM,IAAIe,UAAU,CAACpC,IAArB;AACA;AACH;;AACD;AACI;AACAqB,UAAAA,MAAM,GAAG1B,QAAT;AACAb,UAAAA,GAAG,CAACuD,CAAJ,CAAM,KAAN,EAAa,gCAAgCf,IAA7C;AA5FR;AA8FH,KA/FD,CA+FE,OAAOrB,CAAP,EAAU;AACRnB,MAAAA,GAAG,CAACmB,CAAJ,CAAM,KAAN,EAAaA,CAAC,CAACC,QAAF,EAAb;AACH;;AAED,WAAO;AACHN,MAAAA,IAAI,EAAEG,KADH;AAEHC,MAAAA,IAAI,EAAEqB,MAFH;AAGHf,MAAAA,SAAS,EAAEA;AAHR,KAAP;AAKH;;AAlNK;;AAsNV,eAAef,GAAf","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport decodeUTF8 from '../utils/utf8-conv.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\nlet le = (function () {\n    let buf = new ArrayBuffer(2);\n    (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\n    return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\n})();\n\nclass AMF {\n\n    static parseScriptData(arrayBuffer, dataOffset, dataSize) {\n        let data = {};\n\n        try {\n            let name = AMF.parseValue(arrayBuffer, dataOffset, dataSize);\n            let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n\n            data[name.data] = value.data;\n        } catch (e) {\n            Log.e('AMF', e.toString());\n        }\n\n        return data;\n    }\n\n    static parseObject(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 3) {\n            throw new IllegalStateException('Data not enough when parse ScriptDataObject');\n        }\n        let name = AMF.parseString(arrayBuffer, dataOffset, dataSize);\n        let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n        let isObjectEnd = value.objectEnd;\n\n        return {\n            data: {\n                name: name.data,\n                value: value.data\n            },\n            size: name.size + value.size,\n            objectEnd: isObjectEnd\n        };\n    }\n\n    static parseVariable(arrayBuffer, dataOffset, dataSize) {\n        return AMF.parseObject(arrayBuffer, dataOffset, dataSize);\n    }\n\n    static parseString(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 2) {\n            throw new IllegalStateException('Data not enough when parse String');\n        }\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n        let length = v.getUint16(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 2 + length\n        };\n    }\n\n    static parseLongString(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 4) {\n            throw new IllegalStateException('Data not enough when parse LongString');\n        }\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n        let length = v.getUint32(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 4 + length\n        };\n    }\n\n    static parseDate(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 10) {\n            throw new IllegalStateException('Data size invalid when parse Date');\n        }\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n        let timestamp = v.getFloat64(0, !le);\n        let localTimeOffset = v.getInt16(8, !le);\n        timestamp += localTimeOffset * 60 * 1000;  // get UTC time\n\n        return {\n            data: new Date(timestamp),\n            size: 8 + 2\n        };\n    }\n\n    static parseValue(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 1) {\n            throw new IllegalStateException('Data not enough when parse Value');\n        }\n\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let offset = 1;\n        let type = v.getUint8(0);\n        let value;\n        let objectEnd = false;\n\n        try {\n            switch (type) {\n                case 0:  // Number(Double) type\n                    value = v.getFloat64(1, !le);\n                    offset += 8;\n                    break;\n                case 1: {  // Boolean type\n                    let b = v.getUint8(1);\n                    value = b ? true : false;\n                    offset += 1;\n                    break;\n                }\n                case 2: {  // String type\n                    let amfstr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n                    value = amfstr.data;\n                    offset += amfstr.size;\n                    break;\n                }\n                case 3: { // Object(s) type\n                    value = {};\n                    let terminal = 0;  // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                    if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (offset < dataSize - 4) {  // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                        let amfobj = AMF.parseObject(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n                        if (amfobj.objectEnd)\n                            break;\n                        value[amfobj.data.name] = amfobj.data.value;\n                        offset += amfobj.size;\n                    }\n                    if (offset <= dataSize - 3) {\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            offset += 3;\n                        }\n                    }\n                    break;\n                }\n                case 8: { // ECMA array type (Mixed array)\n                    value = {};\n                    offset += 4;  // ECMAArrayLength(UI32)\n                    let terminal = 0;  // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                    if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (offset < dataSize - 8) {  // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                        let amfvar = AMF.parseVariable(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n                        if (amfvar.objectEnd)\n                            break;\n                        value[amfvar.data.name] = amfvar.data.value;\n                        offset += amfvar.size;\n                    }\n                    if (offset <= dataSize - 3) {\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            offset += 3;\n                        }\n                    }\n                    break;\n                }\n                case 9:  // ScriptDataObjectEnd\n                    value = undefined;\n                    offset = 1;\n                    objectEnd = true;\n                    break;\n                case 10: {  // Strict array type\n                    // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                    value = [];\n                    let strictArrayLength = v.getUint32(1, !le);\n                    offset += 4;\n                    for (let i = 0; i < strictArrayLength; i++) {\n                        let val = AMF.parseValue(arrayBuffer, dataOffset + offset, dataSize - offset);\n                        value.push(val.data);\n                        offset += val.size;\n                    }\n                    break;\n                }\n                case 11: {  // Date type\n                    let date = AMF.parseDate(arrayBuffer, dataOffset + 1, dataSize - 1);\n                    value = date.data;\n                    offset += date.size;\n                    break;\n                }\n                case 12: {  // Long string type\n                    let amfLongStr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n                    value = amfLongStr.data;\n                    offset += amfLongStr.size;\n                    break;\n                }\n                default:\n                    // ignore and skip\n                    offset = dataSize;\n                    Log.w('AMF', 'Unsupported AMF value type ' + type);\n            }\n        } catch (e) {\n            Log.e('AMF', e.toString());\n        }\n\n        return {\n            data: value,\n            size: offset,\n            objectEnd: objectEnd\n        };\n    }\n\n}\n\nexport default AMF;"]},"metadata":{},"sourceType":"module"}