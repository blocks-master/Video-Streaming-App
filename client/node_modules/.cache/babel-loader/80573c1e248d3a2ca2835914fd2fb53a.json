{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Represents an media sample (audio / video)\nexport class SampleInfo {\n  constructor(dts, pts, duration, originalDts, isSync) {\n    this.dts = dts;\n    this.pts = pts;\n    this.duration = duration;\n    this.originalDts = originalDts;\n    this.isSyncPoint = isSync;\n    this.fileposition = null;\n  }\n\n} // Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\n\nexport class MediaSegmentInfo {\n  constructor() {\n    this.beginDts = 0;\n    this.endDts = 0;\n    this.beginPts = 0;\n    this.endPts = 0;\n    this.originalBeginDts = 0;\n    this.originalEndDts = 0;\n    this.syncPoints = []; // SampleInfo[n], for video IDR frames only\n\n    this.firstSample = null; // SampleInfo\n\n    this.lastSample = null; // SampleInfo\n  }\n\n  appendSyncPoint(sampleInfo) {\n    // also called Random Access Point\n    sampleInfo.isSyncPoint = true;\n    this.syncPoints.push(sampleInfo);\n  }\n\n} // Ordered list for recording video IDR frames, sorted by originalDts\n\nexport class IDRSampleList {\n  constructor() {\n    this._list = [];\n  }\n\n  clear() {\n    this._list = [];\n  }\n\n  appendArray(syncPoints) {\n    let list = this._list;\n\n    if (syncPoints.length === 0) {\n      return;\n    }\n\n    if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n      this.clear();\n    }\n\n    Array.prototype.push.apply(list, syncPoints);\n  }\n\n  getLastSyncPointBeforeDts(dts) {\n    if (this._list.length == 0) {\n      return null;\n    }\n\n    let list = this._list;\n    let idx = 0;\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n\n    if (dts < list[0].dts) {\n      idx = 0;\n      lbound = ubound + 1;\n    }\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || dts >= list[mid].dts && dts < list[mid + 1].dts) {\n        idx = mid;\n        break;\n      } else if (list[mid].dts < dts) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n\n    return this._list[idx];\n  }\n\n} // Data structure for recording information of media segments in single track.\n\nexport class MediaSegmentInfoList {\n  constructor(type) {\n    this._type = type;\n    this._list = [];\n    this._lastAppendLocation = -1; // cached last insert location\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get length() {\n    return this._list.length;\n  }\n\n  isEmpty() {\n    return this._list.length === 0;\n  }\n\n  clear() {\n    this._list = [];\n    this._lastAppendLocation = -1;\n  }\n\n  _searchNearestSegmentBefore(originalBeginDts) {\n    let list = this._list;\n\n    if (list.length === 0) {\n      return -2;\n    }\n\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n    let idx = 0;\n\n    if (originalBeginDts < list[0].originalBeginDts) {\n      idx = -1;\n      return idx;\n    }\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || originalBeginDts > list[mid].lastSample.originalDts && originalBeginDts < list[mid + 1].originalBeginDts) {\n        idx = mid;\n        break;\n      } else if (list[mid].originalBeginDts < originalBeginDts) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n\n    return idx;\n  }\n\n  _searchNearestSegmentAfter(originalBeginDts) {\n    return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n  }\n\n  append(mediaSegmentInfo) {\n    let list = this._list;\n    let msi = mediaSegmentInfo;\n    let lastAppendIdx = this._lastAppendLocation;\n    let insertIdx = 0;\n\n    if (lastAppendIdx !== -1 && lastAppendIdx < list.length && msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts)) {\n      insertIdx = lastAppendIdx + 1; // use cached location idx\n    } else {\n      if (list.length > 0) {\n        insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n      }\n    }\n\n    this._lastAppendLocation = insertIdx;\n\n    this._list.splice(insertIdx, 0, msi);\n  }\n\n  getLastSegmentBefore(originalBeginDts) {\n    let idx = this._searchNearestSegmentBefore(originalBeginDts);\n\n    if (idx >= 0) {\n      return this._list[idx];\n    } else {\n      // -1\n      return null;\n    }\n  }\n\n  getLastSampleBefore(originalBeginDts) {\n    let segment = this.getLastSegmentBefore(originalBeginDts);\n\n    if (segment != null) {\n      return segment.lastSample;\n    } else {\n      return null;\n    }\n  }\n\n  getLastSyncPointBefore(originalBeginDts) {\n    let segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n\n    let syncPoints = this._list[segmentIdx].syncPoints;\n\n    while (syncPoints.length === 0 && segmentIdx > 0) {\n      segmentIdx--;\n      syncPoints = this._list[segmentIdx].syncPoints;\n    }\n\n    if (syncPoints.length > 0) {\n      return syncPoints[syncPoints.length - 1];\n    } else {\n      return null;\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/core/media-segment-info.js"],"names":["SampleInfo","constructor","dts","pts","duration","originalDts","isSync","isSyncPoint","fileposition","MediaSegmentInfo","beginDts","endDts","beginPts","endPts","originalBeginDts","originalEndDts","syncPoints","firstSample","lastSample","appendSyncPoint","sampleInfo","push","IDRSampleList","_list","clear","appendArray","list","length","Array","prototype","apply","getLastSyncPointBeforeDts","idx","last","mid","lbound","ubound","Math","floor","MediaSegmentInfoList","type","_type","_lastAppendLocation","isEmpty","_searchNearestSegmentBefore","_searchNearestSegmentAfter","append","mediaSegmentInfo","msi","lastAppendIdx","insertIdx","splice","getLastSegmentBefore","getLastSampleBefore","segment","getLastSyncPointBefore","segmentIdx"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Represents an media sample (audio / video)\nexport class SampleInfo {\n\n    constructor(dts, pts, duration, originalDts, isSync) {\n        this.dts = dts;\n        this.pts = pts;\n        this.duration = duration;\n        this.originalDts = originalDts;\n        this.isSyncPoint = isSync;\n        this.fileposition = null;\n    }\n\n}\n\n// Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\nexport class MediaSegmentInfo {\n\n    constructor() {\n        this.beginDts = 0;\n        this.endDts = 0;\n        this.beginPts = 0;\n        this.endPts = 0;\n        this.originalBeginDts = 0;\n        this.originalEndDts = 0;\n        this.syncPoints = [];     // SampleInfo[n], for video IDR frames only\n        this.firstSample = null;  // SampleInfo\n        this.lastSample = null;   // SampleInfo\n    }\n\n    appendSyncPoint(sampleInfo) {  // also called Random Access Point\n        sampleInfo.isSyncPoint = true;\n        this.syncPoints.push(sampleInfo);\n    }\n\n}\n\n// Ordered list for recording video IDR frames, sorted by originalDts\nexport class IDRSampleList {\n\n    constructor() {\n        this._list = [];\n    }\n\n    clear() {\n        this._list = [];\n    }\n\n    appendArray(syncPoints) {\n        let list = this._list;\n\n        if (syncPoints.length === 0) {\n            return;\n        }\n\n        if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n            this.clear();\n        }\n\n        Array.prototype.push.apply(list, syncPoints);\n    }\n\n    getLastSyncPointBeforeDts(dts) {\n        if (this._list.length == 0) {\n            return null;\n        }\n\n        let list = this._list;\n        let idx = 0;\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (dts < list[0].dts) {\n            idx = 0;\n            lbound = ubound + 1;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (dts >= list[mid].dts && dts < list[mid + 1].dts)) {\n                idx = mid;\n                break;\n            } else if (list[mid].dts < dts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return this._list[idx];\n    }\n\n}\n\n// Data structure for recording information of media segments in single track.\nexport class MediaSegmentInfoList {\n\n    constructor(type) {\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1;  // cached last insert location\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get length() {\n        return this._list.length;\n    }\n\n    isEmpty() {\n        return this._list.length === 0;\n    }\n\n    clear() {\n        this._list = [];\n        this._lastAppendLocation = -1;\n    }\n\n    _searchNearestSegmentBefore(originalBeginDts) {\n        let list = this._list;\n        if (list.length === 0) {\n            return -2;\n        }\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        let idx = 0;\n\n        if (originalBeginDts < list[0].originalBeginDts) {\n            idx = -1;\n            return idx;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\n                                (originalBeginDts < list[mid + 1].originalBeginDts))) {\n                idx = mid;\n                break;\n            } else if (list[mid].originalBeginDts < originalBeginDts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    _searchNearestSegmentAfter(originalBeginDts) {\n        return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n    }\n\n    append(mediaSegmentInfo) {\n        let list = this._list;\n        let msi = mediaSegmentInfo;\n        let lastAppendIdx = this._lastAppendLocation;\n        let insertIdx = 0;\n\n        if (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\n                                    msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\n                                    ((lastAppendIdx === list.length - 1) ||\n                                    (lastAppendIdx < list.length - 1 &&\n                                    msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\n            insertIdx = lastAppendIdx + 1;  // use cached location idx\n        } else {\n            if (list.length > 0) {\n                insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n            }\n        }\n\n        this._lastAppendLocation = insertIdx;\n        this._list.splice(insertIdx, 0, msi);\n    }\n\n    getLastSegmentBefore(originalBeginDts) {\n        let idx = this._searchNearestSegmentBefore(originalBeginDts);\n        if (idx >= 0) {\n            return this._list[idx];\n        } else {  // -1\n            return null;\n        }\n    }\n\n    getLastSampleBefore(originalBeginDts) {\n        let segment = this.getLastSegmentBefore(originalBeginDts);\n        if (segment != null) {\n            return segment.lastSample;\n        } else {\n            return null;\n        }\n    }\n\n    getLastSyncPointBefore(originalBeginDts) {\n        let segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n        let syncPoints = this._list[segmentIdx].syncPoints;\n        while (syncPoints.length === 0 && segmentIdx > 0) {\n            segmentIdx--;\n            syncPoints = this._list[segmentIdx].syncPoints;\n        }\n        if (syncPoints.length > 0) {\n            return syncPoints[syncPoints.length - 1];\n        } else {\n            return null;\n        }\n    }\n\n}"]},"metadata":{},"sourceType":"module"}