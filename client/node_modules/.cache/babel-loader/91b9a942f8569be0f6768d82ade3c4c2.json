{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js'; // For FLV over WebSocket live stream\n\nclass WebSocketLoader extends BaseLoader {\n  static isSupported() {\n    try {\n      return typeof self.WebSocket !== 'undefined';\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor() {\n    super('websocket-loader');\n    this.TAG = 'WebSocketLoader';\n    this._needStash = true;\n    this._ws = null;\n    this._requestAbort = false;\n    this._receivedLength = 0;\n  }\n\n  destroy() {\n    if (this._ws) {\n      this.abort();\n    }\n\n    super.destroy();\n  }\n\n  open(dataSource) {\n    try {\n      let ws = this._ws = new self.WebSocket(dataSource.url);\n      ws.binaryType = 'arraybuffer';\n      ws.onopen = this._onWebSocketOpen.bind(this);\n      ws.onclose = this._onWebSocketClose.bind(this);\n      ws.onmessage = this._onWebSocketMessage.bind(this);\n      ws.onerror = this._onWebSocketError.bind(this);\n      this._status = LoaderStatus.kConnecting;\n    } catch (e) {\n      this._status = LoaderStatus.kError;\n      let info = {\n        code: e.code,\n        msg: e.message\n      };\n\n      if (this._onError) {\n        this._onError(LoaderErrors.EXCEPTION, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }\n\n  abort() {\n    let ws = this._ws;\n\n    if (ws && (ws.readyState === 0 || ws.readyState === 1)) {\n      // CONNECTING || OPEN\n      this._requestAbort = true;\n      ws.close();\n    }\n\n    this._ws = null;\n    this._status = LoaderStatus.kComplete;\n  }\n\n  _onWebSocketOpen(e) {\n    this._status = LoaderStatus.kBuffering;\n  }\n\n  _onWebSocketClose(e) {\n    if (this._requestAbort === true) {\n      this._requestAbort = false;\n      return;\n    }\n\n    this._status = LoaderStatus.kComplete;\n\n    if (this._onComplete) {\n      this._onComplete(0, this._receivedLength - 1);\n    }\n  }\n\n  _onWebSocketMessage(e) {\n    if (e.data instanceof ArrayBuffer) {\n      this._dispatchArrayBuffer(e.data);\n    } else if (e.data instanceof Blob) {\n      let reader = new FileReader();\n\n      reader.onload = () => {\n        this._dispatchArrayBuffer(reader.result);\n      };\n\n      reader.readAsArrayBuffer(e.data);\n    } else {\n      this._status = LoaderStatus.kError;\n      let info = {\n        code: -1,\n        msg: 'Unsupported WebSocket message type: ' + e.data.constructor.name\n      };\n\n      if (this._onError) {\n        this._onError(LoaderErrors.EXCEPTION, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }\n\n  _dispatchArrayBuffer(arraybuffer) {\n    let chunk = arraybuffer;\n    let byteStart = this._receivedLength;\n    this._receivedLength += chunk.byteLength;\n\n    if (this._onDataArrival) {\n      this._onDataArrival(chunk, byteStart, this._receivedLength);\n    }\n  }\n\n  _onWebSocketError(e) {\n    this._status = LoaderStatus.kError;\n    let info = {\n      code: e.code,\n      msg: e.message\n    };\n\n    if (this._onError) {\n      this._onError(LoaderErrors.EXCEPTION, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n}\n\nexport default WebSocketLoader;","map":{"version":3,"sources":["C:/Users/gethi/Desktop/React Apps/streams/client/node_modules/flv.js/src/io/websocket-loader.js"],"names":["Log","BaseLoader","LoaderStatus","LoaderErrors","RuntimeException","WebSocketLoader","isSupported","self","WebSocket","e","constructor","TAG","_needStash","_ws","_requestAbort","_receivedLength","destroy","abort","open","dataSource","ws","url","binaryType","onopen","_onWebSocketOpen","bind","onclose","_onWebSocketClose","onmessage","_onWebSocketMessage","onerror","_onWebSocketError","_status","kConnecting","kError","info","code","msg","message","_onError","EXCEPTION","readyState","close","kComplete","kBuffering","_onComplete","data","ArrayBuffer","_dispatchArrayBuffer","Blob","reader","FileReader","onload","result","readAsArrayBuffer","name","arraybuffer","chunk","byteStart","byteLength","_onDataArrival"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport {BaseLoader, LoaderStatus, LoaderErrors} from './loader.js';\nimport {RuntimeException} from '../utils/exception.js';\n\n// For FLV over WebSocket live stream\nclass WebSocketLoader extends BaseLoader {\n\n    static isSupported() {\n        try {\n            return (typeof self.WebSocket !== 'undefined');\n        } catch (e) {\n            return false;\n        }\n    }\n\n    constructor() {\n        super('websocket-loader');\n        this.TAG = 'WebSocketLoader';\n\n        this._needStash = true;\n\n        this._ws = null;\n        this._requestAbort = false;\n        this._receivedLength = 0;\n    }\n\n    destroy() {\n        if (this._ws) {\n            this.abort();\n        }\n        super.destroy();\n    }\n\n    open(dataSource) {\n        try {\n            let ws = this._ws = new self.WebSocket(dataSource.url);\n            ws.binaryType = 'arraybuffer';\n            ws.onopen = this._onWebSocketOpen.bind(this);\n            ws.onclose = this._onWebSocketClose.bind(this);\n            ws.onmessage = this._onWebSocketMessage.bind(this);\n            ws.onerror = this._onWebSocketError.bind(this);\n\n            this._status = LoaderStatus.kConnecting;\n        } catch (e) {\n            this._status = LoaderStatus.kError;\n\n            let info = {code: e.code, msg: e.message};\n\n            if (this._onError) {\n                this._onError(LoaderErrors.EXCEPTION, info);\n            } else {\n                throw new RuntimeException(info.msg);\n            }\n        }\n    }\n\n    abort() {\n        let ws = this._ws;\n        if (ws && (ws.readyState === 0 || ws.readyState === 1)) {  // CONNECTING || OPEN\n            this._requestAbort = true;\n            ws.close();\n        }\n\n        this._ws = null;\n        this._status = LoaderStatus.kComplete;\n    }\n\n    _onWebSocketOpen(e) {\n        this._status = LoaderStatus.kBuffering;\n    }\n\n    _onWebSocketClose(e) {\n        if (this._requestAbort === true) {\n            this._requestAbort = false;\n            return;\n        }\n\n        this._status = LoaderStatus.kComplete;\n\n        if (this._onComplete) {\n            this._onComplete(0, this._receivedLength - 1);\n        }\n    }\n\n    _onWebSocketMessage(e) {\n        if (e.data instanceof ArrayBuffer) {\n            this._dispatchArrayBuffer(e.data);\n        } else if (e.data instanceof Blob) {\n            let reader = new FileReader();\n            reader.onload = () => {\n                this._dispatchArrayBuffer(reader.result);\n            };\n            reader.readAsArrayBuffer(e.data);\n        } else {\n            this._status = LoaderStatus.kError;\n            let info = {code: -1, msg: 'Unsupported WebSocket message type: ' + e.data.constructor.name};\n\n            if (this._onError) {\n                this._onError(LoaderErrors.EXCEPTION, info);\n            } else {\n                throw new RuntimeException(info.msg);\n            }\n        }\n    }\n\n    _dispatchArrayBuffer(arraybuffer) {\n        let chunk = arraybuffer;\n        let byteStart = this._receivedLength;\n        this._receivedLength += chunk.byteLength;\n\n        if (this._onDataArrival) {\n            this._onDataArrival(chunk, byteStart, this._receivedLength);\n        }\n    }\n\n    _onWebSocketError(e) {\n        this._status = LoaderStatus.kError;\n\n        let info = {\n            code: e.code,\n            msg: e.message\n        };\n\n        if (this._onError) {\n            this._onError(LoaderErrors.EXCEPTION, info);\n        } else {\n            throw new RuntimeException(info.msg);\n        }\n    }\n\n}\n\nexport default WebSocketLoader;"]},"metadata":{},"sourceType":"module"}